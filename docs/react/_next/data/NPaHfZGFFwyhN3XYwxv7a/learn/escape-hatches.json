{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#referencing-values-with-refs\",\"depth\":2,\"text\":\"使用 ref 引用值 \"},{\"url\":\"#manipulating-the-dom-with-refs\",\"depth\":2,\"text\":\"使用 ref 操作 DOM \"},{\"url\":\"#synchronizing-with-effects\",\"depth\":2,\"text\":\"使用 Effect 实现同步 \"},{\"url\":\"#you-might-not-need-an-effect\",\"depth\":2,\"text\":\"你可能不需要 Effect \"},{\"url\":\"#lifecycle-of-reactive-effects\",\"depth\":2,\"text\":\"响应式 Effect 的生命周期 \"},{\"url\":\"#separating-events-from-effects\",\"depth\":2,\"text\":\"从 Effect 中分离事件 \"},{\"url\":\"#removing-effect-dependencies\",\"depth\":2,\"text\":\"移除 Effect 依赖 \"},{\"url\":\"#reusing-logic-with-custom-hooks\",\"depth\":2,\"text\":\"使用自定义 Hook 复用逻辑 \"},{\"url\":\"#whats-next\",\"depth\":2,\"text\":\"下节预告 \"}]","content":"[[\"$r\",\"MaxWidth\",\"12\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"有些组件可能需要控制和同步 React 之外的系统。例如，你可能需要使用浏览器 API 聚焦输入框，或者在没有 React 的情况下实现视频播放器，或者连接并监听远程服务器的消息。在本章中，你将学习到一些脱围机制，让你可以“走出” React 并连接到外部系统。大多数应用逻辑和数据流不应该依赖这些功能。\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"isChapter\":true,\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs\",\"children\":\"在不重新渲染的情况下“记住”信息\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs\",\"children\":\"访问 React 管理的 DOM 元素\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/synchronizing-with-effects\",\"children\":\"将组件与外部系统同步\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/you-might-not-need-an-effect\",\"children\":\"从组件中删除不必要的 Effect\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects\",\"children\":\"Effect 的生命周期与组件的生命周期有何不同\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/separating-events-from-effects\",\"children\":\"防止某些值重新触发 Effect\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/removing-effect-dependencies\",\"children\":\"减少 Effect 重新执行的频率\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/reusing-logic-with-custom-hooks\",\"children\":\"在组件之间共享逻辑\"}]}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"referencing-values-with-refs\",\"children\":\"使用 ref 引用值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你希望组件“记住”某些信息，但又不想让这些信息 \",[\"$r\",\"a\",null,{\"href\":\"/learn/render-and-commit\",\"children\":\"触发新的渲染\"}],\" 时，你可以使用 \",[\"$r\",\"strong\",null,{\"children\":\"ref\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const ref = useRef(0);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"与 state 一样，ref 在重新渲染之间由 React 保留。但是，设置 state 会重新渲染组件，而更改 ref 不会！你可以通过 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 属性访问该 ref 的当前值。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Counter() {\\n  let ref = useRef(0);\\n\\n  function handleClick() {\\n    ref.current = ref.current + 1;\\n    alert('你点击了 ' + ref.current + ' 次!');\\n  }\\n\\n  return (\\n    <button onClick={handleClick}>\\n      点我！\\n    </button>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"22\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"ref 就像组件的一个不被 React 追踪的秘密口袋。例如，可以使用 ref 来存储 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout#return_value\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"timeout ID\"}],\"、\",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DOM 元素\"}],\" 和其他不影响组件渲染输出的对象。\"]}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/referencing-values-with-refs\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs\",\"children\":\"使用 ref 引用值\"}]}],\" 以了解如何使用 ref 来记住信息。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"manipulating-the-dom-with-refs\",\"children\":\"使用 ref 操作 DOM \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"由于 React 会自动更新 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DOM\"}],\" 以匹配渲染输出，因此组件通常不需要操作 DOM。但是，有时可能需要访问由 React 管理的 DOM 元素——例如聚焦节点、滚动到此节点，以及测量它的尺寸和位置。React 没有内置的方法来执行此类操作，所以需要一个指向 DOM 节点的 ref 来实现。例如，点击按钮将使用 ref 聚焦输入框：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Form() {\\n  const inputRef = useRef(null);\\n\\n  function handleClick() {\\n    inputRef.current.focus();\\n  }\\n\\n  return (\\n    <>\\n      <input ref={inputRef} />\\n      <button onClick={handleClick}>\\n        聚焦输入框\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"32\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/manipulating-the-dom-with-refs\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs\",\"children\":\"使用 ref 操作 DOM\"}]}],\" 以了解如何访问 React 管理的 DOM 元素。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"synchronizing-with-effects\",\"children\":\"使用 Effect 实现同步 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"有些组件需要与外部系统同步。例如，可能需要根据 React 状态控制非 React 组件、设置服务器连接或在组件出现在屏幕上时发送分析日志。与处理特定事件的事件处理程序不同，\",[\"$r\",\"strong\",null,{\"children\":\"Effect\"}],\" 在渲染后运行一些代码。使用它将组件与 React 之外的系统同步。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"多按几次播放/暂停，观察视频播放器如何与 \",[\"$r\",\"code\",null,{\"children\":\"isPlaying\"}],\" 属性值保持同步：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef, useEffect } from 'react';\\n\\nfunction VideoPlayer({ src, isPlaying }) {\\n  const ref = useRef(null);\\n\\n  useEffect(() => {\\n    if (isPlaying) {\\n      ref.current.play();\\n    } else {\\n      ref.current.pause();\\n    }\\n  }, [isPlaying]);\\n\\n  return <video ref={ref} src={src} loop playsInline />;\\n}\\n\\nexport default function App() {\\n  const [isPlaying, setIsPlaying] = useState(false);\\n  return (\\n    <>\\n      <button onClick={() => setIsPlaying(!isPlaying)}>\\n        {isPlaying ? '暂停' : '播放'}\\n      </button>\\n      <VideoPlayer\\n        isPlaying={isPlaying}\\n        src=\\\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\\\"\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 20px; }\\nvideo { width: 250px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"36\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"许多 Effect 也会自行“清理”。例如，与聊天服务器建立连接的 Effect 应该返回一个 \",[\"$r\",\"strong\",null,{\"children\":\"cleanup 函数\"}],\"，告诉 React 如何断开组件与该服务器的连接：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nexport default function ChatRoom() {\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, []);\\n  return <h1>欢迎前来聊天！</h1>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection() {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接中...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开连接。');\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"68\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在开发环境中，React 将立即运行并额外清理一次 Effect。这就是为什么你会看到 \",[\"$r\",\"code\",null,{\"children\":\"\\\"✅ 连接中...\\\"\"}],\" 打印了两次。这能够确保你不会忘记实现清理功能。\"]}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/synchronizing-with-effects\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/synchronizing-with-effects\",\"children\":\"使用 Effect 实现同步\"}]}],\" 以了解如何将组件与外部系统同步。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"you-might-not-need-an-effect\",\"children\":\"你可能不需要 Effect \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Effect 是 React 范式中的一种脱围机制。它们可以“逃出” React 并使组件和一些外部系统同步。如果没有涉及到外部系统（例如，需要根据一些 props 或 state 的变化来更新一个组件的 state），不应该使用 Effect。移除不必要的 Effect 可以让代码更容易理解，运行得更快，并且更少出错。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"有两种常见的不必使用 Effect 的情况：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"strong\",null,{\"children\":\"不必为了渲染而使用 Effect 来转换数据。\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"strong\",null,{\"children\":\"不必使用 Effect 来处理用户事件。\"}]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"例如，不需要 Effect 来根据其他状态调整某些状态：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5-9}\",\"children\":\"function Form() {\\n  const [firstName, setFirstName] = useState('泰勒');\\n  const [lastName, setLastName] = useState('斯威夫特');\\n\\n  // 🔴 避免：多余的 state 和不必要的 Effect\\n  const [fullName, setFullName] = useState('');\\n  useEffect(() => {\\n    setFullName(firstName + ' ' + lastName);\\n  }, [firstName, lastName]);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"相反，在渲染时进行尽可能多地计算：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-5}\",\"children\":\"function Form() {\\n  const [firstName, setFirstName] = useState('泰勒');\\n  const [lastName, setLastName] = useState('斯威夫特');\\n  // ✅ 非常好：在渲染期间进行计算\\n  const fullName = firstName + ' ' + lastName;\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你 \",[\"$r\",\"strong\",null,{\"children\":\"的确\"}],\" 可以使用 Effect 来和外部系统同步。\"]}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/you-might-not-need-an-effect\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/you-might-not-need-an-effect\",\"children\":\"你可能不需要 Effect\"}]}],\" 以了解如何移除不必要的 Effect。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"lifecycle-of-reactive-effects\",\"children\":\"响应式 Effect 的生命周期 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Effect 的生命周期不同于组件。组件可以挂载、更新或卸载。Effect 只能做两件事：开始同步某些东西，然后停止同步它。如果 Effect 依赖于随时间变化的 props 和 state，这个循环可能会发生多次。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个 Effect 依赖于 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" props 的值。props 是 \",[\"$r\",\"strong\",null,{\"children\":\"响应值\"}],\"，这意味着它们可以在重新渲染时改变。注意，如果 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 更改，Effect 将会 \",[\"$r\",\"strong\",null,{\"children\":\"重新同步\"}],\"（并重新连接到服务器）：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n\\n  return <h1>欢迎来到 {roomId} 房间！</h1>;\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  return (\\n    <>\\n      <label>\\n        选择聊天室：{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">所有</option>\\n          <option value=\\\"travel\\\">旅游</option>\\n          <option value=\\\"music\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom roomId={roomId} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接到 \\\"' + roomId + '\\\" 房间，在' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开 \\\"' + roomId + '\\\" 房间，在' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"82\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 提供了检查工具规则来检查是否正确地指定了 Effect 的依赖项。如果忘记在上述示例的依赖项列表中指定 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\"，检查工具会自动找到该错误。\"]}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/lifecycle-of-reactive-effects\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects\",\"children\":\"响应式 Effect 的生命周期\"}]}],\" 以了解 Effect 的生命周期与组件的生命周期有何不同。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"separating-events-from-effects\",\"children\":\"从 Effect 中分离事件 \"}],\"\\n\",[\"$r\",\"Wip\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"本节描述了一个在稳定版本的 React 中 \",[\"$r\",\"strong\",null,{\"children\":\"尚未发布\"}],\" 的实验性 API。\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"事件处理程序仅在再次执行相同的交互时重新运行。与事件处理程序不同，如果 Effect 读取的任何值（如 props 或 state）与上次渲染期间不同，则会重新同步。有时，需要混合两种行为：Effect 重新运行以响应某些值而不是其他值。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Effect 中的所有代码都是 \",[\"$r\",\"strong\",null,{\"children\":\"响应式的\"}],\"。如果它读取的某些响应式的值由于重新渲染而发生变化，它将再次运行。例如，如果 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 发生变化，这个 Effect 将重新连接到聊天：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"latest\\\",\\n    \\\"react-dom\\\": \\\"latest\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection, sendMessage } from './chat.js';\\nimport { showNotification } from './notifications.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId, theme }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      showNotification('已连接！', theme);\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId, theme]);\\n\\n  return <h1>欢迎来到 {roomId} 房间！</h1>\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('所有');\\n  const [isDark, setIsDark] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        选择聊天室：{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">所有</option>\\n          <option value=\\\"travel\\\">旅游</option>\\n          <option value=\\\"music\\\">音乐</option>\\n        </select>\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        使用深色主题\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        theme={isDark ? 'dark' : 'light'} \\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现实际上会连接到服务器\\n  let connectedCallback;\\n  let timeout;\\n  return {\\n    connect() {\\n      timeout = setTimeout(() => {\\n        if (connectedCallback) {\\n          connectedCallback();\\n        }\\n      }, 100);\\n    },\\n    on(event, callback) {\\n      if (connectedCallback) {\\n        throw Error('不能添加处理程序两次。');\\n      }\\n      if (event !== 'connected') {\\n        throw Error('仅支持“已连接”事件。');\\n      }\\n      connectedCallback = callback;\\n    },\\n    disconnect() {\\n      clearTimeout(timeout);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"86\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这并不理想。因为仅当 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 已更改时，才想重新连接到聊天，所以切换 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 不应该重新连接到聊天！考虑将读取 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 的代码从 Effect 移到 \",[\"$r\",\"strong\",null,{\"children\":\"Effect Event\"}],\" 中：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\nimport { createConnection, sendMessage } from './chat.js';\\nimport { showNotification } from './notifications.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId, theme }) {\\n  const onConnected = useEffectEvent(() => {\\n    showNotification('已连接！', theme);\\n  });\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      onConnected();\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n\\n  return <h1>欢迎来到 {roomId} 房间！</h1>\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('所有');\\n  const [isDark, setIsDark] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        选择聊天室：{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">所有</option>\\n          <option value=\\\"travel\\\">旅游</option>\\n          <option value=\\\"music\\\">音乐</option>\\n        </select>\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        使用深色主题\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        theme={isDark ? 'dark' : 'light'} \\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现实际上会连接到服务器\\n  let connectedCallback;\\n  let timeout;\\n  return {\\n    connect() {\\n      timeout = setTimeout(() => {\\n        if (connectedCallback) {\\n          connectedCallback();\\n        }\\n      }, 100);\\n    },\\n    on(event, callback) {\\n      if (connectedCallback) {\\n        throw Error('不能添加处理程序两次。');\\n      }\\n      if (event !== 'connected') {\\n        throw Error('仅支持“已连接”事件。');\\n      }\\n      connectedCallback = callback;\\n    },\\n    disconnect() {\\n      clearTimeout(timeout);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js hidden\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"98\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Effect Events 中的代码不是响应式的，因此更改“主题”不再使 Effect 重新连接。\"}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/separating-events-from-effects\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/separating-events-from-effects\",\"children\":\"从 Effect 中分离事件\"}]}],\"，了解如何防止某些值重新触发 Effect。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"removing-effect-dependencies\",\"children\":\"移除 Effect 依赖 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"当你写 Effect 时，代码检查器会验证是否已经将 Effect 读取的每一个响应式值（如 props 和 state）包含在 Effect 的依赖列表中。这可以确保 Effect 与组件的 props 和 state 保持同步。不必要的依赖关系可能会导致 Effect 运行过于频繁，甚至产生无限循环。删除它们的方式取决于具体情况。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如，这个 Effect 依赖于每次编辑输入时都会重新创建的 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 对象：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n\\n  const options = {\\n    serverUrl: serverUrl,\\n    roomId: roomId\\n  };\\n\\n  useEffect(() => {\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [options]);\\n\\n  return (\\n    <>\\n      <h1>欢迎来到 {roomId} 房间！</h1>\\n      <input value={message} onChange={e => setMessage(e.target.value)} />\\n    </>\\n  );\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('所有');\\n  return (\\n    <>\\n      <label>\\n        选择聊天室：{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom roomId={roomId} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接到 \\\"' + roomId + '\\\" 房间，在' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开 \\\"' + roomId + '\\\" 房间，在' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"102\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你不希望每次开始在聊天中输入消息时聊天都重新连接。要解决这个问题，你应该在 Effect 中创建 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 对象，使得 Effect 仅依赖于 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 字符串：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n\\n  useEffect(() => {\\n    const options = {\\n      serverUrl: serverUrl,\\n      roomId: roomId\\n    };\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n\\n  return (\\n    <>\\n      <h1>欢迎来到 {roomId} 房间！</h1>\\n      <input value={message} onChange={e => setMessage(e.target.value)} />\\n    </>\\n  );\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('所有');\\n  return (\\n    <>\\n      <label>\\n        选择聊天室：{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">所有</option>\\n          <option value=\\\"travel\\\">旅游</option>\\n          <option value=\\\"music\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom roomId={roomId} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接到 \\\"' + roomId + '\\\" 房间，在' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开 \\\"' + roomId + '\\\" 房间，在' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"114\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，你并没有通过编辑依赖项列表来删除 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\"  依赖项，那是错误的。相反，你更改了周围的代码，使依赖关系变得 \",[\"$r\",\"strong\",null,{\"children\":\"不必要\"}],\"。将依赖关系列表视为 Effect 代码使用的所有响应值的列表。不必刻意选择把什么放在该列表中。该列表描述了你的代码。要改变依赖性列表，请改变代码。\"]}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/removing-effect-dependencies\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/removing-effect-dependencies\",\"children\":\"移除 Effect 依赖\"}]}],\" 以了解如何减少 Effect 重新运行的频率。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reusing-logic-with-custom-hooks\",\"children\":\"使用自定义 Hook 复用逻辑 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 有一些内置 Hook，例如 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"useEffect\"}],\"。有时需要用途更特殊的 Hook：例如获取数据，记录用户是否在线或者连接聊天室。为了实现效果，可以根据应用需求创建自己的 Hook。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个示例中，自定义 Hook \",[\"$r\",\"code\",null,{\"children\":\"usePointerPosition\"}],\" 追踪当前指针位置，而自定义 Hook \",[\"$r\",\"code\",null,{\"children\":\"useDelayedValue\"}],\" 返回一个“滞后”传递的值一定毫秒数的值。将光标移到沙盒预览区域上以查看跟随光标移动的点轨迹：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { usePointerPosition } from './usePointerPosition.js';\\nimport { useDelayedValue } from './useDelayedValue.js';\\n\\nexport default function Canvas() {\\n  const pos1 = usePointerPosition();\\n  const pos2 = useDelayedValue(pos1, 100);\\n  const pos3 = useDelayedValue(pos2, 200);\\n  const pos4 = useDelayedValue(pos3, 100);\\n  const pos5 = useDelayedValue(pos4, 50);\\n  return (\\n    <>\\n      <Dot position={pos1} opacity={1} />\\n      <Dot position={pos2} opacity={0.8} />\\n      <Dot position={pos3} opacity={0.6} />\\n      <Dot position={pos4} opacity={0.4} />\\n      <Dot position={pos5} opacity={0.2} />\\n    </>\\n  );\\n}\\n\\nfunction Dot({ position, opacity }) {\\n  return (\\n    <div style={{\\n      position: 'absolute',\\n      backgroundColor: 'pink',\\n      borderRadius: '50%',\\n      opacity,\\n      transform: `translate(${position.x}px, ${position.y}px)`,\\n      pointerEvents: 'none',\\n      left: -20,\\n      top: -20,\\n      width: 40,\\n      height: 40,\\n    }} />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/usePointerPosition.js\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nexport function usePointerPosition() {\\n  const [position, setPosition] = useState({ x: 0, y: 0 });\\n  useEffect(() => {\\n    function handleMove(e) {\\n      setPosition({ x: e.clientX, y: e.clientY });\\n    }\\n    window.addEventListener('pointermove', handleMove);\\n    return () => window.removeEventListener('pointermove', handleMove);\\n  }, []);\\n  return position;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/useDelayedValue.js\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nexport function useDelayedValue(value, delay) {\\n  const [delayedValue, setDelayedValue] = useState(value);\\n\\n  useEffect(() => {\\n    setTimeout(() => {\\n      setDelayedValue(value);\\n    }, delay);\\n  }, [value, delay]);\\n\\n  return delayedValue;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { min-height: 300px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可以创建自定义 Hooks，将它们组合在一起，在它们之间传递数据，并在组件之间重用它们。随着应用不断变大，你将减少手动编写的 Effect，因为你将能够重用已经编写的自定义 Hooks。React 社区也维护了许多优秀的自定义 Hooks。\"}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/reusing-logic-with-custom-hooks\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/reusing-logic-with-custom-hooks\",\"children\":\"使用自定义 Hook 复用逻辑\"}]}],\" 以了解如何在组件之间共享逻辑。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"whats-next\",\"children\":\"下节预告 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"跳转到 \",[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs\",\"children\":\"使用 ref 引用值\"}],\" 这一节并开始一页页的阅读！\"]}]]}]]","meta":{"title":"脱围机制"}},"__N_SSG":true}