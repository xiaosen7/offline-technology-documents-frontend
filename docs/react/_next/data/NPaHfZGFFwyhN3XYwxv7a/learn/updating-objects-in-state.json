{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#whats-a-mutation\",\"depth\":2,\"text\":\"什么是 mutation？ \"},{\"url\":\"#treat-state-as-read-only\",\"depth\":2,\"text\":\"将 state 视为只读的 \"},{\"url\":\"#copying-objects-with-the-spread-syntax\",\"depth\":2,\"text\":\"使用展开语法复制对象 \"},{\"url\":\"#updating-a-nested-object\",\"depth\":2,\"text\":\"更新一个嵌套对象 \"},{\"url\":\"#write-concise-update-logic-with-immer\",\"depth\":3,\"text\":\"使用 Immer 编写简洁的更新逻辑 \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"32\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"state 中可以保存任意类型的 JavaScript 值，包括对象。但是，你不应该直接修改存放在 React state 中的对象。相反，当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份），然后将 state 更新为此对象。\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何正确地更新 React state 中的对象\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何在不产生 mutation 的情况下更新一个嵌套对象\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"什么是不可变性（immutability），以及如何不破坏它\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何使用 Immer 使复制对象不那么繁琐\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"whats-a-mutation\",\"children\":\"什么是 mutation？ \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可以在 state 中存放任意类型的 JavaScript 值。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [x, setX] = useState(0);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"到目前为止，你已经尝试过在 state 中存放数字、字符串和布尔值，这些类型的值在 JavaScript 中是不可变（immutable）的，这意味着它们不能被改变或是只读的。你可以通过替换它们的值以触发一次重新渲染。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setX(5);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"state \",[\"$r\",\"code\",null,{\"children\":\"x\"}],\" 从 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" 变为 \",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"，但是数字 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" 本身并没有发生改变。在 JavaScript 中，无法对内置的原始值，如数字、字符串和布尔值，进行任何更改。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在考虑 state 中存放对象的情况：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [position, setPosition] = useState({ x: 0, y: 0 });\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"从技术上来讲，可以改变对象自身的内容。\",[\"$r\",\"strong\",null,{\"children\":\"当你这样做时，就制造了一个 mutation\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"position.x = 5;\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"然而，虽然严格来说 React state 中存放的对象是可变的，但你应该像处理数字、布尔值、字符串一样将它们视为不可变的。因此你应该替换它们的值，而不是对它们进行修改。\"}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"treat-state-as-read-only\",\"children\":\"将 state 视为只读的 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"换句话说，你应该 \",[\"$r\",\"strong\",null,{\"children\":\"把所有存放在 state 中的 JavaScript 对象都视为只读的\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在下面的例子中，我们用一个存放在 state 中的对象来表示指针当前的位置。当你在预览区触摸或移动光标时，红色的点本应移动。但是实际上红点仍停留在原处：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\nexport default function MovingDot() {\\n  const [position, setPosition] = useState({\\n    x: 0,\\n    y: 0\\n  });\\n  return (\\n    <div\\n      onPointerMove={e => {\\n        position.x = e.clientX;\\n        position.y = e.clientY;\\n      }}\\n      style={{\\n        position: 'relative',\\n        width: '100vw',\\n        height: '100vh',\\n      }}>\\n      <div style={{\\n        position: 'absolute',\\n        backgroundColor: 'red',\\n        borderRadius: '50%',\\n        transform: `translate(${position.x}px, ${position.y}px)`,\\n        left: -10,\\n        top: -10,\\n        width: 20,\\n        height: 20,\\n      }} />\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { margin: 0; padding: 0; height: 250px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"50\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"问题出在下面这段代码中。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"onPointerMove={e => {\\n  position.x = e.clientX;\\n  position.y = e.clientY;\\n}}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这段代码直接修改了 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time\",\"children\":\"上一次渲染中\"}],\" 分配给 \",[\"$r\",\"code\",null,{\"children\":\"position\"}],\" 的对象。但是因为并没有使用 state 的设置函数，React 并不知道对象已更改。所以 React 没有做出任何响应。这就像在吃完饭之后才尝试去改变要点的菜一样。虽然在一些情况下，直接修改 state 可能是有效的，但我们并不推荐这么做。你应该把在渲染过程中可以访问到的 state 视为只读的。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这种情况下，为了真正地 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot#setting-state-triggers-renders\",\"children\":\"触发一次重新渲染\"}],\"，\",[\"$r\",\"strong\",null,{\"children\":\"你需要创建一个新对象并把它传递给 state 的设置函数\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"onPointerMove={e => {\\n  setPosition({\\n    x: e.clientX,\\n    y: e.clientY\\n  });\\n}}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通过使用 \",[\"$r\",\"code\",null,{\"children\":\"setPosition\"}],\"，你在告诉 React：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用这个新的对象替换 \",[\"$r\",\"code\",null,{\"children\":\"position\"}],\" 的值\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"然后再次渲染这个组件\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在你可以看到，当你在预览区触摸或移动光标时，红点会跟随着你的指针移动：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\nexport default function MovingDot() {\\n  const [position, setPosition] = useState({\\n    x: 0,\\n    y: 0\\n  });\\n  return (\\n    <div\\n      onPointerMove={e => {\\n        setPosition({\\n          x: e.clientX,\\n          y: e.clientY\\n        });\\n      }}\\n      style={{\\n        position: 'relative',\\n        width: '100vw',\\n        height: '100vh',\\n      }}>\\n      <div style={{\\n        position: 'absolute',\\n        backgroundColor: 'red',\\n        borderRadius: '50%',\\n        transform: `translate(${position.x}px, ${position.y}px)`,\\n        left: -10,\\n        top: -10,\\n        width: 20,\\n        height: 20,\\n      }} />\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { margin: 0; padding: 0; height: 250px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"60\",{\"children\":[\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"local-mutation-is-fine\",\"children\":\"局部 mutation 是可以接受的 \"}],[\"$r\",\"p\",null,{\"children\":\"像这样的代码是有问题的，因为它改变了 state 中现有的对象：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"position.x = e.clientX;\\nposition.y = e.clientY;\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"但是像这样的代码就 \",[\"$r\",\"strong\",null,{\"children\":\"没有任何问题\"}],\"，因为你改变的是你刚刚创建的一个新的对象：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const nextPosition = {};\\nnextPosition.x = e.clientX;\\nnextPosition.y = e.clientY;\\nsetPosition(nextPosition);\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"事实上，它完全等同于下面这种写法：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setPosition({\\n  x: e.clientX,\\n  y: e.clientY\\n});\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"只有当你改变已经处于 state 中的 \",[\"$r\",\"strong\",null,{\"children\":\"现有\"}],\" 对象时，mutation 才会成为问题。而修改一个你刚刚创建的对象就不会出现任何问题，因为 \",[\"$r\",\"strong\",null,{\"children\":\"还没有其他的代码引用它\"}],\"。改变它并不会意外地影响到依赖它的东西。这叫做“局部 mutation”。你甚至可以 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure#local-mutation-your-components-little-secret\",\"children\":\"在渲染的过程中\"}],\" 进行“局部 mutation”的操作。这种操作既便捷又没有任何问题！\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"copying-objects-with-the-spread-syntax\",\"children\":\"使用展开语法复制对象 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在之前的例子中，始终会根据当前指针的位置创建出一个新的 \",[\"$r\",\"code\",null,{\"children\":\"position\"}],\" 对象。但是通常，你会希望把 \",[\"$r\",\"strong\",null,{\"children\":\"现有\"}],\" 数据作为你所创建的新对象的一部分。例如，你可能只想要更新表单中的一个字段，其他的字段仍然使用之前的值。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"下面的代码中，输入框并不会正常运行，因为 \",[\"$r\",\"code\",null,{\"children\":\"onChange\"}],\" 直接修改了 state ：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [person, setPerson] = useState({\\n    firstName: 'Barbara',\\n    lastName: 'Hepworth',\\n    email: 'bhepworth@sculpture.com'\\n  });\\n\\n  function handleFirstNameChange(e) {\\n    person.firstName = e.target.value;\\n  }\\n\\n  function handleLastNameChange(e) {\\n    person.lastName = e.target.value;\\n  }\\n\\n  function handleEmailChange(e) {\\n    person.email = e.target.value;\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        First name:\\n        <input\\n          value={person.firstName}\\n          onChange={handleFirstNameChange}\\n        />\\n      </label>\\n      <label>\\n        Last name:\\n        <input\\n          value={person.lastName}\\n          onChange={handleLastNameChange}\\n        />\\n      </label>\\n      <label>\\n        Email:\\n        <input\\n          value={person.email}\\n          onChange={handleEmailChange}\\n        />\\n      </label>\\n      <p>\\n        {person.firstName}{' '}\\n        {person.lastName}{' '}\\n        ({person.email})\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"78\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"例如，下面这行代码修改了上一次渲染中的 state：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"person.firstName = e.target.value;\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"想要实现你的需求，最可靠的办法就是创建一个新的对象并将它传递给 \",[\"$r\",\"code\",null,{\"children\":\"setPerson\"}],\"。但是在这里，你还需要 \",[\"$r\",\"strong\",null,{\"children\":\"把当前的数据复制到新对象中\"}],\"，因为你只改变了其中一个字段：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setPerson({\\n  firstName: e.target.value, // 从 input 中获取新的 first name\\n  lastName: person.lastName,\\n  email: person.email\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"...\"}],\" \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"对象展开\"}],\" 语法，这样你就不需要单独复制每个属性。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setPerson({\\n  ...person, // 复制上一个 person 中的所有字段\\n  firstName: e.target.value // 但是覆盖 firstName 字段 \\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在表单可以正常运行了！\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"可以看到，你并没有为每个输入框单独声明一个 state。对于大型表单，将所有数据都存放在同一个对象中是非常方便的——前提是你能够正确地更新它！\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [person, setPerson] = useState({\\n    firstName: 'Barbara',\\n    lastName: 'Hepworth',\\n    email: 'bhepworth@sculpture.com'\\n  });\\n\\n  function handleFirstNameChange(e) {\\n    setPerson({\\n      ...person,\\n      firstName: e.target.value\\n    });\\n  }\\n\\n  function handleLastNameChange(e) {\\n    setPerson({\\n      ...person,\\n      lastName: e.target.value\\n    });\\n  }\\n\\n  function handleEmailChange(e) {\\n    setPerson({\\n      ...person,\\n      email: e.target.value\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        First name:\\n        <input\\n          value={person.firstName}\\n          onChange={handleFirstNameChange}\\n        />\\n      </label>\\n      <label>\\n        Last name:\\n        <input\\n          value={person.lastName}\\n          onChange={handleLastNameChange}\\n        />\\n      </label>\\n      <label>\\n        Email:\\n        <input\\n          value={person.email}\\n          onChange={handleEmailChange}\\n        />\\n      </label>\\n      <p>\\n        {person.firstName}{' '}\\n        {person.lastName}{' '}\\n        ({person.email})\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"104\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意 \",[\"$r\",\"code\",null,{\"children\":\"...\"}],\" 展开语法本质是是“浅拷贝”——它只会复制一层。这使得它的执行速度很快，但是也意味着当你想要更新一个嵌套属性时，你必须得多次使用展开语法。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"using-a-single-event-handler-for-multiple-fields\",\"children\":\"使用一个事件处理函数来更新多个字段 \"}],[\"$r\",\"p\",null,{\"children\":[\"你也可以在对象的定义中使用 \",[\"$r\",\"code\",null,{\"children\":\"[\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"]\"}],\" 括号来实现属性的动态命名。下面是同一个例子，但它使用了一个事件处理函数而不是三个：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [person, setPerson] = useState({\\n    firstName: 'Barbara',\\n    lastName: 'Hepworth',\\n    email: 'bhepworth@sculpture.com'\\n  });\\n\\n  function handleChange(e) {\\n    setPerson({\\n      ...person,\\n      [e.target.name]: e.target.value\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        First name:\\n        <input\\n          name=\\\"firstName\\\"\\n          value={person.firstName}\\n          onChange={handleChange}\\n        />\\n      </label>\\n      <label>\\n        Last name:\\n        <input\\n          name=\\\"lastName\\\"\\n          value={person.lastName}\\n          onChange={handleChange}\\n        />\\n      </label>\\n      <label>\\n        Email:\\n        <input\\n          name=\\\"email\\\"\\n          value={person.email}\\n          onChange={handleChange}\\n        />\\n      </label>\\n      <p>\\n        {person.firstName}{' '}\\n        {person.lastName}{' '}\\n        ({person.email})\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"在这里，\",[\"$r\",\"code\",null,{\"children\":\"e.target.name\"}],\" 引用了 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" 这个 DOM 元素的 \",[\"$r\",\"code\",null,{\"children\":\"name\"}],\" 属性。\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"updating-a-nested-object\",\"children\":\"更新一个嵌套对象 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"考虑下面这种结构的嵌套对象：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [person, setPerson] = useState({\\n  name: 'Niki de Saint Phalle',\\n  artwork: {\\n    title: 'Blue Nana',\\n    city: 'Hamburg',\\n    image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\n  }\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你想要更新 \",[\"$r\",\"code\",null,{\"children\":\"person.artwork.city\"}],\" 的值，用 mutation 来实现的方法非常容易理解：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"person.artwork.city = 'New Delhi';\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"但是在 React 中，你需要将 state 视为不可变的！为了修改 \",[\"$r\",\"code\",null,{\"children\":\"city\"}],\" 的值，你首先需要创建一个新的 \",[\"$r\",\"code\",null,{\"children\":\"artwork\"}],\" 对象（其中预先填充了上一个 \",[\"$r\",\"code\",null,{\"children\":\"artwork\"}],\" 对象中的数据），然后创建一个新的 \",[\"$r\",\"code\",null,{\"children\":\"person\"}],\" 对象，并使得其中的 \",[\"$r\",\"code\",null,{\"children\":\"artwork\"}],\" 属性指向新创建的 \",[\"$r\",\"code\",null,{\"children\":\"artwork\"}],\" 对象：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const nextArtwork = { ...person.artwork, city: 'New Delhi' };\\nconst nextPerson = { ...person, artwork: nextArtwork };\\nsetPerson(nextPerson);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"或者，写成一个函数调用：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setPerson({\\n  ...person, // 复制其它字段的数据 \\n  artwork: { // 替换 artwork 字段 \\n    ...person.artwork, // 复制之前 person.artwork 中的数据\\n    city: 'New Delhi' // 但是将 city 的值替换为 New Delhi！\\n  }\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这虽然看起来有点冗长，但对于很多情况都能有效地解决问题：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [person, setPerson] = useState({\\n    name: 'Niki de Saint Phalle',\\n    artwork: {\\n      title: 'Blue Nana',\\n      city: 'Hamburg',\\n      image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\n    }\\n  });\\n\\n  function handleNameChange(e) {\\n    setPerson({\\n      ...person,\\n      name: e.target.value\\n    });\\n  }\\n\\n  function handleTitleChange(e) {\\n    setPerson({\\n      ...person,\\n      artwork: {\\n        ...person.artwork,\\n        title: e.target.value\\n      }\\n    });\\n  }\\n\\n  function handleCityChange(e) {\\n    setPerson({\\n      ...person,\\n      artwork: {\\n        ...person.artwork,\\n        city: e.target.value\\n      }\\n    });\\n  }\\n\\n  function handleImageChange(e) {\\n    setPerson({\\n      ...person,\\n      artwork: {\\n        ...person.artwork,\\n        image: e.target.value\\n      }\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        Name:\\n        <input\\n          value={person.name}\\n          onChange={handleNameChange}\\n        />\\n      </label>\\n      <label>\\n        Title:\\n        <input\\n          value={person.artwork.title}\\n          onChange={handleTitleChange}\\n        />\\n      </label>\\n      <label>\\n        City:\\n        <input\\n          value={person.artwork.city}\\n          onChange={handleCityChange}\\n        />\\n      </label>\\n      <label>\\n        Image:\\n        <input\\n          value={person.artwork.image}\\n          onChange={handleImageChange}\\n        />\\n      </label>\\n      <p>\\n        <i>{person.artwork.title}</i>\\n        {' by '}\\n        {person.name}\\n        <br />\\n        (located in {person.artwork.city})\\n      </p>\\n      <img \\n        src={person.artwork.image} \\n        alt={person.artwork.title}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\ninput { margin-left: 5px; margin-bottom: 5px; }\\nimg { width: 200px; height: 200px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"124\",{\"children\":[\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"objects-are-not-really-nested\",\"children\":\"对象并非是真正嵌套的 \"}],[\"$r\",\"p\",null,{\"children\":\"下面这个对象从代码上来看是“嵌套”的：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let obj = {\\n  name: 'Niki de Saint Phalle',\\n  artwork: {\\n    title: 'Blue Nana',\\n    city: 'Hamburg',\\n    image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\n  }\\n};\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"然而，当我们思考对象的特性时，“嵌套”并不是一个非常准确的方式。当这段代码运行的时候，不存在“嵌套”的对象。你实际上看到的是两个不同的对象：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let obj1 = {\\n  title: 'Blue Nana',\\n  city: 'Hamburg',\\n  image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\n};\\n\\nlet obj2 = {\\n  name: 'Niki de Saint Phalle',\\n  artwork: obj1\\n};\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"对象 \",[\"$r\",\"code\",null,{\"children\":\"obj1\"}],\" 并不处于 \",[\"$r\",\"code\",null,{\"children\":\"obj2\"}],\" 的“内部”。例如，下面的代码中，\",[\"$r\",\"code\",null,{\"children\":\"obj3\"}],\" 中的属性也可以指向 \",[\"$r\",\"code\",null,{\"children\":\"obj1\"}],\"：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let obj1 = {\\n  title: 'Blue Nana',\\n  city: 'Hamburg',\\n  image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\n};\\n\\nlet obj2 = {\\n  name: 'Niki de Saint Phalle',\\n  artwork: obj1\\n};\\n\\nlet obj3 = {\\n  name: 'Copycat',\\n  artwork: obj1\\n};\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"如果你直接修改 \",[\"$r\",\"code\",null,{\"children\":\"obj3.artwork.city\"}],\"，就会同时影响 \",[\"$r\",\"code\",null,{\"children\":\"obj2.artwork.city\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"obj1.city\"}],\"。这是因为 \",[\"$r\",\"code\",null,{\"children\":\"obj3.artwork\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"obj2.artwork\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"obj1\"}],\" 都指向同一个对象。当你用“嵌套”的方式看待对象时，很难看出这一点。相反，它们是相互独立的对象，只不过是用属性“指向”彼此而已。\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"write-concise-update-logic-with-immer\",\"children\":\"使用 Immer 编写简洁的更新逻辑 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你的 state 有多层的嵌套，你或许应该考虑 \",[\"$r\",\"a\",null,{\"href\":\"/learn/choosing-the-state-structure#avoid-deeply-nested-state\",\"children\":\"将其扁平化\"}],\"。但是，如果你不想改变 state 的数据结构，你可能更喜欢用一种更便捷的方式来实现嵌套展开的效果。\",[\"$r\",\"a\",null,{\"href\":\"https://github.com/immerjs/use-immer\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Immer\"}],\" 是一个非常流行的库，它可以让你使用简便但可以直接修改的语法编写代码，并会帮你处理好复制的过程。通过使用 Immer，你写出的代码看起来就像是你“打破了规则”而直接修改了对象：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"updatePerson(draft => {\\n  draft.artwork.city = 'Lagos';\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"但是不同于一般的 mutation，它并不会覆盖之前的 state！\"}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"how-does-immer-work\",\"children\":\"Immer 是如何运行的？ \"}],[\"$r\",\"p\",null,{\"children\":[\"由 Immer 提供的 \",[\"$r\",\"code\",null,{\"children\":\"draft\"}],\" 是一种特殊类型的对象，被称为 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Proxy\"}],\"，它会记录你用它所进行的操作。这就是你能够随心所欲地直接修改对象的原因所在！从原理上说，Immer 会弄清楚 \",[\"$r\",\"code\",null,{\"children\":\"draft\"}],\" 对象的哪些部分被改变了，并会依照你的修改创建出一个全新的对象。\"]}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"尝试使用 Immer:\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"运行 \",[\"$r\",\"code\",null,{\"children\":\"npm install use-immer\"}],\" 添加 Immer 依赖\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"用 \",[\"$r\",\"code\",null,{\"children\":\"import { useImmer } from 'use-immer'\"}],\" 替换掉 \",[\"$r\",\"code\",null,{\"children\":\"import { useState } from 'react'\"}]]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"下面我们把上面的例子用 Immer 实现一下：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useImmer } from 'use-immer';\\n\\nexport default function Form() {\\n  const [person, updatePerson] = useImmer({\\n    name: 'Niki de Saint Phalle',\\n    artwork: {\\n      title: 'Blue Nana',\\n      city: 'Hamburg',\\n      image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\n    }\\n  });\\n\\n  function handleNameChange(e) {\\n    updatePerson(draft => {\\n      draft.name = e.target.value;\\n    });\\n  }\\n\\n  function handleTitleChange(e) {\\n    updatePerson(draft => {\\n      draft.artwork.title = e.target.value;\\n    });\\n  }\\n\\n  function handleCityChange(e) {\\n    updatePerson(draft => {\\n      draft.artwork.city = e.target.value;\\n    });\\n  }\\n\\n  function handleImageChange(e) {\\n    updatePerson(draft => {\\n      draft.artwork.image = e.target.value;\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        Name:\\n        <input\\n          value={person.name}\\n          onChange={handleNameChange}\\n        />\\n      </label>\\n      <label>\\n        Title:\\n        <input\\n          value={person.artwork.title}\\n          onChange={handleTitleChange}\\n        />\\n      </label>\\n      <label>\\n        City:\\n        <input\\n          value={person.artwork.city}\\n          onChange={handleCityChange}\\n        />\\n      </label>\\n      <label>\\n        Image:\\n        <input\\n          value={person.artwork.image}\\n          onChange={handleImageChange}\\n        />\\n      </label>\\n      <p>\\n        <i>{person.artwork.title}</i>\\n        {' by '}\\n        {person.name}\\n        <br />\\n        (located in {person.artwork.city})\\n      </p>\\n      <img \\n        src={person.artwork.image} \\n        alt={person.artwork.title}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"immer\\\": \\\"1.7.3\\\",\\n    \\\"react\\\": \\\"latest\\\",\\n    \\\"react-dom\\\": \\\"latest\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\ninput { margin-left: 5px; margin-bottom: 5px; }\\nimg { width: 200px; height: 200px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"132\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"可以看到，事件处理函数变得更简洁了。你可以随意在一个组件中同时使用 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"useImmer\"}],\"。如果你想要写出更简洁的更新处理函数，Immer 会是一个不错的选择，尤其是当你的 state 中有嵌套，并且复制对象会带来重复的代码时。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"why-is-mutating-state-not-recommended-in-react\",\"children\":\"为什么在 React 中不推荐直接修改 state？ \"}],[\"$r\",\"p\",null,{\"children\":\"有以下几个原因：\"}],[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"调试\"}],\"：如果你使用 \",[\"$r\",\"code\",null,{\"children\":\"console.log\"}],\" 并且不直接修改 state，你之前日志中的 state 的值就不会被新的 state 变化所影响。这样你就可以清楚地看到两次渲染之间 state 的值发生了什么变化\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"优化\"}],\"：React 常见的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":\"优化策略\"}],\" 依赖于如果之前的 props 或者 state 的值和下一次相同就跳过渲染。如果你从未直接修改 state ，那么你就可以很快看到 state 是否发生了变化。如果 \",[\"$r\",\"code\",null,{\"children\":\"prevObj === obj\"}],\"，那么你就可以肯定这个对象内部并没有发生改变。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"新功能\"}],\"：我们正在构建的 React 的新功能依赖于 state 被 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"像快照一样看待\"}],\" 的理念。如果你直接修改 state 的历史版本，可能会影响你使用这些新功能。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"需求变更\"}],\"：有些应用功能在不出现任何修改的情况下会更容易实现，比如实现撤销/恢复、展示修改历史，或是允许用户把表单重置成某个之前的值。这是因为你可以把 state 之前的拷贝保存到内存中，并适时对其进行再次使用。如果一开始就用了直接修改 state 的方式，那么后面要实现这样的功能就会变得非常困难。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"更简单的实现\"}],\"：React 并不依赖于 mutation ，所以你不需要对对象进行任何特殊操作。它不需要像很多“响应式”的解决方案一样去劫持对象的属性、总是用代理把对象包裹起来，或者在初始化时做其他工作。这也是为什么 React 允许你把任何对象存放在 state 中——不管对象有多大——而不会造成有任何额外的性能或正确性问题的原因。\"]}],\"\\n\"]}],[\"$r\",\"p\",null,{\"children\":\"在实践中，你经常可以“侥幸”直接修改 state 而不出现什么问题，但是我们强烈建议你不要这样做，这样你就可以使用我们秉承着这种理念开发的 React 新功能。未来的贡献者甚至是你未来的自己都会感谢你的！\"}]]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"将 React 中所有的 state 都视为不可直接修改的。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"当你在 state 中存放对象时，直接修改对象并不会触发重渲染，并会改变前一次渲染“快照”中 state 的值。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"不要直接修改一个对象，而要为它创建一个 \",[\"$r\",\"strong\",null,{\"children\":\"新\"}],\" 版本，并通过把 state 设置成这个新版本来触发重新渲染。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你可以使用这样的 \",[\"$r\",\"code\",null,{\"children\":\"{...obj, something: 'newValue'}\"}],\" 对象展开语法来创建对象的拷贝。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"对象的展开语法是浅层的：它的复制深度只有一层。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"想要更新嵌套对象，你需要从你更新的位置开始自底向上为每一层都创建新的拷贝。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"想要减少重复的拷贝代码，可以使用 Immer。\"}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"fix-incorrect-state-updates\",\"children\":\"修复错误的 state 更新代码 \"}],[\"$r\",\"p\",null,{\"children\":\"这个表单有几个 bug。试着点击几次增加分数的按钮。你会注意到分数并没有增加。然后试着编辑一下名字字段，你会注意到分数突然“响应”了你之前的修改。最后，试着编辑一下姓氏字段，你会发现分数完全消失了。\"}],[\"$r\",\"p\",null,{\"children\":\"你的任务就是修复所有的这些 bug。在你修复它们的同时，解释一下它们为什么会产生。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Scoreboard() {\\n  const [player, setPlayer] = useState({\\n    firstName: 'Ranjani',\\n    lastName: 'Shettar',\\n    score: 10,\\n  });\\n\\n  function handlePlusClick() {\\n    player.score++;\\n  }\\n\\n  function handleFirstNameChange(e) {\\n    setPlayer({\\n      ...player,\\n      firstName: e.target.value,\\n    });\\n  }\\n\\n  function handleLastNameChange(e) {\\n    setPlayer({\\n      lastName: e.target.value\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        Score: <b>{player.score}</b>\\n        {' '}\\n        <button onClick={handlePlusClick}>\\n          +1\\n        </button>\\n      </label>\\n      <label>\\n        First name:\\n        <input\\n          value={player.firstName}\\n          onChange={handleFirstNameChange}\\n        />\\n      </label>\\n      <label>\\n        Last name:\\n        <input\\n          value={player.lastName}\\n          onChange={handleLastNameChange}\\n        />\\n      </label>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-bottom: 10px; }\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"下面是两个 bug 都得到修复后的代码：\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Scoreboard() {\\n  const [player, setPlayer] = useState({\\n    firstName: 'Ranjani',\\n    lastName: 'Shettar',\\n    score: 10,\\n  });\\n\\n  function handlePlusClick() {\\n    setPlayer({\\n      ...player,\\n      score: player.score + 1,\\n    });\\n  }\\n\\n  function handleFirstNameChange(e) {\\n    setPlayer({\\n      ...player,\\n      firstName: e.target.value,\\n    });\\n  }\\n\\n  function handleLastNameChange(e) {\\n    setPlayer({\\n      ...player,\\n      lastName: e.target.value\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        Score: <b>{player.score}</b>\\n        {' '}\\n        <button onClick={handlePlusClick}>\\n          +1\\n        </button>\\n      </label>\\n      <label>\\n        First name:\\n        <input\\n          value={player.firstName}\\n          onChange={handleFirstNameChange}\\n        />\\n      </label>\\n      <label>\\n        Last name:\\n        <input\\n          value={player.lastName}\\n          onChange={handleLastNameChange}\\n        />\\n      </label>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"代码中 \",[\"$r\",\"code\",null,{\"children\":\"handlePlusClick\"}],\" 函数的问题在于它直接修改了 \",[\"$r\",\"code\",null,{\"children\":\"player\"}],\" 对象。这就造成了 React 并不知道需要重新渲染的原因，也就没有更新屏幕上分数的值。这就是为什么，当你修改名字字段的时候，state 发生了更新，state 更新触发了重新渲染，重新渲染\",[\"$r\",\"strong\",null,{\"children\":\"同时也\"}],\"更新了屏幕上的分数。\"]}],[\"$r\",\"p\",null,{\"children\":[\"代码中 \",[\"$r\",\"code\",null,{\"children\":\"handleLastNameChange\"}],\" 的问题在于它没有把 \",[\"$r\",\"code\",null,{\"children\":\"...player\"}],\" 中已有的属性复制到新的对象中。因此，当你编辑姓氏字段时，分数就丢失了。\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"find-and-fix-the-mutation\",\"children\":\"发现并修复 mutation \"}],[\"$r\",\"p\",null,{\"children\":\"在静止的背景上有一个可以拖动的方形。你可以使用下拉框来修改方形的颜色。\"}],[\"$r\",\"p\",null,{\"children\":[\"但是这里有个 bug。当你先移动了方形，再去修改它的颜色时，背景会突然“跳”到方形所在的位置（实际上背景的位置并不应该发生变化！）。但是这并不是我们想要的，\",[\"$r\",\"code\",null,{\"children\":\"Background\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"position\"}],\" 属性被设置为 \",[\"$r\",\"code\",null,{\"children\":\"initialPosition\"}],\"，也就是 \",[\"$r\",\"code\",null,{\"children\":\"{ x: 0, y: 0 }\"}],\"。为什么修改颜色之后，背景会移动呢？\"]}],[\"$r\",\"p\",null,{\"children\":\"找到 bug 并修复它。\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"如果有一些出乎意料的改变，就是 mutation，在 \",[\"$r\",\"code\",null,{\"children\":\"App.js\"}],\" 中找到 mutation 并修复它。\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport Background from './Background.js';\\nimport Box from './Box.js';\\n\\nconst initialPosition = {\\n  x: 0,\\n  y: 0\\n};\\n\\nexport default function Canvas() {\\n  const [shape, setShape] = useState({\\n    color: 'orange',\\n    position: initialPosition\\n  });\\n\\n  function handleMove(dx, dy) {\\n    shape.position.x += dx;\\n    shape.position.y += dy;\\n  }\\n\\n  function handleColorChange(e) {\\n    setShape({\\n      ...shape,\\n      color: e.target.value\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <select\\n        value={shape.color}\\n        onChange={handleColorChange}\\n      >\\n        <option value=\\\"orange\\\">orange</option>\\n        <option value=\\\"lightpink\\\">lightpink</option>\\n        <option value=\\\"aliceblue\\\">aliceblue</option>\\n      </select>\\n      <Background\\n        position={initialPosition}\\n      />\\n      <Box\\n        color={shape.color}\\n        position={shape.position}\\n        onMove={handleMove}\\n      >\\n        Drag me!\\n      </Box>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Box.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Box({\\n  children,\\n  color,\\n  position,\\n  onMove\\n}) {\\n  const [\\n    lastCoordinates,\\n    setLastCoordinates\\n  ] = useState(null);\\n\\n  function handlePointerDown(e) {\\n    e.target.setPointerCapture(e.pointerId);\\n    setLastCoordinates({\\n      x: e.clientX,\\n      y: e.clientY,\\n    });\\n  }\\n\\n  function handlePointerMove(e) {\\n    if (lastCoordinates) {\\n      setLastCoordinates({\\n        x: e.clientX,\\n        y: e.clientY,\\n      });\\n      const dx = e.clientX - lastCoordinates.x;\\n      const dy = e.clientY - lastCoordinates.y;\\n      onMove(dx, dy);\\n    }\\n  }\\n\\n  function handlePointerUp(e) {\\n    setLastCoordinates(null);\\n  }\\n\\n  return (\\n    <div\\n      onPointerDown={handlePointerDown}\\n      onPointerMove={handlePointerMove}\\n      onPointerUp={handlePointerUp}\\n      style={{\\n        width: 100,\\n        height: 100,\\n        cursor: 'grab',\\n        backgroundColor: color,\\n        position: 'absolute',\\n        border: '1px solid black',\\n        display: 'flex',\\n        justifyContent: 'center',\\n        alignItems: 'center',\\n        transform: `translate(\\n          ${position.x}px,\\n          ${position.y}px\\n        )`,\\n      }}\\n    >{children}</div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Background.js\",\"children\":\"export default function Background({\\n  position\\n}) {\\n  return (\\n    <div style={{\\n      position: 'absolute',\\n      transform: `translate(\\n        ${position.x}px,\\n        ${position.y}px\\n      )`,\\n      width: 250,\\n      height: 250,\\n      backgroundColor: 'rgba(200, 200, 0, 0.2)',\\n    }} />\\n  );\\n};\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { height: 280px; }\\nselect { margin-bottom: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"问题出在 \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" 中的 mutation 。它直接修改了 \",[\"$r\",\"code\",null,{\"children\":\"shape.position\"}],\"，但是此时 \",[\"$r\",\"code\",null,{\"children\":\"initialPosition\"}],\" 所指向的也是同一个对象。因此方形和背景都发生了移动。（因为它是 mutation，所以直到一个不相关更新——颜色变化——触发了一次重新渲染，变化才反映到屏幕上。）\"]}],[\"$r\",\"p\",null,{\"children\":[\"修复问题的方法就是从 \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" 中移除这个 mutation，然后用展开运算符来复制方形对象。请注意 \",[\"$r\",\"code\",null,{\"children\":\"+=\"}],\" 是 mutation 的一种，所以你需要对它进行重写来使用普通的 \",[\"$r\",\"code\",null,{\"children\":\"+\"}],\" 操作符。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport Background from './Background.js';\\nimport Box from './Box.js';\\n\\nconst initialPosition = {\\n  x: 0,\\n  y: 0\\n};\\n\\nexport default function Canvas() {\\n  const [shape, setShape] = useState({\\n    color: 'orange',\\n    position: initialPosition\\n  });\\n\\n  function handleMove(dx, dy) {\\n    setShape({\\n      ...shape,\\n      position: {\\n        x: shape.position.x + dx,\\n        y: shape.position.y + dy,\\n      }\\n    });\\n  }\\n\\n  function handleColorChange(e) {\\n    setShape({\\n      ...shape,\\n      color: e.target.value\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <select\\n        value={shape.color}\\n        onChange={handleColorChange}\\n      >\\n        <option value=\\\"orange\\\">orange</option>\\n        <option value=\\\"lightpink\\\">lightpink</option>\\n        <option value=\\\"aliceblue\\\">aliceblue</option>\\n      </select>\\n      <Background\\n        position={initialPosition}\\n      />\\n      <Box\\n        color={shape.color}\\n        position={shape.position}\\n        onMove={handleMove}\\n      >\\n        Drag me!\\n      </Box>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Box.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Box({\\n  children,\\n  color,\\n  position,\\n  onMove\\n}) {\\n  const [\\n    lastCoordinates,\\n    setLastCoordinates\\n  ] = useState(null);\\n\\n  function handlePointerDown(e) {\\n    e.target.setPointerCapture(e.pointerId);\\n    setLastCoordinates({\\n      x: e.clientX,\\n      y: e.clientY,\\n    });\\n  }\\n\\n  function handlePointerMove(e) {\\n    if (lastCoordinates) {\\n      setLastCoordinates({\\n        x: e.clientX,\\n        y: e.clientY,\\n      });\\n      const dx = e.clientX - lastCoordinates.x;\\n      const dy = e.clientY - lastCoordinates.y;\\n      onMove(dx, dy);\\n    }\\n  }\\n\\n  function handlePointerUp(e) {\\n    setLastCoordinates(null);\\n  }\\n\\n  return (\\n    <div\\n      onPointerDown={handlePointerDown}\\n      onPointerMove={handlePointerMove}\\n      onPointerUp={handlePointerUp}\\n      style={{\\n        width: 100,\\n        height: 100,\\n        cursor: 'grab',\\n        backgroundColor: color,\\n        position: 'absolute',\\n        border: '1px solid black',\\n        display: 'flex',\\n        justifyContent: 'center',\\n        alignItems: 'center',\\n        transform: `translate(\\n          ${position.x}px,\\n          ${position.y}px\\n        )`,\\n      }}\\n    >{children}</div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Background.js\",\"children\":\"export default function Background({\\n  position\\n}) {\\n  return (\\n    <div style={{\\n      position: 'absolute',\\n      transform: `translate(\\n        ${position.x}px,\\n        ${position.y}px\\n      )`,\\n      width: 250,\\n      height: 250,\\n      backgroundColor: 'rgba(200, 200, 0, 0.2)',\\n    }} />\\n  );\\n};\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { height: 280px; }\\nselect { margin-bottom: 10px; }\\n\"}]}]]}]]}],[\"$r\",\"h4\",null,{\"id\":\"update-an-object-with-immer\",\"children\":\"使用 Immer 更新对象 \"}],[\"$r\",\"p\",null,{\"children\":[\"这里的例子和上面那段有 bug 的代码是相同的。这一次，试着用 Immer 来修复 mutation 的问题。为了方便你的练习，\",[\"$r\",\"code\",null,{\"children\":\"useImmer\"}],\" 已经被引入了，因此你只需要修改 \",[\"$r\",\"code\",null,{\"children\":\"shape\"}],\" 这个 state 变量来使用它。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport { useImmer } from 'use-immer';\\nimport Background from './Background.js';\\nimport Box from './Box.js';\\n\\nconst initialPosition = {\\n  x: 0,\\n  y: 0\\n};\\n\\nexport default function Canvas() {\\n  const [shape, setShape] = useState({\\n    color: 'orange',\\n    position: initialPosition\\n  });\\n\\n  function handleMove(dx, dy) {\\n    shape.position.x += dx;\\n    shape.position.y += dy;\\n  }\\n\\n  function handleColorChange(e) {\\n    setShape({\\n      ...shape,\\n      color: e.target.value\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <select\\n        value={shape.color}\\n        onChange={handleColorChange}\\n      >\\n        <option value=\\\"orange\\\">orange</option>\\n        <option value=\\\"lightpink\\\">lightpink</option>\\n        <option value=\\\"aliceblue\\\">aliceblue</option>\\n      </select>\\n      <Background\\n        position={initialPosition}\\n      />\\n      <Box\\n        color={shape.color}\\n        position={shape.position}\\n        onMove={handleMove}\\n      >\\n        Drag me!\\n      </Box>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Box.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Box({\\n  children,\\n  color,\\n  position,\\n  onMove\\n}) {\\n  const [\\n    lastCoordinates,\\n    setLastCoordinates\\n  ] = useState(null);\\n\\n  function handlePointerDown(e) {\\n    e.target.setPointerCapture(e.pointerId);\\n    setLastCoordinates({\\n      x: e.clientX,\\n      y: e.clientY,\\n    });\\n  }\\n\\n  function handlePointerMove(e) {\\n    if (lastCoordinates) {\\n      setLastCoordinates({\\n        x: e.clientX,\\n        y: e.clientY,\\n      });\\n      const dx = e.clientX - lastCoordinates.x;\\n      const dy = e.clientY - lastCoordinates.y;\\n      onMove(dx, dy);\\n    }\\n  }\\n\\n  function handlePointerUp(e) {\\n    setLastCoordinates(null);\\n  }\\n\\n  return (\\n    <div\\n      onPointerDown={handlePointerDown}\\n      onPointerMove={handlePointerMove}\\n      onPointerUp={handlePointerUp}\\n      style={{\\n        width: 100,\\n        height: 100,\\n        cursor: 'grab',\\n        backgroundColor: color,\\n        position: 'absolute',\\n        border: '1px solid black',\\n        display: 'flex',\\n        justifyContent: 'center',\\n        alignItems: 'center',\\n        transform: `translate(\\n          ${position.x}px,\\n          ${position.y}px\\n        )`,\\n      }}\\n    >{children}</div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Background.js\",\"children\":\"export default function Background({\\n  position\\n}) {\\n  return (\\n    <div style={{\\n      position: 'absolute',\\n      transform: `translate(\\n        ${position.x}px,\\n        ${position.y}px\\n      )`,\\n      width: 250,\\n      height: 250,\\n      backgroundColor: 'rgba(200, 200, 0, 0.2)',\\n    }} />\\n  );\\n};\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { height: 280px; }\\nselect { margin-bottom: 10px; }\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"immer\\\": \\\"1.7.3\\\",\\n    \\\"react\\\": \\\"latest\\\",\\n    \\\"react-dom\\\": \\\"latest\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"下面的代码是使用 Immer 重写的。请注意代码中的事件处理函数仍然是以直接修改对象的方式书写的，但是代码不会产生任何问题了。这是因为从原理上来说，Immer 从来没有直接修改现有的对象。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useImmer } from 'use-immer';\\nimport Background from './Background.js';\\nimport Box from './Box.js';\\n\\nconst initialPosition = {\\n  x: 0,\\n  y: 0\\n};\\n\\nexport default function Canvas() {\\n  const [shape, updateShape] = useImmer({\\n    color: 'orange',\\n    position: initialPosition\\n  });\\n\\n  function handleMove(dx, dy) {\\n    updateShape(draft => {\\n      draft.position.x += dx;\\n      draft.position.y += dy;\\n    });\\n  }\\n\\n  function handleColorChange(e) {\\n    updateShape(draft => {\\n      draft.color = e.target.value;\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <select\\n        value={shape.color}\\n        onChange={handleColorChange}\\n      >\\n        <option value=\\\"orange\\\">orange</option>\\n        <option value=\\\"lightpink\\\">lightpink</option>\\n        <option value=\\\"aliceblue\\\">aliceblue</option>\\n      </select>\\n      <Background\\n        position={initialPosition}\\n      />\\n      <Box\\n        color={shape.color}\\n        position={shape.position}\\n        onMove={handleMove}\\n      >\\n        Drag me!\\n      </Box>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Box.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Box({\\n  children,\\n  color,\\n  position,\\n  onMove\\n}) {\\n  const [\\n    lastCoordinates,\\n    setLastCoordinates\\n  ] = useState(null);\\n\\n  function handlePointerDown(e) {\\n    e.target.setPointerCapture(e.pointerId);\\n    setLastCoordinates({\\n      x: e.clientX,\\n      y: e.clientY,\\n    });\\n  }\\n\\n  function handlePointerMove(e) {\\n    if (lastCoordinates) {\\n      setLastCoordinates({\\n        x: e.clientX,\\n        y: e.clientY,\\n      });\\n      const dx = e.clientX - lastCoordinates.x;\\n      const dy = e.clientY - lastCoordinates.y;\\n      onMove(dx, dy);\\n    }\\n  }\\n\\n  function handlePointerUp(e) {\\n    setLastCoordinates(null);\\n  }\\n\\n  return (\\n    <div\\n      onPointerDown={handlePointerDown}\\n      onPointerMove={handlePointerMove}\\n      onPointerUp={handlePointerUp}\\n      style={{\\n        width: 100,\\n        height: 100,\\n        cursor: 'grab',\\n        backgroundColor: color,\\n        position: 'absolute',\\n        border: '1px solid black',\\n        display: 'flex',\\n        justifyContent: 'center',\\n        alignItems: 'center',\\n        transform: `translate(\\n          ${position.x}px,\\n          ${position.y}px\\n        )`,\\n      }}\\n    >{children}</div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Background.js\",\"children\":\"export default function Background({\\n  position\\n}) {\\n  return (\\n    <div style={{\\n      position: 'absolute',\\n      transform: `translate(\\n        ${position.x}px,\\n        ${position.y}px\\n      )`,\\n      width: 250,\\n      height: 250,\\n      backgroundColor: 'rgba(200, 200, 0, 0.2)',\\n    }} />\\n  );\\n};\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { height: 280px; }\\nselect { margin-bottom: 10px; }\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"immer\\\": \\\"1.7.3\\\",\\n    \\\"react\\\": \\\"latest\\\",\\n    \\\"react-dom\\\": \\\"latest\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}]]}]]}]]}]]","meta":{"title":"更新 state 中的对象","translators":["Neo42","yliaz","Debbl"]}},"__N_SSG":true}