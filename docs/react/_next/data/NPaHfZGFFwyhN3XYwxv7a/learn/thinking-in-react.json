{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#start-with-the-mockup\",\"depth\":2,\"text\":\"从原型开始 \"},{\"url\":\"#step-1-break-the-ui-into-a-component-hierarchy\",\"depth\":2,\"text\":\"步骤一：将 UI 拆解为组件层级结构 \"},{\"url\":\"#step-2-build-a-static-version-in-react\",\"depth\":2,\"text\":\"步骤二：使用 React 构建一个静态版本 \"},{\"url\":\"#step-3-find-the-minimal-but-complete-representation-of-ui-state\",\"depth\":2,\"text\":\"步骤三：找出 UI 精简且完整的 state 表示 \"},{\"url\":\"#step-4-identify-where-your-state-should-live\",\"depth\":2,\"text\":\"步骤四：验证 state 应该被放置在哪里 \"},{\"url\":\"#step-5-add-inverse-data-flow\",\"depth\":2,\"text\":\"步骤五：添加反向数据流 \"},{\"url\":\"#where-to-go-from-here\",\"depth\":2,\"text\":\"下一节，我该做什么？ \"}]","content":"[[\"$r\",\"MaxWidth\",\"28\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"React 可以改变你对可见设计和应用构建的思考。当你使用 React 构建用户界面时，你首先会把它分解成一个个 \",[\"$r\",\"strong\",null,{\"children\":\"组件\"}],\"，然后，你需要把这些组件连接在一起，使数据流经它们。在本教程中，我们将引导你使用 React 构建一个可搜索的产品数据表。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"start-with-the-mockup\",\"children\":\"从原型开始 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"想象一下，你早已从设计者那儿得到了一个 JSON API 和原型。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"JSON API 返回如下的数据:\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"children\":\"[\\n  { category: \\\"Fruits\\\", price: \\\"$1\\\", stocked: true, name: \\\"Apple\\\" },\\n  { category: \\\"Fruits\\\", price: \\\"$1\\\", stocked: true, name: \\\"Dragonfruit\\\" },\\n  { category: \\\"Fruits\\\", price: \\\"$2\\\", stocked: false, name: \\\"Passionfruit\\\" },\\n  { category: \\\"Vegetables\\\", price: \\\"$2\\\", stocked: true, name: \\\"Spinach\\\" },\\n  { category: \\\"Vegetables\\\", price: \\\"$4\\\", stocked: false, name: \\\"Pumpkin\\\" },\\n  { category: \\\"Vegetables\\\", price: \\\"$1\\\", stocked: true, name: \\\"Peas\\\" }\\n]\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"原型看起来像是这样:\"}],\"\\n\",[\"$r\",\"img\",null,{\"src\":\"/images/docs/s_thinking-in-react_ui.png\",\"width\":\"300\",\"style\":{\"margin\":\"0 auto\"}}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"仅需跟随下面的五步，即可使用 React 来实现 UI。\"}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"step-1-break-the-ui-into-a-component-hierarchy\",\"children\":\"步骤一：将 UI 拆解为组件层级结构 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"一开始，在绘制原型中的每个组件和子组件周围绘制盒子并命名它们。如果你与设计师一起工作，他们可能早已在其设计工具中对这些组件进行了命名。检查一下它们!\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"取决于你的使用背景，可以考虑通过不同的方式将设计分割为组件:\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"程序设计\"}],\"——使用同样的技术决定你是否应该创建一个新的函数或者对象。这一技术即 \",[\"$r\",\"a\",null,{\"href\":\"https://en.wikipedia.org/wiki/Single_responsibility_principle\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"单一功能原理\"}],\"，也就是说，一个组件理想情况下应仅做一件事情。但随着功能的持续增长，它应该被分解为更小的子组件。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"CSS\"}],\"——思考你将把类选择器用于何处。(然而，组件并没有那么细的粒度。)\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"设计\"}],\"——思考你将如何组织布局的层级。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果你的 JSON 结构非常棒，经常会发现其映射到 UI 中的组件结构是一件自然而然的事情。那是因为 UI 和原型常拥有相同的信息结构—即，相同的形状。将你的 UI 分割到组件，每个组件匹配到原型中的每个部分。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"以下展示了五个组件:\"}],\"\\n\"]}],[\"$r\",\"FullWidth\",null,{\"children\":[\"$r\",\"CodeDiagram\",null,{\"flip\":true,\"children\":[[\"$r\",\"img\",null,{\"src\":\"/images/docs/s_thinking-in-react_ui_outline.png\",\"width\":\"500\",\"style\":{\"margin\":\"0 auto\"}}],[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\"（灰色）包含完整的应用。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\"（蓝色）获取用户输入。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"ProductTable\"}],\"（淡紫色）根据用户输入，展示和过滤清单。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"ProductCategoryRow\"}],\"（绿色）展示每个类别的表头。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"ProductRow\"}],\"（黄色）展示每个产品的行。\"]}],\"\\n\"]}]]}]}],[\"$r\",\"MaxWidth\",\"44\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"看向 \",[\"$r\",\"code\",null,{\"children\":\"ProductTable\"}],\"（淡紫色），可以看到表头（包含 “Name” 和 “Price” 标签）并不是独立的组件。这是个人喜好的问题，你可以采取任何一种方式继续。在这个例子中，它是作为 \",[\"$r\",\"code\",null,{\"children\":\"ProductTable\"}],\" 的一部分，因为它展现在 \",[\"$r\",\"code\",null,{\"children\":\"ProductTable\"}],\" 列表之中。然而，如果这个表头变得复杂（举个例子，如果添加排序），创建独立的 \",[\"$r\",\"code\",null,{\"children\":\"ProductTableHeader\"}],\" 组件就变得有意义了。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在你已经在原型中辨别了组件，并将它们转化为了层级结构。在原型中，组件可以展示在其它组件之中，在层级结构中如同其孩子一般:\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"ProductTable\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"ProductCategoryRow\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"ProductRow\"}]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"step-2-build-a-static-version-in-react\",\"children\":\"步骤二：使用 React 构建一个静态版本 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在你已经拥有了你自己的组件层级结构，是时候实现你的应用程序了。最直接的办法是根据你的数据模型，构建一个不带任何交互的 UI 渲染代码版本…经常是先构建一个静态版本比较简单，然后再一个个添加交互。构建一个静态版本需要写大量的代码，并不需要什么思考; 但添加交互需要大量的思考，却不需要大量的代码。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"构建应用程序的静态版本来渲染你的数据模型，将构建 \",[\"$r\",\"a\",null,{\"href\":\"/learn/your-first-component\",\"children\":\"组件\"}],\" 并复用其它的组件，然后使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":\"props\"}],\" 进行传递数据。Props 是从父组件向子组件传递数据的一种方式。如果你对 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"state\"}],\" 章节很熟悉，不要在静态版本中使用 state 进行构建。state 只是为交互提供的保留功能，即数据会随着时间变化。因为这是一个静态应用程序，所以并不需要。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你既可以通过从层次结构更高层组件（如 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\"）开始“自上而下”构建，也可以通过从更低层级组件（如 \",[\"$r\",\"code\",null,{\"children\":\"ProductRow\"}],\"）“自下而上”进行构建。在简单的例子中，自上而下构建通常更简单；而在大型项目中，自下而上构建更简单。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"meta\":\"src/App.js\",\"children\":\"function ProductCategoryRow({ category }) {\\n  return (\\n    <tr>\\n      <th colSpan=\\\"2\\\">\\n        {category}\\n      </th>\\n    </tr>\\n  );\\n}\\n\\nfunction ProductRow({ product }) {\\n  const name = product.stocked ? product.name :\\n    <span style={{ color: 'red' }}>\\n      {product.name}\\n    </span>;\\n\\n  return (\\n    <tr>\\n      <td>{name}</td>\\n      <td>{product.price}</td>\\n    </tr>\\n  );\\n}\\n\\nfunction ProductTable({ products }) {\\n  const rows = [];\\n  let lastCategory = null;\\n\\n  products.forEach((product) => {\\n    if (product.category !== lastCategory) {\\n      rows.push(\\n        <ProductCategoryRow\\n          category={product.category}\\n          key={product.category} />\\n      );\\n    }\\n    rows.push(\\n      <ProductRow\\n        product={product}\\n        key={product.name} />\\n    );\\n    lastCategory = product.category;\\n  });\\n\\n  return (\\n    <table>\\n      <thead>\\n        <tr>\\n          <th>Name</th>\\n          <th>Price</th>\\n        </tr>\\n      </thead>\\n      <tbody>{rows}</tbody>\\n    </table>\\n  );\\n}\\n\\nfunction SearchBar() {\\n  return (\\n    <form>\\n      <input type=\\\"text\\\" placeholder=\\\"Search...\\\" />\\n      <label>\\n        <input type=\\\"checkbox\\\" />\\n        {' '}\\n        Only show products in stock\\n      </label>\\n    </form>\\n  );\\n}\\n\\nfunction FilterableProductTable({ products }) {\\n  return (\\n    <div>\\n      <SearchBar />\\n      <ProductTable products={products} />\\n    </div>\\n  );\\n}\\n\\nconst PRODUCTS = [\\n  {category: \\\"Fruits\\\", price: \\\"$1\\\", stocked: true, name: \\\"Apple\\\"},\\n  {category: \\\"Fruits\\\", price: \\\"$1\\\", stocked: true, name: \\\"Dragonfruit\\\"},\\n  {category: \\\"Fruits\\\", price: \\\"$2\\\", stocked: false, name: \\\"Passionfruit\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$2\\\", stocked: true, name: \\\"Spinach\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$4\\\", stocked: false, name: \\\"Pumpkin\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$1\\\", stocked: true, name: \\\"Peas\\\"}\\n];\\n\\nexport default function App() {\\n  return <FilterableProductTable products={PRODUCTS} />;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body {\\n  padding: 5px\\n}\\nlabel {\\n  display: block;\\n  margin-top: 5px;\\n  margin-bottom: 5px;\\n}\\nth {\\n  padding-top: 10px;\\n}\\ntd {\\n  padding: 2px;\\n  padding-right: 40px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"102\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你无法理解这段代码，请先阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/\",\"children\":\"快速入门\"}],\" 章节！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在构建你的组件之后，即拥有一个渲染数据模型的可复用组件库。因为这是一个静态应用程序，组件仅返回 JSX。最顶层组件（\",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\"）将接收你的数据模型作为其 prop。这被称之为 \",[\"$r\",\"strong\",null,{\"children\":\"单向数据流\"}],\"，因为数据从树的顶层组件传递到下面的组件。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"在这部分中，你不需要使用任何 state，这是下一步的内容！\"}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"step-3-find-the-minimal-but-complete-representation-of-ui-state\",\"children\":\"步骤三：找出 UI 精简且完整的 state 表示 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了使 UI 可交互，你需要用户更改潜在的数据结构。你将可以使用 \",[\"$r\",\"strong\",null,{\"children\":\"state\"}],\" 进行实现。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"考虑将 state 作为应用程序需要记住改变数据的最小集合。组织 state 最重要的一条原则是保持它 \",[\"$r\",\"a\",null,{\"href\":\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DRY（不要自我重复）\"}],\"。计算出你应用程序需要的绝对精简 state 表示，按需计算其它一切。举个例子，如果你正在构建一个购物列表，你可将他们在 state 中存储为数组。如果你同时想展示列表中物品数量，不需要将其另存为一个新的 state。取而代之，可以通过读取你数组的长度来实现。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在考虑示例应用程序中的每一条数据:\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"产品原始列表\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"搜索用户键入的文本\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"复选框的值\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"过滤后的产品列表\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"其中哪些是 state 呢？标记出那些不是的:\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"随着时间推移 \",[\"$r\",\"strong\",null,{\"children\":\"保持不变\"}],\"？如此，便不是 state。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"通过 props \",[\"$r\",\"strong\",null,{\"children\":\"从父组件传递\"}],\"？如此，便不是 state。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"是否可以基于已存在于组件中的 state 或者 props \",[\"$r\",\"strong\",null,{\"children\":\"进行计算\"}],\"？如此，它肯定不是state！\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"剩下的可能是 state。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"让我们再次一条条验证它们:\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"原始列表中的产品 \",[\"$r\",\"strong\",null,{\"children\":\"被作为 props 传递，所以不是 state\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"搜索文本似乎应该是 state，因为它会随着时间的推移而变化，并且无法从任何东西中计算出来。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"复选框的值似乎是 state，因为它会随着时间的推移而变化，并且无法从任何东西中计算出来。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"过滤后列表中的产品 \",[\"$r\",\"strong\",null,{\"children\":\"不是 state，因为可以通过被原始列表中的产品，根据搜索框文本和复选框的值进行计算\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这就意味着只有搜索文本和复选框的值是 state！非常好！\"}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"props-vs-state\",\"children\":\"props vs state \"}],[\"$r\",\"p\",null,{\"children\":\"在 React 中有两种“模型”数据：props 和 state。下面是它们的不同之处:\"}],[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":[[\"$r\",\"strong\",null,{\"children\":\"props\"}],\" 像是你传递的参数\"]}],\" 至函数。它们使父组件可以传递数据给子组件，定制它们的展示。举个例子，\",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 可以传递 \",[\"$r\",\"code\",null,{\"children\":\"color\"}],\" prop 至 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":[[\"$r\",\"strong\",null,{\"children\":\"state\"}],\" 像是组件的内存\"]}],\"。它使组件可以对一些信息保持追踪，并根据交互来改变。举个例子，\",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 可以保持对 \",[\"$r\",\"code\",null,{\"children\":\"isHovered\"}],\" state 的追踪。\"]}],\"\\n\"]}],[\"$r\",\"p\",null,{\"children\":[\"props 和 state 是不同的，但它们可以共同工作。父组件将经常在 state 中放置一些信息（以便它可以改变），并且作为子组件的属性 \",[\"$r\",\"strong\",null,{\"children\":\"向下\"}],\" 传递至它的子组件。如果第一次了解这其中的差别感到迷惑，也没关系。通过大量练习即可牢牢记住！\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"step-4-identify-where-your-state-should-live\",\"children\":\"步骤四：验证 state 应该被放置在哪里 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在验证你应用程序中的最小 state 数据之后，你需要验证哪个组件是通过改变 state 实现可响应的，或者 \",[\"$r\",\"strong\",null,{\"children\":\"拥有\"}],\" 这个 state。记住：React 使用单向数据流，通过组件层级结构从父组件传递数据至子组件。要搞清楚哪个组件拥有哪个 state。如果你是第一次阅读此章节，可能会很有挑战，但可以通过下面的步骤搞定它!\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"为你应用程序中的每一个 state:\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"验证每一个基于特定 state 渲染的组件。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"寻找它们最近并且共同的父组件——在层级结构中，一个凌驾于它们所有组件之上的组件。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"决定 state 应该被放置于哪里:\",\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"通常情况下，你可以直接放置 state 于它们共同的父组件。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"你也可以将 state 放置于它们父组件上层的组件。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果你找不到一个有意义拥有这个 state 的地方，单独创建一个新的组件去管理这个 state，并将它添加到它们父组件上层的某个地方。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在之前的步骤中，你已在应用程序中创建了两个 state：输入框文本和复选框的值。在这个例子中，它们总在一起展示，将其视为一个 state 非常简单。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在为这个 state 贯彻我们的策略:\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"验证使用 state 的组件\"}],\"：\",\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"ProductTable\"}],\" 需要基于 state (搜索文本和复选框值) 过滤产品列表。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\" 需要展示 state (搜索文本和复选框值)。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"寻找它们的父组件\"}],\"：它们的第一个共同父组件为 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"决定 state 放置的地方\"}],\"：我们将放置过滤文本和勾选 state 的值于 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"所以 state 将被放置在 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState()\"}],\" Hook\"]}],\" 为组件添加 state。Hook 可以“钩住”组件的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/render-and-commit\",\"children\":\"渲染周期\"}],\"。在 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\" 的顶部添加两个 state 变量，用于指定你应用程序的初始 state：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function FilterableProductTable({ products }) {\\n  const [filterText, setFilterText] = useState('');\\n  const [inStockOnly, setInStockOnly] = useState(false);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然后，\",[\"$r\",\"code\",null,{\"children\":\"filterText\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"inStockOnly\"}],\" 作为 props 传递至 \",[\"$r\",\"code\",null,{\"children\":\"ProductTable\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<div>\\n  <SearchBar\\n    filterText={filterText}\\n    inStockOnly={inStockOnly} />\\n  <ProductTable\\n    products={products}\\n    filterText={filterText}\\n    inStockOnly={inStockOnly} />\\n</div>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以查看你应用程序的表现。在下面的沙盒代码中，通过修改 \",[\"$r\",\"code\",null,{\"children\":\"useState('')\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"useState('fruit')\"}],\" 以编辑 \",[\"$r\",\"code\",null,{\"children\":\"filterText\"}],\" 的初始值，你将会发现搜索输入框和表格发生更新：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\n\\nfunction FilterableProductTable({ products }) {\\n  const [filterText, setFilterText] = useState('');\\n  const [inStockOnly, setInStockOnly] = useState(false);\\n\\n  return (\\n    <div>\\n      <SearchBar\\n        filterText={filterText}\\n        inStockOnly={inStockOnly} />\\n      <ProductTable\\n        products={products}\\n        filterText={filterText}\\n        inStockOnly={inStockOnly} />\\n    </div>\\n  );\\n}\\n\\nfunction ProductCategoryRow({ category }) {\\n  return (\\n    <tr>\\n      <th colSpan=\\\"2\\\">\\n        {category}\\n      </th>\\n    </tr>\\n  );\\n}\\n\\nfunction ProductRow({ product }) {\\n  const name = product.stocked ? product.name :\\n    <span style={{ color: 'red' }}>\\n      {product.name}\\n    </span>;\\n\\n  return (\\n    <tr>\\n      <td>{name}</td>\\n      <td>{product.price}</td>\\n    </tr>\\n  );\\n}\\n\\nfunction ProductTable({ products, filterText, inStockOnly }) {\\n  const rows = [];\\n  let lastCategory = null;\\n\\n  products.forEach((product) => {\\n    if (\\n      product.name.toLowerCase().indexOf(\\n        filterText.toLowerCase()\\n      ) === -1\\n    ) {\\n      return;\\n    }\\n    if (inStockOnly && !product.stocked) {\\n      return;\\n    }\\n    if (product.category !== lastCategory) {\\n      rows.push(\\n        <ProductCategoryRow\\n          category={product.category}\\n          key={product.category} />\\n      );\\n    }\\n    rows.push(\\n      <ProductRow\\n        product={product}\\n        key={product.name} />\\n    );\\n    lastCategory = product.category;\\n  });\\n\\n  return (\\n    <table>\\n      <thead>\\n        <tr>\\n          <th>Name</th>\\n          <th>Price</th>\\n        </tr>\\n      </thead>\\n      <tbody>{rows}</tbody>\\n    </table>\\n  );\\n}\\n\\nfunction SearchBar({ filterText, inStockOnly }) {\\n  return (\\n    <form>\\n      <input\\n        type=\\\"text\\\"\\n        value={filterText}\\n        placeholder=\\\"Search...\\\"/>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={inStockOnly} />\\n        {' '}\\n        Only show products in stock\\n      </label>\\n    </form>\\n  );\\n}\\n\\nconst PRODUCTS = [\\n  {category: \\\"Fruits\\\", price: \\\"$1\\\", stocked: true, name: \\\"Apple\\\"},\\n  {category: \\\"Fruits\\\", price: \\\"$1\\\", stocked: true, name: \\\"Dragonfruit\\\"},\\n  {category: \\\"Fruits\\\", price: \\\"$2\\\", stocked: false, name: \\\"Passionfruit\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$2\\\", stocked: true, name: \\\"Spinach\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$4\\\", stocked: false, name: \\\"Pumpkin\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$1\\\", stocked: true, name: \\\"Peas\\\"}\\n];\\n\\nexport default function App() {\\n  return <FilterableProductTable products={PRODUCTS} />;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body {\\n  padding: 5px\\n}\\nlabel {\\n  display: block;\\n  margin-top: 5px;\\n  margin-bottom: 5px;\\n}\\nth {\\n  padding-top: 5px;\\n}\\ntd {\\n  padding: 2px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"130\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"注意，编辑表单还不能正常工作，在上面的 sandbox 中，有一个控制台的报错，解释了原因：\"}],\"\\n\",[\"$r\",\"ConsoleBlock\",null,{\"level\":\"error\",\"children\":[\"$r\",\"p\",null,{\"children\":\"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field.\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在上面的沙盒中，\",[\"$r\",\"code\",null,{\"children\":\"ProductTable\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\" 读取 \",[\"$r\",\"code\",null,{\"children\":\"filterText\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"inStockOnly\"}],\" props 以渲染表格、输入，以及复选框。举个例子，这里展示了 \",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\" 如何填充输入的值：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,6}\",\"children\":\"function SearchBar({ filterText, inStockOnly }) {\\n  return (\\n    <form>\\n      <input\\n        type=\\\"text\\\"\\n        value={filterText}\\n        placeholder=\\\"Search...\\\"/>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"然而，你还没有添加任何代码来响应用户的动作，如输入文案，这将是你应做的最后一步。\"}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"step-5-add-inverse-data-flow\",\"children\":\"步骤五：添加反向数据流 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"目前你的应用程序可以带着 props 和 state 随着层级结构进行正确渲染。但是根据用户的输入改变 state，需要通过其它的方式支持数据流：深层结构的表单组件需要在 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\" 中更新 state。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 使数据流显式展示，是与双向数据绑定相比，需要更多的输入。如果你尝试在上述的例子中输入或者勾选复选框，发现 React 忽视了你的输入。这点是有意为之的。通过 \",[\"$r\",\"code\",null,{\"children\":\"<input value={filterText} />\"}],\"，已经设置了 \",[\"$r\",\"code\",null,{\"children\":\"input\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\" 属性，使之恒等于从 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\" 传递的 \",[\"$r\",\"code\",null,{\"children\":\"filterText\"}],\" state。只要 \",[\"$r\",\"code\",null,{\"children\":\"filterText\"}],\" state 不设置，（输入框的）输入就不会改变。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当用户更改表单输入时，state 将更新以反映这些更改。state 由 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\" 所拥有，所以只有它可以调用 \",[\"$r\",\"code\",null,{\"children\":\"setFilterText\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"setInStockOnly\"}],\"。使 \",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\" 更新 \",[\"$r\",\"code\",null,{\"children\":\"FilterableProductTable\"}],\" 的 state，需要将这些函数传递到 \",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,3,10,11}\",\"children\":\"function FilterableProductTable({ products }) {\\n  const [filterText, setFilterText] = useState('');\\n  const [inStockOnly, setInStockOnly] = useState(false);\\n\\n  return (\\n    <div>\\n      <SearchBar\\n        filterText={filterText}\\n        inStockOnly={inStockOnly}\\n        onFilterTextChange={setFilterText}\\n        onInStockOnlyChange={setInStockOnly} />\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 \",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\" 中，添加一个 \",[\"$r\",\"code\",null,{\"children\":\"onChange\"}],\" 事件处理器，使用其设置父组件的 state：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,5,13,19}\",\"children\":\"function SearchBar({\\n  filterText,\\n  inStockOnly,\\n  onFilterTextChange,\\n  onInStockOnlyChange\\n}) {\\n  return (\\n    <form>\\n      <input\\n        type=\\\"text\\\"\\n        value={filterText}\\n        placeholder=\\\"搜索\\\"\\n        onChange={(e) => onFilterTextChange(e.target.value)}\\n      />\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={inStockOnly}\\n          onChange={(e) => onInStockOnlyChange(e.target.checked)}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在应用程序可以完整工作了！\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\n\\nfunction FilterableProductTable({ products }) {\\n  const [filterText, setFilterText] = useState('');\\n  const [inStockOnly, setInStockOnly] = useState(false);\\n\\n  return (\\n    <div>\\n      <SearchBar\\n        filterText={filterText}\\n        inStockOnly={inStockOnly}\\n        onFilterTextChange={setFilterText}\\n        onInStockOnlyChange={setInStockOnly} />\\n      <ProductTable\\n        products={products}\\n        filterText={filterText}\\n        inStockOnly={inStockOnly} />\\n    </div>\\n  );\\n}\\n\\nfunction ProductCategoryRow({ category }) {\\n  return (\\n    <tr>\\n      <th colSpan=\\\"2\\\">\\n        {category}\\n      </th>\\n    </tr>\\n  );\\n}\\n\\nfunction ProductRow({ product }) {\\n  const name = product.stocked ? product.name :\\n    <span style={{ color: 'red' }}>\\n      {product.name}\\n    </span>;\\n\\n  return (\\n    <tr>\\n      <td>{name}</td>\\n      <td>{product.price}</td>\\n    </tr>\\n  );\\n}\\n\\nfunction ProductTable({ products, filterText, inStockOnly }) {\\n  const rows = [];\\n  let lastCategory = null;\\n\\n  products.forEach((product) => {\\n    if (\\n      product.name.toLowerCase().indexOf(\\n        filterText.toLowerCase()\\n      ) === -1\\n    ) {\\n      return;\\n    }\\n    if (inStockOnly && !product.stocked) {\\n      return;\\n    }\\n    if (product.category !== lastCategory) {\\n      rows.push(\\n        <ProductCategoryRow\\n          category={product.category}\\n          key={product.category} />\\n      );\\n    }\\n    rows.push(\\n      <ProductRow\\n        product={product}\\n        key={product.name} />\\n    );\\n    lastCategory = product.category;\\n  });\\n\\n  return (\\n    <table>\\n      <thead>\\n        <tr>\\n          <th>Name</th>\\n          <th>Price</th>\\n        </tr>\\n      </thead>\\n      <tbody>{rows}</tbody>\\n    </table>\\n  );\\n}\\n\\nfunction SearchBar({\\n  filterText,\\n  inStockOnly,\\n  onFilterTextChange,\\n  onInStockOnlyChange\\n}) {\\n  return (\\n    <form>\\n      <input\\n        type=\\\"text\\\"\\n        value={filterText} placeholder=\\\"Search...\\\"\\n        onChange={(e) => onFilterTextChange(e.target.value)} />\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={inStockOnly}\\n          onChange={(e) => onInStockOnlyChange(e.target.checked)} />\\n        {' '}\\n        Only show products in stock\\n      </label>\\n    </form>\\n  );\\n}\\n\\nconst PRODUCTS = [\\n  {category: \\\"Fruits\\\", price: \\\"$1\\\", stocked: true, name: \\\"Apple\\\"},\\n  {category: \\\"Fruits\\\", price: \\\"$1\\\", stocked: true, name: \\\"Dragonfruit\\\"},\\n  {category: \\\"Fruits\\\", price: \\\"$2\\\", stocked: false, name: \\\"Passionfruit\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$2\\\", stocked: true, name: \\\"Spinach\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$4\\\", stocked: false, name: \\\"Pumpkin\\\"},\\n  {category: \\\"Vegetables\\\", price: \\\"$1\\\", stocked: true, name: \\\"Peas\\\"}\\n];\\n\\nexport default function App() {\\n  return <FilterableProductTable products={PRODUCTS} />;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body {\\n  padding: 5px\\n}\\nlabel {\\n  display: block;\\n  margin-top: 5px;\\n  margin-bottom: 5px;\\n}\\nth {\\n  padding: 4px;\\n}\\ntd {\\n  padding: 2px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以在 \",[\"$r\",\"a\",null,{\"href\":\"/learn/adding-interactivity\",\"children\":\"添加交互\"}],\" 这一章节，学习到所有处理事件和更新 state 的内容。\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"where-to-go-from-here\",\"children\":\"下一节，我该做什么？ \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"本章只是一个概述，旨在告诉你如何使用 React 如何进行思考构建组件和应用程序。你可以即刻 \",[\"$r\",\"a\",null,{\"href\":\"/learn/installation\",\"children\":\"开始一个 React 项目\"}],\"，或者在本教程中 \",[\"$r\",\"a\",null,{\"href\":\"/learn/describing-the-ui\",\"children\":\"深入了解所有语法\"}],\"。\"]}]]}]]","meta":{"title":"React 哲学","translators":["HerbertHe","KnowsCount","mophia","QC-L"]}},"__N_SSG":true}