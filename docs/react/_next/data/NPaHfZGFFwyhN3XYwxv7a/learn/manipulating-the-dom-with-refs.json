{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#getting-a-ref-to-the-node\",\"depth\":2,\"text\":\"获取指向节点的 ref \"},{\"url\":\"#example-focusing-a-text-input\",\"depth\":3,\"text\":\"示例: 使文本输入框获得焦点 \"},{\"url\":\"#example-scrolling-to-an-element\",\"depth\":3,\"text\":\"示例: 滚动至一个元素 \"},{\"url\":\"#accessing-another-components-dom-nodes\",\"depth\":2,\"text\":\"访问另一个组件的 DOM 节点 \"},{\"url\":\"#when-react-attaches-the-refs\",\"depth\":2,\"text\":\"React 何时添加 refs \"},{\"url\":\"#best-practices-for-dom-manipulation-with-refs\",\"depth\":2,\"text\":\"使用 refs 操作 DOM 的最佳实践 \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"26\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"由于 React 会自动处理更新 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DOM\"}],\" 以匹配你的渲染输出，因此你在组件中通常不需要操作 DOM。但是，有时你可能需要访问由 React 管理的 DOM 元素 —— 例如，让一个节点获得焦点、滚动到它或测量它的尺寸和位置。在 React 中没有内置的方法来做这些事情，所以你需要一个指向 DOM 节点的 \",[\"$r\",\"strong\",null,{\"children\":\"ref\"}],\" 来实现。\"]}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如何使用 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性访问由 React 管理的 DOM 节点\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" JSX 属性如何与 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" Hook 相关联\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何访问另一个组件的 DOM 节点\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"在哪些情况下修改 React 管理的 DOM 是安全的\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"getting-a-ref-to-the-node\",\"children\":\"获取指向节点的 ref \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"要访问由 React 管理的 DOM 节点，首先，引入 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" Hook：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"然后，在你的组件中使用它声明一个 ref：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const myRef = useRef(null);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"最后，将 ref 作为 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性值传递给想要获取的 DOM 节点的 JSX 标签：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<div ref={myRef}>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" Hook 返回一个对象，该对象有一个名为 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 的属性。最初，\",[\"$r\",\"code\",null,{\"children\":\"myRef.current\"}],\" 是 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。当 React 为这个 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 创建一个 DOM 节点时，React 会把对该节点的引用放入 \",[\"$r\",\"code\",null,{\"children\":\"myRef.current\"}],\"。然后，你可以从 \",[\"$r\",\"a\",null,{\"href\":\"/learn/responding-to-events\",\"children\":\"事件处理器\"}],\" 访问此 DOM 节点，并使用在其上定义的内置\",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/API/Element\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"浏览器 API\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"// 你可以使用任意浏览器 API，例如：\\nmyRef.current.scrollIntoView();\\n\"}]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"example-focusing-a-text-input\",\"children\":\"示例: 使文本输入框获得焦点 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在本例中，单击按钮将使输入框获得焦点：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Form() {\\n  const inputRef = useRef(null);\\n\\n  function handleClick() {\\n    inputRef.current.focus();\\n  }\\n\\n  return (\\n    <>\\n      <input ref={inputRef} />\\n      <button onClick={handleClick}>\\n        聚焦输入框\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"38\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"要实现这一点：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" Hook 声明 \",[\"$r\",\"code\",null,{\"children\":\"inputRef\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"像 \",[\"$r\",\"code\",null,{\"children\":\"<input ref={inputRef}>\"}],\" 这样传递它。这告诉 React \",[\"$r\",\"strong\",null,{\"children\":[\"将这个 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" 的 DOM 节点放入 \",[\"$r\",\"code\",null,{\"children\":\"inputRef.current\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在 \",[\"$r\",\"code\",null,{\"children\":\"handleClick\"}],\" 函数中，从 \",[\"$r\",\"code\",null,{\"children\":\"inputRef.current\"}],\" 读取 input DOM 节点并使用 \",[\"$r\",\"code\",null,{\"children\":\"inputRef.current.focus()\"}],\" 调用它的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/focus\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"focus()\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"用 \",[\"$r\",\"code\",null,{\"children\":\"onClick\"}],\" 将 \",[\"$r\",\"code\",null,{\"children\":\"handleClick\"}],\" 事件处理器传递给 \",[\"$r\",\"code\",null,{\"children\":\"<button>\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"虽然 DOM 操作是 ref 最常见的用例，但 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" Hook 可用于存储 React 之外的其他内容，例如计时器 ID 。与 state 类似，ref 能在渲染之间保留。你甚至可以将 ref 视为设置它们时不会触发重新渲染的 state 变量！你可以在\",[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs\",\"children\":\"使用 Ref 引用值\"}],\"中了解有关 ref 的更多信息。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"example-scrolling-to-an-element\",\"children\":\"示例: 滚动至一个元素 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"一个组件中可以有多个 ref。在这个例子中，有一个由三张图片和三个按钮组成的轮播，点击按钮会调用浏览器的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"scrollIntoView()\"}]}],\" 方法，在相应的 DOM 节点上将它们居中显示在视口中：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function CatFriends() {\\n  const firstCatRef = useRef(null);\\n  const secondCatRef = useRef(null);\\n  const thirdCatRef = useRef(null);\\n\\n  function handleScrollToFirstCat() {\\n    firstCatRef.current.scrollIntoView({\\n      behavior: 'smooth',\\n      block: 'nearest',\\n      inline: 'center'\\n    });\\n  }\\n\\n  function handleScrollToSecondCat() {\\n    secondCatRef.current.scrollIntoView({\\n      behavior: 'smooth',\\n      block: 'nearest',\\n      inline: 'center'\\n    });\\n  }\\n\\n  function handleScrollToThirdCat() {\\n    thirdCatRef.current.scrollIntoView({\\n      behavior: 'smooth',\\n      block: 'nearest',\\n      inline: 'center'\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <nav>\\n        <button onClick={handleScrollToFirstCat}>\\n          Tom\\n        </button>\\n        <button onClick={handleScrollToSecondCat}>\\n          Maru\\n        </button>\\n        <button onClick={handleScrollToThirdCat}>\\n          Jellylorum\\n        </button>\\n      </nav>\\n      <div>\\n        <ul>\\n          <li>\\n            <img\\n              src=\\\"https://placekitten.com/g/200/200\\\"\\n              alt=\\\"Tom\\\"\\n              ref={firstCatRef}\\n            />\\n          </li>\\n          <li>\\n            <img\\n              src=\\\"https://placekitten.com/g/300/200\\\"\\n              alt=\\\"Maru\\\"\\n              ref={secondCatRef}\\n            />\\n          </li>\\n          <li>\\n            <img\\n              src=\\\"https://placekitten.com/g/250/200\\\"\\n              alt=\\\"Jellylorum\\\"\\n              ref={thirdCatRef}\\n            />\\n          </li>\\n        </ul>\\n      </div>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"div {\\n  width: 100%;\\n  overflow: hidden;\\n}\\n\\nnav {\\n  text-align: center;\\n}\\n\\nbutton {\\n  margin: .25rem;\\n}\\n\\nul,\\nli {\\n  list-style: none;\\n  white-space: nowrap;\\n}\\n\\nli {\\n  display: inline;\\n  padding: 0.5rem;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"48\",{\"children\":[\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"how-to-manage-a-list-of-refs-using-a-ref-callback\",\"children\":\"如何使用 ref 回调管理 ref 列表 \"}],[\"$r\",\"p\",null,{\"children\":[\"在上面的例子中，ref 的数量是预先确定的。但有时候，你可能需要为列表中的每一项都绑定 ref ，而你又不知道会有多少项。像下面这样做\",[\"$r\",\"strong\",null,{\"children\":\"是行不通的\"}],\"：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<ul>\\n  {items.map((item) => {\\n    // 行不通！\\n    const ref = useRef(null);\\n    return <li ref={ref} />;\\n  })}\\n</ul>\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"这是因为 \",[\"$r\",\"strong\",null,{\"children\":\"Hook 只能在组件的顶层被调用\"}],\"。不能在循环语句、条件语句或 \",[\"$r\",\"code\",null,{\"children\":\"map()\"}],\" 函数中调用 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 。\"]}],[\"$r\",\"p\",null,{\"children\":[\"一种可能的解决方案是用一个 ref 引用其父元素，然后用 DOM 操作方法如 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"querySelectorAll\"}]}],\" 来寻找它的子节点。然而，这种方法很脆弱，如果 DOM 结构发生变化，可能会失效或报错。\"]}],[\"$r\",\"p\",null,{\"children\":[\"另一种解决方案是\",[\"$r\",\"strong\",null,{\"children\":[\"将函数传递给 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性\"]}],\"。这称为 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/components/common#ref-callback\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 回调\"]}],\"。当需要设置 ref 时，React 将传入 DOM 节点来调用你的 ref 回调，并在需要清除它时传入 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 。这使你可以维护自己的数组或 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Map\"}],\"，并通过其索引或某种类型的 ID 访问任何 ref。\"]}],[\"$r\",\"p\",null,{\"children\":\"此示例展示了如何使用此方法滚动到长列表中的任意节点：\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function CatFriends() {\\n  const itemsRef = useRef(null);\\n\\n  function scrollToId(itemId) {\\n    const map = getMap();\\n    const node = map.get(itemId);\\n    node.scrollIntoView({\\n      behavior: 'smooth',\\n      block: 'nearest',\\n      inline: 'center'\\n    });\\n  }\\n\\n  function getMap() {\\n    if (!itemsRef.current) {\\n      // 首次运行时初始化 Map。\\n      itemsRef.current = new Map();\\n    }\\n    return itemsRef.current;\\n  }\\n\\n  return (\\n    <>\\n      <nav>\\n        <button onClick={() => scrollToId(0)}>\\n          Tom\\n        </button>\\n        <button onClick={() => scrollToId(5)}>\\n          Maru\\n        </button>\\n        <button onClick={() => scrollToId(9)}>\\n          Jellylorum\\n        </button>\\n      </nav>\\n      <div>\\n        <ul>\\n          {catList.map(cat => (\\n            <li\\n              key={cat.id}\\n              ref={(node) => {\\n                const map = getMap();\\n                if (node) {\\n                  map.set(cat.id, node);\\n                } else {\\n                  map.delete(cat.id);\\n                }\\n              }}\\n            >\\n              <img\\n                src={cat.imageUrl}\\n                alt={'Cat #' + cat.id}\\n              />\\n            </li>\\n          ))}\\n        </ul>\\n      </div>\\n    </>\\n  );\\n}\\n\\nconst catList = [];\\nfor (let i = 0; i < 10; i++) {\\n  catList.push({\\n    id: i,\\n    imageUrl: 'https://placekitten.com/250/200?image=' + i\\n  });\\n}\\n\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"div {\\n  width: 100%;\\n  overflow: hidden;\\n}\\n\\nnav {\\n  text-align: center;\\n}\\n\\nbutton {\\n  margin: .25rem;\\n}\\n\\nul,\\nli {\\n  list-style: none;\\n  white-space: nowrap;\\n}\\n\\nli {\\n  display: inline;\\n  padding: 0.5rem;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"itemsRef\"}],\" 保存的不是单个 DOM 节点，而是保存了包含列表项 ID 和 DOM 节点的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Map\"}],\"。(\",[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs\",\"children\":\"Ref 可以保存任何值！\"}],\") 每个列表项上的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/components/common#ref-callback\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 回调\"]}],\"负责更新 Map：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<li\\n  key={cat.id}\\n  ref={node => {\\n    const map = getMap();\\n    if (node) {\\n      // 添加到 Map\\n      map.set(cat.id, node);\\n    } else {\\n      // 从 Map 删除\\n      map.delete(cat.id);\\n    }\\n  }}\\n>\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"这使你可以之后从 Map 读取单个 DOM 节点。\"}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"accessing-another-components-dom-nodes\",\"children\":\"访问另一个组件的 DOM 节点 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你将 ref 放在像 \",[\"$r\",\"code\",null,{\"children\":\"<input />\"}],\" 这样输出浏览器元素的内置组件上时，React 会将该 ref 的 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性设置为相应的 DOM 节点（例如浏览器中实际的 \",[\"$r\",\"code\",null,{\"children\":\"<input />\"}],\" ）。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"但是，如果你尝试将 ref 放在 \",[\"$r\",\"strong\",null,{\"children\":\"你自己的\"}],\" 组件上，例如 \",[\"$r\",\"code\",null,{\"children\":\"<MyInput />\"}],\"，默认情况下你会得到 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。这个示例演示了这种情况。请注意单击按钮 \",[\"$r\",\"strong\",null,{\"children\":\"并不会\"}],\" 聚焦输入框：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nfunction MyInput(props) {\\n  return <input {...props} />;\\n}\\n\\nexport default function MyForm() {\\n  const inputRef = useRef(null);\\n\\n  function handleClick() {\\n    inputRef.current.focus();\\n  }\\n\\n  return (\\n    <>\\n      <MyInput ref={inputRef} />\\n      <button onClick={handleClick}>\\n        聚焦输入框\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"66\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"为了帮助您注意到这个问题，React 还会向控制台打印一条错误消息：\"}],\"\\n\",[\"$r\",\"ConsoleBlock\",null,{\"level\":\"error\",\"children\":[\"$r\",\"p\",null,{\"children\":\"Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"发生这种情况是因为默认情况下，React 不允许组件访问其他组件的 DOM 节点。甚至自己的子组件也不行！这是故意的。Refs 是一种脱围机制，应该谨慎使用。手动操作 \",[\"$r\",\"strong\",null,{\"children\":\"另一个\"}],\" 组件的 DOM 节点会使你的代码更加脆弱。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"相反，\",[\"$r\",\"strong\",null,{\"children\":\"想要\"}],\" 暴露其 DOM 节点的组件必须\",[\"$r\",\"strong\",null,{\"children\":\"选择\"}],\"该行为。一个组件可以指定将它的 ref “转发”给一个子组件。下面是 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 如何使用 \",[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" API：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const MyInput = forwardRef((props, ref) => {\\n  return <input {...props} ref={ref} />;\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"它是这样工作的:\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"<MyInput ref={inputRef} />\"}],\" 告诉 React 将对应的 DOM 节点放入 \",[\"$r\",\"code\",null,{\"children\":\"inputRef.current\"}],\" 中。但是，这取决于 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件是否允许这种行为， 默认情况下是不允许的。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件是使用 \",[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 声明的。 \",[\"$r\",\"strong\",null,{\"children\":[\"这让从上面接收的 \",[\"$r\",\"code\",null,{\"children\":\"inputRef\"}],\" 作为第二个参数 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 传入组件\"]}],\"，第一个参数是 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件将自己接收到的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 传递给它内部的 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在，单击按钮聚焦输入框起作用了：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { forwardRef, useRef } from 'react';\\n\\nconst MyInput = forwardRef((props, ref) => {\\n  return <input {...props} ref={ref} />;\\n});\\n\\nexport default function Form() {\\n  const inputRef = useRef(null);\\n\\n  function handleClick() {\\n    inputRef.current.focus();\\n  }\\n\\n  return (\\n    <>\\n      <MyInput ref={inputRef} />\\n      <button onClick={handleClick}>\\n        聚焦输入框\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"96\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在设计系统中，将低级组件（如按钮、输入框等）的 ref 转发到它们的 DOM 节点是一种常见模式。另一方面，像表单、列表或页面段落这样的高级组件通常不会暴露它们的 DOM 节点，以避免对 DOM 结构的意外依赖。\"}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"exposing-a-subset-of-the-api-with-an-imperative-handle\",\"children\":\"使用命令句柄暴露一部分 API \"}],[\"$r\",\"p\",null,{\"children\":[\"在上面的例子中，\",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 暴露了原始的 DOM 元素 input。这让父组件可以对其调用\",[\"$r\",\"code\",null,{\"children\":\"focus()\"}],\"。然而，这也让父组件能够做其他事情 —— 例如，改变其 CSS 样式。在一些不常见的情况下，你可能希望限制暴露的功能。你可以用 \",[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}],\" 做到这一点：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import {\\n  forwardRef, \\n  useRef, \\n  useImperativeHandle\\n} from 'react';\\n\\nconst MyInput = forwardRef((props, ref) => {\\n  const realInputRef = useRef(null);\\n  useImperativeHandle(ref, () => ({\\n    // 只暴露 focus，没有别的\\n    focus() {\\n      realInputRef.current.focus();\\n    },\\n  }));\\n  return <input {...props} ref={realInputRef} />;\\n});\\n\\nexport default function Form() {\\n  const inputRef = useRef(null);\\n\\n  function handleClick() {\\n    inputRef.current.focus();\\n  }\\n\\n  return (\\n    <>\\n      <MyInput ref={inputRef} />\\n      <button onClick={handleClick}>\\n        聚焦输入框\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"p\",null,{\"children\":[\"这里，\",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 中的 \",[\"$r\",\"code\",null,{\"children\":\"realInputRef\"}],\" 保存了实际的 input DOM 节点。 但是，\",[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}],\" 指示 React 将你自己指定的对象作为父组件的 ref 值。 所以 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件内的 \",[\"$r\",\"code\",null,{\"children\":\"inputRef.current\"}],\" 将只有 \",[\"$r\",\"code\",null,{\"children\":\"focus\"}],\" 方法。在这种情况下，ref “句柄”不是 DOM 节点，而是你在 \",[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}],\" 调用中创建的自定义对象。\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"when-react-attaches-the-refs\",\"children\":\"React 何时添加 refs \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 React 中，每次更新都分为 \",[\"$r\",\"a\",null,{\"href\":\"/learn/render-and-commit#step-3-react-commits-changes-to-the-dom\",\"children\":\"两个阶段\"}],\"：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在 \",[\"$r\",\"strong\",null,{\"children\":\"渲染\"}],\" 阶段， React 调用你的组件来确定屏幕上应该显示什么。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在 \",[\"$r\",\"strong\",null,{\"children\":\"提交\"}],\" 阶段， React 把变更应用于 DOM。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常，你 \",[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs#best-practices-for-refs\",\"children\":\"不希望\"}],\" 在渲染期间访问 refs。这也适用于保存 DOM 节点的 refs。在第一次渲染期间，DOM 节点尚未创建，因此 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 将为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。在渲染更新的过程中，DOM 节点还没有更新。所以读取它们还为时过早。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 在提交阶段设置 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\"。在更新 DOM 之前，React 将受影响的 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 值设置为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。更新 DOM 后，React 立即将它们设置到相应的 DOM 节点。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"通常，你将从事件处理器访问 refs。\"}],\" 如果你想使用 ref 执行某些操作，但没有特定的事件可以执行此操作，你可能需要一个 effect。我们将在下一页讨论 effect。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"flushing-state-updates-synchronously-with-flush-sync\",\"children\":\"用 flushSync 同步更新 state \"}],[\"$r\",\"p\",null,{\"children\":[\"思考这样的代码，它添加一个新的待办事项，并将屏幕向下滚动到列表的最后一个子项。请注意，出于某种原因，它总是滚动到最后一个添加 \",[\"$r\",\"strong\",null,{\"children\":\"之前\"}],\" 的待办事项：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function TodoList() {\\n  const listRef = useRef(null);\\n  const [text, setText] = useState('');\\n  const [todos, setTodos] = useState(\\n    initialTodos\\n  );\\n\\n  function handleAdd() {\\n    const newTodo = { id: nextId++, text: text };\\n    setText('');\\n    setTodos([ ...todos, newTodo]);\\n    listRef.current.lastChild.scrollIntoView({\\n      behavior: 'smooth',\\n      block: 'nearest'\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <button onClick={handleAdd}>\\n        添加\\n      </button>\\n      <input\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <ul ref={listRef}>\\n        {todos.map(todo => (\\n          <li key={todo.id}>{todo.text}</li>\\n        ))}\\n      </ul>\\n    </>\\n  );\\n}\\n\\nlet nextId = 0;\\nlet initialTodos = [];\\nfor (let i = 0; i < 20; i++) {\\n  initialTodos.push({\\n    id: nextId++,\\n    text: '待办 #' + (i + 1)\\n  });\\n}\\n\"}]}]}],[\"$r\",\"p\",null,{\"children\":\"问题出在这两行：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setTodos([ ...todos, newTodo]);\\nlistRef.current.lastChild.scrollIntoView();\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"在 React 中，\",[\"$r\",\"a\",null,{\"href\":\"/learn/queueing-a-series-of-state-updates\",\"children\":\"state 更新是排队进行的\"}],\"。通常，这就是你想要的。但是，在这个示例中会导致问题，因为 \",[\"$r\",\"code\",null,{\"children\":\"setTodos\"}],\" 不会立即更新 DOM。因此，当你将列表滚动到最后一个元素时，尚未添加待办事项。这就是为什么滚动总是“落后”一项的原因。\"]}],[\"$r\",\"p\",null,{\"children\":[\"要解决此问题，你可以强制 React 同步更新（“刷新”）DOM。 为此，从 \",[\"$r\",\"code\",null,{\"children\":\"react-dom\"}],\" 导入 \",[\"$r\",\"code\",null,{\"children\":\"flushSync\"}],\" 并\",[\"$r\",\"strong\",null,{\"children\":\"将 state 更新包裹\"}],\" 到 \",[\"$r\",\"code\",null,{\"children\":\"flushSync\"}],\" 调用中：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"flushSync(() => {\\n  setTodos([ ...todos, newTodo]);\\n});\\nlistRef.current.lastChild.scrollIntoView();\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"这将指示 React 当封装在 \",[\"$r\",\"code\",null,{\"children\":\"flushSync\"}],\" 中的代码执行后，立即同步更新 DOM。因此，当你尝试滚动到最后一个待办事项时，它已经在 DOM 中了：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\nimport { flushSync } from 'react-dom';\\n\\nexport default function TodoList() {\\n  const listRef = useRef(null);\\n  const [text, setText] = useState('');\\n  const [todos, setTodos] = useState(\\n    initialTodos\\n  );\\n\\n  function handleAdd() {\\n    const newTodo = { id: nextId++, text: text };\\n    flushSync(() => {\\n      setText('');\\n      setTodos([ ...todos, newTodo]);      \\n    });\\n    listRef.current.lastChild.scrollIntoView({\\n      behavior: 'smooth',\\n      block: 'nearest'\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <button onClick={handleAdd}>\\n        添加\\n      </button>\\n      <input\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <ul ref={listRef}>\\n        {todos.map(todo => (\\n          <li key={todo.id}>{todo.text}</li>\\n        ))}\\n      </ul>\\n    </>\\n  );\\n}\\n\\nlet nextId = 0;\\nlet initialTodos = [];\\nfor (let i = 0; i < 20; i++) {\\n  initialTodos.push({\\n    id: nextId++,\\n    text: '待办 #' + (i + 1)\\n  });\\n}\\n\"}]}]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"best-practices-for-dom-manipulation-with-refs\",\"children\":\"使用 refs 操作 DOM 的最佳实践 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Refs 是一种脱围机制。你应该只在你必须“跳出 React”时使用它们。这方面的常见示例包括管理焦点、滚动位置或调用 React 未暴露的浏览器 API。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你坚持聚焦和滚动等非破坏性操作，应该不会遇到任何问题。但是，如果你尝试手动\",[\"$r\",\"strong\",null,{\"children\":\"修改\"}],\" DOM，则可能会与 React 所做的更改发生冲突。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了说明这个问题，这个例子包括一条欢迎消息和两个按钮。第一个按钮使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/conditional-rendering\",\"children\":\"条件渲染\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"state\"}],\" 切换它的显示和隐藏，就像你通常在 React 中所做的那样。第二个按钮使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"remove()\"}],\" DOM API\"]}],\" 将其从 React 控制之外的 DOM 中强行移除.\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"尝试按几次“通过 setState 切换”。该消息会消失并再次出现。然后按 “从 DOM 中删除”。这将强行删除它。最后，按 “通过 setState 切换”：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function Counter() {\\n  const [show, setShow] = useState(true);\\n  const ref = useRef(null);\\n\\n  return (\\n    <div>\\n      <button\\n        onClick={() => {\\n          setShow(!show);\\n        }}>\\n        通过 setState 切换\\n      </button>\\n      <button\\n        onClick={() => {\\n          ref.current.remove();\\n        }}>\\n        从 DOM 中删除\\n      </button>\\n      {show && <p ref={ref}>Hello world</p>}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"p,\\nbutton {\\n  display: block;\\n  margin: 10px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"106\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在你手动删除 DOM 元素后，尝试使用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 再次显示它会导致崩溃。这是因为你更改了 DOM，而 React 不知道如何继续正确管理它。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"避免更改由 React 管理的 DOM 节点。\"}],\" 对 React 管理的元素进行修改、添加子元素、从中删除子元素会导致不一致的视觉结果，或与上述类似的崩溃。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"但是，这并不意味着你完全不能这样做。它需要谨慎。 \",[\"$r\",\"strong\",null,{\"children\":\"你可以安全地修改 React 没有理由更新的部分 DOM。\"}],\" 例如，如果某些 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 在 JSX 中始终为空，React 将没有理由去变动其子列表。 因此，在那里手动增删元素是安全的。\"]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Refs 是一个通用概念，但大多数情况下你会使用它们来保存 DOM 元素。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你通过传递 \",[\"$r\",\"code\",null,{\"children\":\"<div ref={myRef}>\"}],\" 指示 React 将 DOM 节点放入 \",[\"$r\",\"code\",null,{\"children\":\"myRef.current\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"通常，你会将 refs 用于非破坏性操作，例如聚焦、滚动或测量 DOM 元素。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"默认情况下，组件不暴露其 DOM 节点。 您可以通过使用 \",[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 并将第二个 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 参数传递给特定节点来暴露 DOM 节点。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"避免更改由 React 管理的 DOM 节点。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果你确实修改了 React 管理的 DOM 节点，请修改 React 没有理由更新的部分。\"}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"play-and-pause-the-video\",\"children\":\"播放和暂停视频 \"}],[\"$r\",\"p\",null,{\"children\":[\"在此示例中，按钮切换 state 变量以在播放和暂停状态之间切换。 然而，为了实际播放或暂停视频，切换状态是不够的。你还需要在 \",[\"$r\",\"code\",null,{\"children\":\"<video>\"}],\" 的 DOM 元素上调用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/play\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"play()\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/pause\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"pause()\"}]}],\"。 向它添加一个 ref，并使按钮起作用。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function VideoPlayer() {\\n  const [isPlaying, setIsPlaying] = useState(false);\\n\\n  function handleClick() {\\n    const nextIsPlaying = !isPlaying;\\n    setIsPlaying(nextIsPlaying);\\n  }\\n\\n  return (\\n    <>\\n      <button onClick={handleClick}>\\n        {isPlaying ? '暂停' : '播放'}\\n      </button>\\n      <video width=\\\"250\\\">\\n        <source\\n          src=\\\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\\\"\\n          type=\\\"video/mp4\\\"\\n        />\\n      </video>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 20px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"对于额外的挑战，即使用户右键单击视频并使用内置浏览器媒体控件播放，也要使“播放”按钮与视频是否正在播放同步。 您可能需要在视频中监听 \",[\"$r\",\"code\",null,{\"children\":\"onPlay\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"onPause\"}],\" 才能做到这一点。\"]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"声明一个 ref 并将其放在 \",[\"$r\",\"code\",null,{\"children\":\"<video>\"}],\" 元素上。然后根据下一个 state 在事件处理器中调用 \",[\"$r\",\"code\",null,{\"children\":\"ref.current.play()\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"ref.current.pause()\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function VideoPlayer() {\\n  const [isPlaying, setIsPlaying] = useState(false);\\n  const ref = useRef(null);\\n\\n  function handleClick() {\\n    const nextIsPlaying = !isPlaying;\\n    setIsPlaying(nextIsPlaying);\\n\\n    if (nextIsPlaying) {\\n      ref.current.play();\\n    } else {\\n      ref.current.pause();\\n    }\\n  }\\n\\n  return (\\n    <>\\n      <button onClick={handleClick}>\\n        {isPlaying ? '暂停' : '播放'}\\n      </button>\\n      <video\\n        width=\\\"250\\\"\\n        ref={ref}\\n        onPlay={() => setIsPlaying(true)}\\n        onPause={() => setIsPlaying(false)}\\n      >\\n        <source\\n          src=\\\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\\\"\\n          type=\\\"video/mp4\\\"\\n        />\\n      </video>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 20px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"为了处理内置浏览器控件，您可以将 \",[\"$r\",\"code\",null,{\"children\":\"onPlay\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"onPause\"}],\" 处理程序添加到 \",[\"$r\",\"code\",null,{\"children\":\"<video>\"}],\" 元素，并调用它们的 \",[\"$r\",\"code\",null,{\"children\":\"setIsPlaying\"}],\"。 这样，如果用户使用浏览器控件播放视频，状态将相应调整。\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"focus-the-search-field\",\"children\":\"使搜索域获得焦点 \"}],[\"$r\",\"p\",null,{\"children\":\"做到单击“搜索”按钮时，使搜索域获得焦点。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"export default function Page() {\\n  return (\\n    <>\\n      <nav>\\n        <button>搜索</button>\\n      </nav>\\n      <input\\n        placeholder=\\\"找什么呢？\\\"\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"向输入框添加一个 ref，并在 DOM 节点上调用 \",[\"$r\",\"code\",null,{\"children\":\"focus()\"}],\" 以使其获得焦点：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Page() {\\n  const inputRef = useRef(null);\\n  return (\\n    <>\\n      <nav>\\n        <button onClick={() => {\\n          inputRef.current.focus();\\n        }}>\\n          搜索\\n        </button>\\n      </nav>\\n      <input\\n        ref={inputRef}\\n        placeholder=\\\"找什么呢？\\\"\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 10px; }\\n\"}]}]]}]]}],[\"$r\",\"h4\",null,{\"id\":\"scrolling-an-image-carousel\",\"children\":\"滚动图像轮播 \"}],[\"$r\",\"p\",null,{\"children\":[\"此图像轮播有一个“下一个”按钮，可以切换激活的图像。单击时使图库水平滚动到激活的图像。你需要在激活的图像的 DOM 节点上调用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"scrollIntoView()\"}]}],\"：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"node.scrollIntoView({\\n  behavior: 'smooth',\\n  block: 'nearest',\\n  inline: 'center'\\n});\\n\"}]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"在本练习中，你不需要对每个图像都添加 ref。对当前激活的图像或图像列表本身有一个 ref 就足够了。使用 \",[\"$r\",\"code\",null,{\"children\":\"flushSync\"}],\" 确保 DOM 在滚动 \",[\"$r\",\"strong\",null,{\"children\":\"之前\"}],\" 更新。\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function CatFriends() {\\n  const [index, setIndex] = useState(0);\\n  return (\\n    <>\\n      <nav>\\n        <button onClick={() => {\\n          if (index < catList.length - 1) {\\n            setIndex(index + 1);\\n          } else {\\n            setIndex(0);\\n          }\\n        }}>\\n          下一个\\n        </button>\\n      </nav>\\n      <div>\\n        <ul>\\n          {catList.map((cat, i) => (\\n            <li key={cat.id}>\\n              <img\\n                className={\\n                  index === i ?\\n                    'active' :\\n                    ''\\n                }\\n                src={cat.imageUrl}\\n                alt={'猫猫 #' + cat.id}\\n              />\\n            </li>\\n          ))}\\n        </ul>\\n      </div>\\n    </>\\n  );\\n}\\n\\nconst catList = [];\\nfor (let i = 0; i < 10; i++) {\\n  catList.push({\\n    id: i,\\n    imageUrl: 'https://placekitten.com/250/200?image=' + i\\n  });\\n}\\n\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"div {\\n  width: 100%;\\n  overflow: hidden;\\n}\\n\\nnav {\\n  text-align: center;\\n}\\n\\nbutton {\\n  margin: .25rem;\\n}\\n\\nul,\\nli {\\n  list-style: none;\\n  white-space: nowrap;\\n}\\n\\nli {\\n  display: inline;\\n  padding: 0.5rem;\\n}\\n\\nimg {\\n  padding: 10px;\\n  margin: -10px;\\n  transition: background 0.2s linear;\\n}\\n\\n.active {\\n  background: rgba(0, 100, 150, 0.4);\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"你可以声明一个 \",[\"$r\",\"code\",null,{\"children\":\"selectedRef\"}],\"，然后根据条件将它传递给当前图像：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<li ref={index === i ? selectedRef : null}>\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"当\",[\"$r\",\"code\",null,{\"children\":\"index === i\"}],\"时，表示图像是被选中的图像，相应的 \",[\"$r\",\"code\",null,{\"children\":\"<li>\"}],\" 将接收到 \",[\"$r\",\"code\",null,{\"children\":\"selectedRef\"}],\"。React 将确保 \",[\"$r\",\"code\",null,{\"children\":\"selectedRef.current\"}],\" 始终指向正确的 DOM 节点。\"]}],[\"$r\",\"p\",null,{\"children\":[\"请注意，为了强制 React 在滚动前更新 DOM，\",[\"$r\",\"code\",null,{\"children\":\"flushSync\"}],\" 调用是必需的。否则，\",[\"$r\",\"code\",null,{\"children\":\"selectedRef.current\"}],\"将始终指向之前选择的项目。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef, useState } from 'react';\\nimport { flushSync } from 'react-dom';\\n\\nexport default function CatFriends() {\\n  const selectedRef = useRef(null);\\n  const [index, setIndex] = useState(0);\\n\\n  return (\\n    <>\\n      <nav>\\n        <button onClick={() => {\\n          flushSync(() => {\\n            if (index < catList.length - 1) {\\n              setIndex(index + 1);\\n            } else {\\n              setIndex(0);\\n            }\\n          });\\n          selectedRef.current.scrollIntoView({\\n            behavior: 'smooth',\\n            block: 'nearest',\\n            inline: 'center'\\n          });            \\n        }}>\\n          下一步\\n        </button>\\n      </nav>\\n      <div>\\n        <ul>\\n          {catList.map((cat, i) => (\\n            <li\\n              key={cat.id}\\n              ref={index === i ?\\n                selectedRef :\\n                null\\n              }\\n            >\\n              <img\\n                className={\\n                  index === i ?\\n                    'active'\\n                    : ''\\n                }\\n                src={cat.imageUrl}\\n                alt={'猫猫 #' + cat.id}\\n              />\\n            </li>\\n          ))}\\n        </ul>\\n      </div>\\n    </>\\n  );\\n}\\n\\nconst catList = [];\\nfor (let i = 0; i < 10; i++) {\\n  catList.push({\\n    id: i,\\n    imageUrl: 'https://placekitten.com/250/200?image=' + i\\n  });\\n}\\n\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"div {\\n  width: 100%;\\n  overflow: hidden;\\n}\\n\\nnav {\\n  text-align: center;\\n}\\n\\nbutton {\\n  margin: .25rem;\\n}\\n\\nul,\\nli {\\n  list-style: none;\\n  white-space: nowrap;\\n}\\n\\nli {\\n  display: inline;\\n  padding: 0.5rem;\\n}\\n\\nimg {\\n  padding: 10px;\\n  margin: -10px;\\n  transition: background 0.2s linear;\\n}\\n\\n.active {\\n  background: rgba(0, 100, 150, 0.4);\\n}\\n\"}]}]]}]]}],[\"$r\",\"h4\",null,{\"id\":\"focus-the-search-field-with-separate-components\",\"children\":\"使分开的组件中的搜索域获得焦点 \"}],[\"$r\",\"p\",null,{\"children\":\"做到单击“搜索”按钮将焦点放在搜索域上。请注意，每个组件都在单独的文件中定义，并且不能将其移出。如何将它们连接在一起？\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"你需要 \",[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 来主动从你自己的组件中暴露一个 DOM 节点，比如 \",[\"$r\",\"code\",null,{\"children\":\"SearchInput\"}],\"。\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import SearchButton from './SearchButton.js';\\nimport SearchInput from './SearchInput.js';\\n\\nexport default function Page() {\\n  return (\\n    <>\\n      <nav>\\n        <SearchButton />\\n      </nav>\\n      <SearchInput />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/SearchButton.js\",\"children\":\"export default function SearchButton() {\\n  return (\\n    <button>\\n      搜索\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/SearchInput.js\",\"children\":\"export default function SearchInput() {\\n  return (\\n    <input\\n      placeholder=\\\"找什么呢？\\\"\\n    />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"你需要向 \",[\"$r\",\"code\",null,{\"children\":\"SearchButton\"}],\" 添加一个\",[\"$r\",\"code\",null,{\"children\":\"onClick\"}],\" 属性，\",[\"$r\",\"code\",null,{\"children\":\"SearchButton\"}],\" 会将其向下传递给浏览器原生 \",[\"$r\",\"code\",null,{\"children\":\"<button>\"}],\"。你还要向下传递一个 ref 给 \",[\"$r\",\"code\",null,{\"children\":\"<SearchInput>\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"<SearchInput>\"}],\" 将转发 ref 给真正的 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" 并对它进行赋值。最后，在单击事件处理器中，你将能对存储在该 ref 中的 DOM 节点调用 \",[\"$r\",\"code\",null,{\"children\":\"focus\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useRef } from 'react';\\nimport SearchButton from './SearchButton.js';\\nimport SearchInput from './SearchInput.js';\\n\\nexport default function Page() {\\n  const inputRef = useRef(null);\\n  return (\\n    <>\\n      <nav>\\n        <SearchButton onClick={() => {\\n          inputRef.current.focus();\\n        }} />\\n      </nav>\\n      <SearchInput ref={inputRef} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/SearchButton.js\",\"children\":\"export default function SearchButton({ onClick }) {\\n  return (\\n    <button onClick={onClick}>\\n      搜索\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/SearchInput.js\",\"children\":\"import { forwardRef } from 'react';\\n\\nexport default forwardRef(\\n  function SearchInput(props, ref) {\\n    return (\\n      <input\\n        ref={ref}\\n        placeholder=\\\"找什么呢？\\\"\\n      />\\n    );\\n  }\\n);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 10px; }\\n\"}]}]]}]]}]]}]]","meta":{"title":"使用 ref 操作 DOM","translators":["SylviaZ89"]}},"__N_SSG":true}