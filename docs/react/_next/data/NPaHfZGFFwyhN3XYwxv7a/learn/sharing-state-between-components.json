{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#lifting-state-up-by-example\",\"depth\":2,\"text\":\"举例说明一下状态提升 \"},{\"url\":\"#step-1-remove-state-from-the-child-components\",\"depth\":3,\"text\":\"第 1 步: 从子组件中移除状态 \"},{\"url\":\"#step-2-pass-hardcoded-data-from-the-common-parent\",\"depth\":3,\"text\":\"第 2 步: 从公共父组件传递硬编码数据 \"},{\"url\":\"#step-3-add-state-to-the-common-parent\",\"depth\":3,\"text\":\"第 3 步: 为公共父组件添加状态 \"},{\"url\":\"#a-single-source-of-truth-for-each-state\",\"depth\":2,\"text\":\"每个状态都对应唯一的数据源 \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"14\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"有时候，你希望两个组件的状态始终同步更改。要实现这一点，可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这被称为“状态提升”，这是编写 React 代码时常做的事。\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何使用状态提升在组件之间共享状态\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"什么是受控组件和非受控组件\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"lifting-state-up-by-example\",\"children\":\"举例说明一下状态提升 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，父组件 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 渲染了 2 个独立的 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件。\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"Panel\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"Panel\"}]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"每个 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件都有一个布尔值 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\"，用于控制其内容是否可见。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"请点击 2 个面板中的显示按钮：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nfunction Panel({ title, children }) {\\n  const [isActive, setIsActive] = useState(false);\\n  return (\\n    <section className=\\\"panel\\\">\\n      <h3>{title}</h3>\\n      {isActive ? (\\n        <p>{children}</p>\\n      ) : (\\n        <button onClick={() => setIsActive(true)}>\\n          显示\\n        </button>\\n      )}\\n    </section>\\n  );\\n}\\n\\nexport default function Accordion() {\\n  return (\\n    <>\\n      <h2>哈萨克斯坦，阿拉木图</h2>\\n      <Panel title=\\\"关于\\\">\\n        阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。\\n      </Panel>\\n      <Panel title=\\\"词源\\\">\\n        这个名字来自于 <span lang=\\\"kk-KZ\\\">алма</span>，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，<i lang=\\\"la\\\">Malus sieversii</i> 被认为是现今苹果的祖先。\\n      </Panel>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"h3, p { margin: 5px 0px; }\\n.panel {\\n  padding: 10px;\\n  border: 1px solid #aaa;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"48\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"我们发现点击其中一个面板中的按钮并不会影响另外一个，他们是独立的。\"}],\"\\n\",[\"$r\",\"DiagramGroup\",null,{\"children\":[[\"$r\",\"Diagram\",null,{\"name\":\"sharing_state_child\",\"height\":367,\"width\":477,\"alt\":\"这个图表展示了一个包含三个组件的树形结构图，其中父组件是 Accordion，子组件是 Panel。这 2 个 Panel 组件内部都有 isActive 属性，值为 false。\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"由于一开始所有 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 内部的 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 都是 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\"，因此它们的内容都不会显示。\"]}]}],[\"$r\",\"Diagram\",null,{\"name\":\"sharing_state_child_clicked\",\"height\":367,\"width\":480,\"alt\":\"这个图表与前面的是一样的，只是这里高亮显示了第一个子 Panel 组件的 isActive 属性，表示鼠标点击后将 isActive 的值设置为了 true。而第二个 Panel 组件的 isActive 值仍然还是 false。\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"此时，点击任意一个 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件中的按钮都只会更新当前 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件内的 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 值\"]}]}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"假设现在您想改变这种行为，以便在任何时候只展开一个面板\"}],\"。在这种设计下，展开第 2 个面板应会折叠第 1 个面板。您该如何做到这一点呢？“\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"要协调好这两个面板，我们需要分 3 步将状态“提升”到他们的父组件中。\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"从子组件中 \",[\"$r\",\"strong\",null,{\"children\":\"移除\"}],\" state 。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"从父组件 \",[\"$r\",\"strong\",null,{\"children\":\"传递\"}],\" 硬编码数据。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"为共同的父组件添加 state ，并将其与事件处理函数一起向下传递。\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这样，\",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 组件就可以控制 2 个 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件，保证同一时间只能展开一个。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"step-1-remove-state-from-the-child-components\",\"children\":\"第 1 步: 从子组件中移除状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你将把 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件对 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 的控制权交给他们的父组件。这意味着，父组件会将 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 作为 \",[\"$r\",\"code\",null,{\"children\":\"prop\"}],\" 传给子组件 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\"。我们先从 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件中 \",[\"$r\",\"strong\",null,{\"children\":\"删除下面这一行\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [isActive, setIsActive] = useState(false);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然后，把 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 加入 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件的 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Panel({ title, children, isActive }) {\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 的父组件就可以通过 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":\"向下传递 prop\"}],\" 来 \",[\"$r\",\"strong\",null,{\"children\":\"控制\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\"。但相反地，\",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件对 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 的值 \",[\"$r\",\"strong\",null,{\"children\":\"没有控制权\"}],\" —— 现在完全由父组件决定！\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"step-2-pass-hardcoded-data-from-the-common-parent\",\"children\":\"第 2 步: 从公共父组件传递硬编码数据 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了实现状态提升，必须定位到你想协调的 \",[\"$r\",\"strong\",null,{\"children\":\"两个\"}],\" 子组件最近的公共父组件：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" \",[\"$r\",\"strong\",null,{\"children\":\"(最近的公共父组件)\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"Panel\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"Panel\"}]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，公共父组件是 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\"。因为它位于两个面板之上，可以控制它们的 props，所以它将成为当前激活面板的“控制之源”。通过 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 组件将硬编码值 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\"（例如 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\" ）传递给两个面板：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Accordion() {\\n  return (\\n    <>\\n      <h2>哈萨克斯坦，阿拉木图</h2>\\n      <Panel title=\\\"关于\\\" isActive={true}>\\n        阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。\\n      </Panel>\\n      <Panel title=\\\"词源\\\" isActive={true}>\\n        这个名字来自于 <span lang=\\\"kk-KZ\\\">алма</span>，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，<i lang=\\\"la\\\">Malus sieversii</i> 被认为是现今苹果的祖先。\\n      </Panel>\\n    </>\\n  );\\n}\\n\\nfunction Panel({ title, children, isActive }) {\\n  return (\\n    <section className=\\\"panel\\\">\\n      <h3>{title}</h3>\\n      {isActive ? (\\n        <p>{children}</p>\\n      ) : (\\n        <button onClick={() => setIsActive(true)}>\\n          显示\\n        </button>\\n      )}\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"h3, p { margin: 5px 0px; }\\n.panel {\\n  padding: 10px;\\n  border: 1px solid #aaa;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"68\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以尝试修改 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 组件中 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 的值，并在屏幕上查看结果。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"step-3-add-state-to-the-common-parent\",\"children\":\"第 3 步: 为公共父组件添加状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"状态提升通常会改变原状态的数据存储类型。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，一次只能激活一个面板。这意味着 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 这个父组件需要记录 \",[\"$r\",\"strong\",null,{\"children\":\"哪个\"}],\" 面板是被激活的面板。我们可以用数字作为当前被激活 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 的索引，而不是 \",[\"$r\",\"code\",null,{\"children\":\"boolean\"}],\" 值：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [activeIndex, setActiveIndex] = useState(0);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当 \",[\"$r\",\"code\",null,{\"children\":\"activeIndex\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" 时，激活第一个面板，为 \",[\"$r\",\"code\",null,{\"children\":\"1\"}],\" 时，激活第二个面板。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在任意一个 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 中点击“显示”按钮都需要更改 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 中的激活索引值。 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 中无法直接设置状态 \",[\"$r\",\"code\",null,{\"children\":\"activeIndex\"}],\" 的值，因为该状态是在 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 组件内部定义的。 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 组件需要 \",[\"$r\",\"strong\",null,{\"children\":\"显式允许\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件通过 \",[\"$r\",\"a\",null,{\"href\":\"/learn/responding-to-events#passing-event-handlers-as-props\",\"children\":\"将事件处理程序作为 prop 向下传递\"}],\" 来更改其状态：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<>\\n  <Panel\\n    isActive={activeIndex === 0}\\n    onShow={() => setActiveIndex(0)}\\n  >\\n    ...\\n  </Panel>\\n  <Panel\\n    isActive={activeIndex === 1}\\n    onShow={() => setActiveIndex(1)}\\n  >\\n    ...\\n  </Panel>\\n</>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件中的 \",[\"$r\",\"code\",null,{\"children\":\"<button>\"}],\" 将使用 \",[\"$r\",\"code\",null,{\"children\":\"onShow\"}],\" 这个属性作为其点击事件的处理程序：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Accordion() {\\n  const [activeIndex, setActiveIndex] = useState(0);\\n  return (\\n    <>\\n      <h2>哈萨克斯坦，阿拉木图</h2>\\n      <Panel\\n        title=\\\"关于\\\"\\n        isActive={activeIndex === 0}\\n        onShow={() => setActiveIndex(0)}\\n      >\\n        阿拉木图人口约200万，是哈萨克斯坦最大的城市。它在 1929 年到 1997 年间都是首都。\\n      </Panel>\\n      <Panel\\n        title=\\\"词源\\\"\\n        isActive={activeIndex === 1}\\n        onShow={() => setActiveIndex(1)}\\n      >\\n        这个名字来自于 <span lang=\\\"kk-KZ\\\">алма</span>，哈萨克语中“苹果”的意思，经常被翻译成“苹果之乡”。事实上，阿拉木图的周边地区被认为是苹果的发源地，<i lang=\\\"la\\\">Malus sieversii</i> 被认为是现今苹果的祖先。\\n      </Panel>\\n    </>\\n  );\\n}\\n\\nfunction Panel({\\n  title,\\n  children,\\n  isActive,\\n  onShow\\n}) {\\n  return (\\n    <section className=\\\"panel\\\">\\n      <h3>{title}</h3>\\n      {isActive ? (\\n        <p>{children}</p>\\n      ) : (\\n        <button onClick={onShow}>\\n          显示\\n        </button>\\n      )}\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"h3, p { margin: 5px 0px; }\\n.panel {\\n  padding: 10px;\\n  border: 1px solid #aaa;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"88\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这样，我们就完成了对状态的提升！将状态移至公共父组件中可以让你更好的管理这两个面板。使用激活索引值代替之前的 \",[\"$r\",\"code\",null,{\"children\":\"是否显示\"}],\" 标识确保了一次只能激活一个面板。而通过向下传递事件处理函数可以让子组件修改父组件的状态。\"]}],\"\\n\",[\"$r\",\"DiagramGroup\",null,{\"children\":[[\"$r\",\"Diagram\",null,{\"name\":\"sharing_state_parent\",\"height\":385,\"width\":487,\"alt\":\"这个图表展示了一个包含三个组件的树形结构图，其中父组件是 Accordion，两个子组件是 Panel。Accordion 包含一个值为 0 的 activeIndex 属性，该属性会传递给第一个Panel 组件，让其内部的 isActive 值变为 true，同时会传递给第二个 Panel 组件，让其内部的 isActive 值变为 false。\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"一开始, \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 组件中的 \",[\"$r\",\"code\",null,{\"children\":\"activeIndex\"}],\" 是 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\"，此时第一个 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件接受到的属性为 \",[\"$r\",\"code\",null,{\"children\":\"isActive = true\"}]]}]}],[\"$r\",\"Diagram\",null,{\"name\":\"sharing_state_parent_clicked\",\"height\":385,\"width\":521,\"alt\":\"这个图表与前面的是一样的，只是突出显示了父 Accordion 组件的 activeIndex值，表示单击后该值已更改为 1。同时，强调了两个子 Panel 组件的流程，并将传递给每个子组件的 isActive 值设置为相反的值：第一个 Panel 的值为 false，第二个 Panel 的值为 true。\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"当 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 组件中的 \",[\"$r\",\"code\",null,{\"children\":\"activeIndex\"}],\" 变为 \",[\"$r\",\"code\",null,{\"children\":\"1\"}],\" 时，第二个 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件接受到的属性变为 \",[\"$r\",\"code\",null,{\"children\":\"isActive = true\"}],\"，第一个 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件接受到的属性变为 \",[\"$r\",\"code\",null,{\"children\":\"isActive = false\"}]]}]}]]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"controlled-and-uncontrolled-components\",\"children\":\"受控组件和非受控组件 \"}],[\"$r\",\"p\",null,{\"children\":[\"通常我们把包含“不受控制”状态的组件称为“非受控组件”。例如，最开始带有 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 状态变量的 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件就是不受控制的，因为其父组件无法控制面板的激活状态。\"]}],[\"$r\",\"p\",null,{\"children\":[\"相反，当组件中的重要信息是由 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 而不是其自身状态驱动时，就可以认为该组件是“受控组件”。这就允许父组件完全指定其行为。最后带有 \",[\"$r\",\"code\",null,{\"children\":\"isActive\"}],\" 属性的 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 组件是由 \",[\"$r\",\"code\",null,{\"children\":\"Accordion\"}],\" 组件控制的。\"]}],[\"$r\",\"p\",null,{\"children\":[\"非受控组件通常很简单，因为它们不需要太多配置。但是当你想把它们组合在一起使用时，就不那么灵活了。受控组件具有最大的灵活性，但它们需要父组件使用 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 对其进行配置。\"]}],[\"$r\",\"p\",null,{\"children\":[\"在实践中，“受控”和“非受控”并不是严格的技术术语——通常每个组件都同时拥有内部状态和 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\"。然而，这对于组件该如何设计和提供什么样功能的讨论是有帮助的。\"]}],[\"$r\",\"p\",null,{\"children\":[\"当编写一个组件时，你应该考虑哪些信息应该受控制（通过 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\"），哪些信息不应该受控制（通过 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\"）。当然，你可以随时改变主意并重构代码。\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"a-single-source-of-truth-for-each-state\",\"children\":\"每个状态都对应唯一的数据源 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 \",[\"$r\",\"code\",null,{\"children\":\"React\"}],\" 应用中，很多组件都有自己的状态。一些状态可能“活跃”在叶子组件（树形结构最底层的组件）附近，例如输入框。另一些状态可能在应用程序顶部“活动”。例如，客户端路由库也是通过将当前路由存储在 \",[\"$r\",\"code\",null,{\"children\":\"React\"}],\" 状态中，利用 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 将状态层层传递下去来实现的！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state\"}],\"。这一原则也被称为拥有 \",[\"$r\",\"a\",null,{\"href\":\"https://en.wikipedia.org/wiki/Single_source_of_truth\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"“可信单一数据源”\"}],\"。它并不意味着所有状态都存在一个地方——对每个状态来说，都需要一个特定的组件来保存这些状态信息。你应该 \",[\"$r\",\"strong\",null,{\"children\":\"将状态提升\"}],\" 到公共父级，或 \",[\"$r\",\"strong\",null,{\"children\":\"将状态传递\"}],\" 到需要它的子级中，而不是在组件之间复制共享的状态。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你的应用会随着你的操作而变化。当你将状态上下移动时，你依然会想要确定每个状态在哪里“活跃”。这都是过程的一部分！\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"想了解在更多组件中的实践，请阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/thinking-in-react\",\"children\":\"React 思维\"}],\".\"]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"当你想要整合两个组件时，将它们的 state 移动到共同的父组件中。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"然后在父组件中通过 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 把信息传递下去。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"最后，向下传递事件处理程序，以便子组件可以改变父组件的 state 。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"考虑该将组件视为“受控”（由 prop 驱动）或是“不受控”（由 state 驱动）是十分有益的。\"}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"synced-inputs\",\"children\":\"同步输入状态 \"}],[\"$r\",\"p\",null,{\"children\":\"现在有两个独立的输入框。为了让它们保持同步：即编辑一个输入框时，另一个输入框也会更新相同的文本，反之亦然。\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"你需要将它们的状态移动到父组件中。\"}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function SyncedInputs() {\\n  return (\\n    <>\\n      <Input label=\\\"第一个输入框\\\" />\\n      <Input label=\\\"第二个输入框\\\" />\\n    </>\\n  );\\n}\\n\\nfunction Input({ label }) {\\n  const [text, setText] = useState('');\\n\\n  function handleChange(e) {\\n    setText(e.target.value);\\n  }\\n\\n  return (\\n    <label>\\n      {label}\\n      {' '}\\n      <input\\n        value={text}\\n        onChange={handleChange}\\n      />\\n    </label>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { margin: 5px; }\\nlabel { display: block; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"将 \",[\"$r\",\"code\",null,{\"children\":\"text\"}],\" 状态变量与 \",[\"$r\",\"code\",null,{\"children\":\"handleChange\"}],\" 处理程序一起移动到父组件中。然后将它们作为 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 传递给两个 \",[\"$r\",\"code\",null,{\"children\":\"Input\"}],\" 组件。这样它们就能保持同步了。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function SyncedInputs() {\\n  const [text, setText] = useState('');\\n\\n  function handleChange(e) {\\n    setText(e.target.value);\\n  }\\n\\n  return (\\n    <>\\n      <Input\\n        label=\\\"第一个输入框\\\"\\n        value={text}\\n        onChange={handleChange}\\n      />\\n      <Input\\n        label=\\\"第二个输入框\\\"\\n        value={text}\\n        onChange={handleChange}\\n      />\\n    </>\\n  );\\n}\\n\\nfunction Input({ label, value, onChange }) {\\n  return (\\n    <label>\\n      {label}\\n      {' '}\\n      <input\\n        value={value}\\n        onChange={onChange}\\n      />\\n    </label>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { margin: 5px; }\\nlabel { display: block; }\\n\"}]}]]}]]}],[\"$r\",\"h4\",null,{\"id\":\"filtering-a-list\",\"children\":\"列表过滤 \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\" 组件拥有一个用来控制输入框的 \",[\"$r\",\"code\",null,{\"children\":\"query\"}],\" 状态，它的父组件中展示了一个 \",[\"$r\",\"code\",null,{\"children\":\"List\"}],\" 组件，但是没有考虑搜索条件。\"]}],[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"filterItems(foods, query)\"}],\" 方法来通过搜索条件过滤列表项。为了测试修改是否正确，请尝试在输入框中输入 “寿司” ，“烤肉串” 或 “点心”。\"]}],[\"$r\",\"p\",null,{\"children\":[\"可以看到 \",[\"$r\",\"code\",null,{\"children\":\"filterItems\"}],\" 已经自动引入了，所以不需要我们自己再引入了。\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"你需要从 \",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\" 组件中移除 \",[\"$r\",\"code\",null,{\"children\":\"query\"}],\" 状态和 \",[\"$r\",\"code\",null,{\"children\":\"handleChange\"}],\" 处理程序，并把它们移到 \",[\"$r\",\"code\",null,{\"children\":\"FilterableList\"}],\" 组件中。然后将 \",[\"$r\",\"code\",null,{\"children\":\"query\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"onChange\"}],\" 当做 props 向下传递给 \",[\"$r\",\"code\",null,{\"children\":\"SearchBar\"}],\" 组件。\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\nimport { foods, filterItems } from './data.js';\\n\\nexport default function FilterableList() {\\n  return (\\n    <>\\n      <SearchBar />\\n      <hr />\\n      <List items={foods} />\\n    </>\\n  );\\n}\\n\\nfunction SearchBar() {\\n  const [query, setQuery] = useState('');\\n\\n  function handleChange(e) {\\n    setQuery(e.target.value);\\n  }\\n\\n  return (\\n    <label>\\n      搜索：{' '}\\n      <input\\n        value={query}\\n        onChange={handleChange}\\n      />\\n    </label>\\n  );\\n}\\n\\nfunction List({ items }) {\\n  return (\\n    <table>\\n      <tbody>\\n        {items.map(food => (\\n          <tr key={food.id}>\\n            <td>{food.name}</td>\\n            <td>{food.description}</td>\\n          </tr>\\n        ))}\\n      </tbody>\\n    </table>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export function filterItems(items, query) {\\n  query = query.toLowerCase();\\n  return items.filter(item =>\\n    item.name.split(' ').some(word =>\\n      word.toLowerCase().startsWith(query)\\n    )\\n  );\\n}\\n\\nexport const foods = [{\\n  id: 0,\\n  name: '寿司',\\n  description: '寿司是一道传统的日本菜，是用醋米饭做成的'\\n}, {\\n  id: 1,\\n  name: '木豆',\\n  description: '制作木豆最常见的方法是在汤中加入洋葱、西红柿和各种香料'\\n}, {\\n  id: 2,\\n  name: '饺子',\\n  description: '饺子是用未发酵的面团包裹咸的或甜的馅料，然后在沸水中煮制而成的'\\n}, {\\n  id: 3,\\n  name: '烤肉串',\\n  description: '烤肉串是一种很受欢迎的食物，是用肉串和肉块做成。'\\n}, {\\n  id: 4,\\n  name: '点心',\\n  description: '点心是广东人的传统喜好，是在餐馆吃早餐和午餐时喜欢吃的一系列小菜'\\n}];\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"将 \",[\"$r\",\"code\",null,{\"children\":\"query\"}],\" 状态提升到 \",[\"$r\",\"code\",null,{\"children\":\"FilterableList\"}],\" 组件中。调用 \",[\"$r\",\"code\",null,{\"children\":\"filterItems(foods, query)\"}],\" 方法获取过滤后的列表并将其传递给 \",[\"$r\",\"code\",null,{\"children\":\"List\"}],\" 组件。现在修改查询条件就会反映在列表中：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\nimport { foods, filterItems } from './data.js';\\n\\nexport default function FilterableList() {\\n  const [query, setQuery] = useState('');\\n  const results = filterItems(foods, query);\\n\\n  function handleChange(e) {\\n    setQuery(e.target.value);\\n  }\\n\\n  return (\\n    <>\\n      <SearchBar\\n        query={query}\\n        onChange={handleChange}\\n      />\\n      <hr />\\n      <List items={results} />\\n    </>\\n  );\\n}\\n\\nfunction SearchBar({ query, onChange }) {\\n  return (\\n    <label>\\n      搜索：{' '}\\n      <input\\n        value={query}\\n        onChange={onChange}\\n      />\\n    </label>\\n  );\\n}\\n\\nfunction List({ items }) {\\n  return (\\n    <table>\\n      <tbody> \\n        {items.map(food => (\\n          <tr key={food.id}>\\n            <td>{food.name}</td>\\n            <td>{food.description}</td>\\n          </tr>\\n        ))}\\n      </tbody>\\n    </table>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export function filterItems(items, query) {\\n  query = query.toLowerCase();\\n  return items.filter(item =>\\n    item.name.split(' ').some(word =>\\n      word.toLowerCase().startsWith(query)\\n    )\\n  );\\n}\\n\\nexport const foods = [{\\n  id: 0,\\n  name: '寿司',\\n  description: '寿司是一道传统的日本菜，是用醋米饭做成的'\\n}, {\\n  id: 1,\\n  name: '木豆',\\n  description: '制作木豆最常见的方法是在汤中加入洋葱、西红柿和各种香料'\\n}, {\\n  id: 2,\\n  name: '饺子',\\n  description: '饺子是用未发酵的面团包裹咸的或甜的馅料，然后在沸水中煮制而成的'\\n}, {\\n  id: 3,\\n  name: '烤肉串',\\n  description: '烤肉串是一种很受欢迎的食物，是用肉串和肉块做成。'\\n}, {\\n  id: 4,\\n  name: '点心',\\n  description: '点心是广东人的传统喜好，是在餐馆吃早餐和午餐时喜欢吃的一系列小菜'\\n}];\\n\"}]}]]}]]}]]}]]","meta":{"title":"在组件间共享状态","translators":["qinhua"]}},"__N_SSG":true}