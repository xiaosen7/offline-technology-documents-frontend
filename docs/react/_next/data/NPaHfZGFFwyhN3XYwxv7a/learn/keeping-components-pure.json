{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#purity-components-as-formulas\",\"depth\":2,\"text\":\"纯函数：组件作为公式 \"},{\"url\":\"#side-effects-unintended-consequences\",\"depth\":2,\"text\":\"副作用：（不符合）预期的后果 \"},{\"url\":\"#local-mutation-your-components-little-secret\",\"depth\":3,\"text\":\"局部 mutation：组件的小秘密 \"},{\"url\":\"#where-you-can-cause-side-effects\",\"depth\":2,\"text\":[\"哪些地方 \",[\"$r\",\"strong\",null,{\"children\":\"可能\"}],\" 引发副作用 \"]},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"30\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"部分 JavaScript 函数是 \",[\"$r\",\"strong\",null,{\"children\":\"纯粹\"}],\" 的，这类函数通常被称为纯函数。纯函数仅执行计算操作，不做其他操作。你可以通过将组件按纯函数严格编写，以避免一些随着代码库的增长而出现的、令人困扰的 bug 以及不可预测的行为。但为了获得这些好处，你需要遵循一些规则。\"]}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"纯函数是什么，以及它如何帮助你避免 bug\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何将数据变更与渲染过程分离，以保持组件的纯粹\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何使用严格模式发现组件中的错误\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"purity-components-as-formulas\",\"children\":\"纯函数：组件作为公式 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在计算机科学中（尤其是函数式编程的世界中），\",[\"$r\",\"a\",null,{\"href\":\"https://wikipedia.org/wiki/Pure_function\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"纯函数\"}],\" 通常具有如下特征：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"只负责自己的任务\"}],\"。它不会更改在该函数调用前就已存在的对象或变量。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"输入相同，则输出相同\"}],\"。给定相同的输入，纯函数应总是返回相同的结果。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"举个你非常熟悉的纯函数示例：数学中的公式。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"考虑如下数学公式：\",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 2\",[\"$r\",\"MathI\",null,{\"children\":\"x\"}]]}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"若 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"x\"}],\" = 2\"]}],\" 则 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 4\"]}],\"。永远如此。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"若 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"x\"}],\" = 3\"]}],\" 则 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 6\"]}],\"。永远如此。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"若 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"x\"}],\" = 3\"]}],\"，那么 \",[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" 并不会因为时间或股市的影响，而有时等于 \",[\"$r\",\"Math\",null,{\"children\":\"9\"}],\" 、 \",[\"$r\",\"Math\",null,{\"children\":\"–1\"}],\" 或 \",[\"$r\",\"Math\",null,{\"children\":\"2.5\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"若 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 2\",[\"$r\",\"MathI\",null,{\"children\":\"x\"}]]}],\" 且 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"x\"}],\" = 3\"]}],\", 那么 \",[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" \",[\"$r\",\"em\",null,{\"children\":\"永远\"}],\" 等于 \",[\"$r\",\"Math\",null,{\"children\":\"6\"}],\".\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"我们使用 JavaScript 的函数实现，看起来将会是这样：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function double(number) {\\n  return 2 * number;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"上述例子中，\",[\"$r\",\"code\",null,{\"children\":\"double()\"}],\" 就是一个 \",[\"$r\",\"strong\",null,{\"children\":\"纯函数\"}],\"。如果你传入 \",[\"$r\",\"code\",null,{\"children\":\"3\"}],\" ，它将总是返回 \",[\"$r\",\"code\",null,{\"children\":\"6\"}],\" 。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 便围绕着这个概念进行设计。\",[\"$r\",\"strong\",null,{\"children\":\"React 假设你编写的所有组件都是纯函数\"}],\"。也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"function Recipe({ drinkers }) {\\n  return (\\n    <ol>    \\n      <li>Boil {drinkers} cups of water.</li>\\n      <li>Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.</li>\\n      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>\\n    </ol>\\n  );\\n}\\n\\nexport default function App() {\\n  return (\\n    <section>\\n      <h1>Spiced Chai Recipe</h1>\\n      <h2>For two</h2>\\n      <Recipe drinkers={2} />\\n      <h2>For a gathering</h2>\\n      <Recipe drinkers={4} />\\n    </section>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"40\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你给函数 \",[\"$r\",\"code\",null,{\"children\":\"Recipe\"}],\" 传入 \",[\"$r\",\"code\",null,{\"children\":\"drinkers={2}\"}],\" 参数时，它将返回包含 \",[\"$r\",\"code\",null,{\"children\":\"2 cups of water\"}],\" 的 JSX。永远如此。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"而当你传入 \",[\"$r\",\"code\",null,{\"children\":\"drinkers={4}\"}],\" 时，它将返回包含 \",[\"$r\",\"code\",null,{\"children\":\"4 cups of water\"}],\" 的 JSX。永远如此。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"就像数学公式一样。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以把你的组件当作食谱：如果你遵循它们，并且在烹饪过程中不引入新食材，你每次都会得到相同的菜肴。那这道 “菜肴” 就是组件用于 React \",[\"$r\",\"a\",null,{\"href\":\"/learn/render-and-commit\",\"children\":\"渲染\"}],\" 的 JSX。\"]}],\"\\n\"]}],[\"$r\",\"Illustration\",null,{\"src\":\"/images/docs/illustrations/i_puritea-recipe.png\",\"alt\":\"A tea recipe for x people: take x cups of water, add x spoons of tea and 0.5x spoons of spices, and 0.5x cups of milk\"}],[\"$r\",\"MaxWidth\",\"48\",{\"children\":[\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"side-effects-unintended-consequences\",\"children\":\"副作用：（不符合）预期的后果 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 的渲染过程必须自始至终是纯粹的。组件应该只 \",[\"$r\",\"strong\",null,{\"children\":\"返回\"}],\" 它们的 JSX，而不 \",[\"$r\",\"strong\",null,{\"children\":\"改变\"}],\" 在渲染前，就已存在的任何对象或变量 — 这将会使它们变得不纯粹！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"以下是违反这一规则的组件示例：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let guest = 0;\\n\\nfunction Cup() {\\n  // Bad：正在更改预先存在的变量！\\n  guest = guest + 1;\\n  return <h2>Tea cup for guest #{guest}</h2>;\\n}\\n\\nexport default function TeaSet() {\\n  return (\\n    <>\\n      <Cup />\\n      <Cup />\\n      <Cup />\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"56\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"该组件正在读写其外部声明的 \",[\"$r\",\"code\",null,{\"children\":\"guest\"}],\" 变量。这意味着 \",[\"$r\",\"strong\",null,{\"children\":\"多次调用这个组件会产生不同的 JSX\"}],\"！并且，如果 \",[\"$r\",\"strong\",null,{\"children\":\"其他\"}],\" 组件读取 \",[\"$r\",\"code\",null,{\"children\":\"guest\"}],\" ，它们也会产生不同的 JSX，其结果取决于它们何时被渲染！这是无法预测的。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"回到我们的公式 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 2\",[\"$r\",\"MathI\",null,{\"children\":\"x\"}]]}],\" ，现在即使 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"x\"}],\" = 2\"]}],\" ，我们也不能相信 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 4\"]}],\" 。我们的测试可能会失败，我们的用户可能会感到困扰，飞机可能会从天空坠毁——你将看到这会引发多么扑朔迷离的 bugs！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":[\"将 \",[\"$r\",\"code\",null,{\"children\":\"guest\"}],\" 作为 prop 传入\"]}],\" 来修复此组件：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Cup({ guest }) {\\n  return <h2>Tea cup for guest #{guest}</h2>;\\n}\\n\\nexport default function TeaSet() {\\n  return (\\n    <>\\n      <Cup guest={1} />\\n      <Cup guest={2} />\\n      <Cup guest={3} />\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"70\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在你的组件就是纯粹的，因为它返回的 JSX 只依赖于 \",[\"$r\",\"code\",null,{\"children\":\"guest\"}],\" prop。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"一般来说，你不应该期望你的组件以任何特定的顺序被渲染。调用 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 5\",[\"$r\",\"MathI\",null,{\"children\":\"x\"}]]}],\" 和 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 2\",[\"$r\",\"MathI\",null,{\"children\":\"x\"}]]}],\" 的先后顺序并不重要：这两个公式相互独立。同样地，每个组件也应该“独立思考”，而不是在渲染过程中试图与其他组件协调，或者依赖于其他组件。渲染过程就像是一场学校考试：每个组件都应该自己计算 JSX！\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"detecting-impure-calculations-with-strict-mode\",\"children\":\"使用严格模式检测不纯的计算 \"}],[\"$r\",\"p\",null,{\"children\":[\"尽管你可能还没使用过，但在 React 中，你可以在渲染时读取三种输入：\",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":\"props\"}],\"，\",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"state\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。你应该始终将这些输入视为只读。\"]}],[\"$r\",\"p\",null,{\"children\":[\"当你想根据用户输入 \",[\"$r\",\"em\",null,{\"children\":\"更改\"}],\" 某些内容时，你应该 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"设置状态\"}],\"，而不是直接写入变量。当你的组件正在渲染时，你永远不应该改变预先存在的变量或对象。\"]}],[\"$r\",\"p\",null,{\"children\":[\"React 提供了 “严格模式”，在严格模式下开发时，它将会调用每个组件函数两次。\",[\"$r\",\"strong\",null,{\"children\":\"通过重复调用组件函数，严格模式有助于找到违反这些规则的组件\"}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[\"我们注意到，原始示例显示的是 “Guest #2”、“Guest #4” 和 “Guest #6”，而不是 “Guest #1”、“Guest #2” 和 “Guest #3”。原来的函数并不纯粹，因此调用它两次就出现了问题。但对于修复后的纯函数版本，即使调用该函数两次也能得到正确结果。\",[\"$r\",\"strong\",null,{\"children\":\"纯函数仅仅执行计算，因此调用它们两次不会改变任何东西\"}],\" — 就像两次调用 \",[\"$r\",\"code\",null,{\"children\":\"double(2)\"}],\" 并不会改变返回值，两次求解 \",[\"$r\",\"Math\",null,{\"children\":[[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" = 2\",[\"$r\",\"MathI\",null,{\"children\":\"x\"}]]}],\" 不会改变 \",[\"$r\",\"MathI\",null,{\"children\":\"y\"}],\" 的值一样。相同的输入，总是返回相同的输出。\"]}],[\"$r\",\"p\",null,{\"children\":[\"严格模式在生产环境下不生效，因此它不会降低应用程序的速度。如需引入严格模式，你可以用 \",[\"$r\",\"code\",null,{\"children\":\"<React.StrictMode>\"}],\" 包裹根组件。一些框架会默认这样做。\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"local-mutation-your-components-little-secret\",\"children\":\"局部 mutation：组件的小秘密 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"上述示例的问题出在渲染过程中，组件改变了 \",[\"$r\",\"strong\",null,{\"children\":\"预先存在的\"}],\" 变量的值。为了让它听起来更可怕一点，我们将这种现象称为 \",[\"$r\",\"strong\",null,{\"children\":\"突变（mutation）\"}],\" 。纯函数不会改变函数作用域外的变量、或在函数调用前创建的对象——这会使函数变得不纯粹！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"但是，\",[\"$r\",\"strong\",null,{\"children\":[\"你完全可以在渲染时更改你 \",[\"$r\",\"em\",null,{\"children\":\"刚刚\"}],\" 创建的变量和对象\"]}],\"。在本示例中，你创建一个 \",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\" 数组，将其分配给一个 \",[\"$r\",\"code\",null,{\"children\":\"cups\"}],\" 变量，然后 \",[\"$r\",\"code\",null,{\"children\":\"push\"}],\" 一打 cup 进去：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Cup({ guest }) {\\n  return <h2>Tea cup for guest #{guest}</h2>;\\n}\\n\\nexport default function TeaGathering() {\\n  let cups = [];\\n  for (let i = 1; i <= 12; i++) {\\n    cups.push(<Cup key={i} guest={i} />);\\n  }\\n  return cups;\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"90\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"cups\"}],\" 变量或 \",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\" 数组是在 \",[\"$r\",\"code\",null,{\"children\":\"TeaGathering\"}],\" 函数之外创建的，这将是一个很大的问题！因为如果那样的话，当你调用数组的 push 方法时，就会更改 \",[\"$r\",\"strong\",null,{\"children\":\"预先存在的\"}],\" 对象。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"但是，这里不会有影响，因为每次渲染时，你都是在 \",[\"$r\",\"code\",null,{\"children\":\"TeaGathering\"}],\" 函数内部创建的它们。\",[\"$r\",\"code\",null,{\"children\":\"TeaGathering\"}],\" 之外的代码并不会知道发生了什么。这就被称为 \",[\"$r\",\"strong\",null,{\"children\":\"“局部 mutation”\"}],\" — 如同藏在组件里的小秘密。\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"where-you-can-cause-side-effects\",\"children\":[\"哪些地方 \",[\"$r\",\"strong\",null,{\"children\":\"可能\"}],\" 引发副作用 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"函数式编程在很大程度上依赖于纯函数，但 \",[\"$r\",\"strong\",null,{\"children\":\"某些事物\"}],\" 在特定情况下不得不发生改变。这是编程的要义！这些变动包括更新屏幕、启动动画、更改数据等，它们被称为 \",[\"$r\",\"strong\",null,{\"children\":\"副作用\"}],\"。它们是 \",[\"$r\",\"strong\",null,{\"children\":\"“额外”\"}],\" 发生的事情，与渲染过程无关。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 React 中，\",[\"$r\",\"strong\",null,{\"children\":[\"副作用通常属于 \",[\"$r\",\"a\",null,{\"href\":\"/learn/responding-to-events\",\"children\":\"事件处理程序\"}]]}],\"。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。即使事件处理程序是在你的组件 \",[\"$r\",\"strong\",null,{\"children\":\"内部\"}],\" 定义的，它们也不会在渲染期间运行！ \",[\"$r\",\"strong\",null,{\"children\":\"因此事件处理程序无需是纯函数\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\" 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。\",[\"$r\",\"strong\",null,{\"children\":\"然而，这种方法应该是你最后的手段\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果可能，请尝试仅通过渲染过程来表达你的逻辑。你会惊讶于这能带给你多少好处！\"}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"why-does-react-care-about-purity\",\"children\":\"React 为何侧重于纯函数? \"}],[\"$r\",\"p\",null,{\"children\":\"编写纯函数需要遵循一些习惯和规程。但它开启了绝妙的机遇：\"}],[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"你的组件可以在不同的环境下运行 — 例如，在服务器上！由于它们针对相同的输入，总是返回相同的结果，因此一个组件可以满足多个用户请求。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你可以为那些输入未更改的组件来 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":\"跳过渲染\"}],\"，以提高性能。这是安全的做法，因为纯函数总是返回相同的结果，所以可以安全地缓存它们。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果在渲染深层组件树的过程中，某些数据发生了变化，React 可以重新开始渲染，而不会浪费时间完成过时的渲染。纯粹性使得它随时可以安全地停止计算。\"}],\"\\n\"]}],[\"$r\",\"p\",null,{\"children\":\"我们正在构建的每个 React 新特性都利用到了纯函数。从数据获取到动画再到性能，保持组件的纯粹可以充分释放 React 范式的能力。\"}]]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"一个组件必须是纯粹的，就意味着：\",\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"只负责自己的任务。\"}],\" 它不会更改在该函数调用前就已存在的对象或变量。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"输入相同，则输出相同。\"}],\" 给定相同的输入，组件应该总是返回相同的 JSX。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"渲染随时可能发生，因此组件不应依赖于彼此的渲染顺序。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你不应该改变任何用于组件渲染的输入。这包括 props、state 和 context。通过 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"“设置” state\"}],\" 来更新界面，而不要改变预先存在的对象。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"努力在你返回的 JSX 中表达你的组件逻辑。当你需要“改变事物”时，你通常希望在事件处理程序中进行。作为最后的手段，你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"useEffect\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"编写纯函数需要一些练习，但它充分释放了 React 范式的能力。\"}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"fix-a-broken-clock\",\"children\":\"修复坏掉的时钟 \"}],[\"$r\",\"p\",null,{\"children\":[\"该组件尝试在午夜到早上 6 点期间，将 \",[\"$r\",\"code\",null,{\"children\":\"<h1>\"}],\" 的 CSS 类设置为 \",[\"$r\",\"code\",null,{\"children\":\"\\\"night\\\"\"}],\"，而在其他时间都设置为 \",[\"$r\",\"code\",null,{\"children\":\"\\\"day\\\"\"}],\"。但它不起作用。你能修复这个组件吗？\"]}],[\"$r\",\"p\",null,{\"children\":\"你可以临时更改计算机的时区来验证你的解决方案是否有效。当前时间位于午夜至早上六点之间时，时钟应该有相反的颜色！\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"渲染是一种 \",[\"$r\",\"em\",null,{\"children\":\"计算过程\"}],\" ，它不应该试图“做”其他事情。你能用其他方式表达这一思想吗？\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Clock.js active\",\"children\":\"export default function Clock({ time }) {\\n  let hours = time.getHours();\\n  if (hours >= 0 && hours <= 6) {\\n    document.getElementById('time').className = 'night';\\n  } else {\\n    document.getElementById('time').className = 'day';\\n  }\\n  return (\\n    <h1 id=\\\"time\\\">\\n      {time.toLocaleTimeString()}\\n    </h1>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import { useState, useEffect } from 'react';\\nimport Clock from './Clock.js';\\n\\nfunction useTime() {\\n  const [time, setTime] = useState(() => new Date());\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      setTime(new Date());\\n    }, 1000);\\n    return () => clearInterval(id);\\n  }, []);\\n  return time;\\n}\\n\\nexport default function App() {\\n  const time = useTime();\\n  return (\\n    <Clock time={time} />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body > * {\\n  width: 100%;\\n  height: 100%;\\n}\\n.day {\\n  background: #fff;\\n  color: #222;\\n}\\n.night {\\n  background: #222;\\n  color: #fff;\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"你可以计算 \",[\"$r\",\"code\",null,{\"children\":\"className\"}],\"，并将其包含在渲染的输出中，以此实现对组件的修复：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Clock.js active\",\"children\":\"export default function Clock({ time }) {\\n  let hours = time.getHours();\\n  let className;\\n  if (hours >= 0 && hours <= 6) {\\n    className = 'night';\\n  } else {\\n    className = 'day';\\n  }\\n  return (\\n    <h1 className={className}>\\n      {time.toLocaleTimeString()}\\n    </h1>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import { useState, useEffect } from 'react';\\nimport Clock from './Clock.js';\\n\\nfunction useTime() {\\n  const [time, setTime] = useState(() => new Date());\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      setTime(new Date());\\n    }, 1000);\\n    return () => clearInterval(id);\\n  }, []);\\n  return time;\\n}\\n\\nexport default function App() {\\n  const time = useTime();\\n  return (\\n    <Clock time={time} />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body > * {\\n  width: 100%;\\n  height: 100%;\\n}\\n.day {\\n  background: #fff;\\n  color: #222;\\n}\\n.night {\\n  background: #222;\\n  color: #fff;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":\"在这个例子中，副作用（修改 DOM）完全没有必要。你只需要返回 JSX。\"}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-broken-profile\",\"children\":\"修复损坏的资料 \"}],[\"$r\",\"p\",null,{\"children\":[\"两个 \",[\"$r\",\"code\",null,{\"children\":\"Profile\"}],\" 组件使用不同的数据并排呈现。在第一个资料中点击 “Collapse” 折叠，然后点击 “Expand” 展开它。你会看到两个资料现在显示的是同一个人。这是一个 bug。\"]}],[\"$r\",\"p\",null,{\"children\":\"找出产生 bug 的原因，并修复它。\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"问题代码出现在 \",[\"$r\",\"code\",null,{\"children\":\"Profile.js\"}],\" 中。一定要从上到下读完所有内容！\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Profile.js\",\"children\":\"import Panel from './Panel.js';\\nimport { getImageUrl } from './utils.js';\\n\\nlet currentPerson;\\n\\nexport default function Profile({ person }) {\\n  currentPerson = person;\\n  return (\\n    <Panel>\\n      <Header />\\n      <Avatar />\\n    </Panel>\\n  )\\n}\\n\\nfunction Header() {\\n  return <h1>{currentPerson.name}</h1>;\\n}\\n\\nfunction Avatar() {\\n  return (\\n    <img\\n      className=\\\"avatar\\\"\\n      src={getImageUrl(currentPerson)}\\n      alt={currentPerson.name}\\n      width={50}\\n      height={50}\\n    />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Panel.js hidden\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Panel({ children }) {\\n  const [open, setOpen] = useState(true);\\n  return (\\n    <section className=\\\"panel\\\">\\n      <button onClick={() => setOpen(!open)}>\\n        {open ? 'Collapse' : 'Expand'}\\n      </button>\\n      {open && children}\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import Profile from './Profile.js';\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <Profile person={{\\n        imageId: 'lrWQx8l',\\n        name: 'Subrahmanyan Chandrasekhar',\\n      }} />\\n      <Profile person={{\\n        imageId: 'MK3eW3A',\\n        name: 'Creola Katherine Johnson',\\n      }} />\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/utils.js hidden\",\"children\":\"export function getImageUrl(person, size = 's') {\\n  return (\\n    'https://i.imgur.com/' +\\n    person.imageId +\\n    size +\\n    '.jpg'\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".avatar { margin: 5px; border-radius: 50%; }\\n.panel {\\n  border: 1px solid #aaa;\\n  border-radius: 6px;\\n  margin-top: 20px;\\n  padding: 10px;\\n  width: 200px;\\n}\\nh1 { margin: 5px; font-size: 18px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"问题在于 \",[\"$r\",\"code\",null,{\"children\":\"Profile\"}],\" 组件写入了一个预先存在的 \",[\"$r\",\"code\",null,{\"children\":\"currentPerson\"}],\" 变量，而 \",[\"$r\",\"code\",null,{\"children\":\"Header\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"Avatar\"}],\" 组件读取了这个变量。这使得 \",[\"$r\",\"strong\",null,{\"children\":\"三个组件都\"}],\" 变得不纯粹且难以预测。\"]}],[\"$r\",\"p\",null,{\"children\":[\"要修复这个 bug，需要删除 \",[\"$r\",\"code\",null,{\"children\":\"currentPerson\"}],\" 变量。同时，通过 props 将所有信息从 \",[\"$r\",\"code\",null,{\"children\":\"Profile\"}],\" 传递到 \",[\"$r\",\"code\",null,{\"children\":\"Header\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"Avatar\"}],\" 中。你需要向两个组件各添加一个 \",[\"$r\",\"code\",null,{\"children\":\"person\"}],\" prop，并将其一直向下传递。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Profile.js active\",\"children\":\"import Panel from './Panel.js';\\nimport { getImageUrl } from './utils.js';\\n\\nexport default function Profile({ person }) {\\n  return (\\n    <Panel>\\n      <Header person={person} />\\n      <Avatar person={person} />\\n    </Panel>\\n  )\\n}\\n\\nfunction Header({ person }) {\\n  return <h1>{person.name}</h1>;\\n}\\n\\nfunction Avatar({ person }) {\\n  return (\\n    <img\\n      className=\\\"avatar\\\"\\n      src={getImageUrl(person)}\\n      alt={person.name}\\n      width={50}\\n      height={50}\\n    />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Panel.js hidden\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Panel({ children }) {\\n  const [open, setOpen] = useState(true);\\n  return (\\n    <section className=\\\"panel\\\">\\n      <button onClick={() => setOpen(!open)}>\\n        {open ? 'Collapse' : 'Expand'}\\n      </button>\\n      {open && children}\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import Profile from './Profile.js';\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <Profile person={{\\n        imageId: 'lrWQx8l',\\n        name: 'Subrahmanyan Chandrasekhar',\\n      }} />\\n      <Profile person={{\\n        imageId: 'MK3eW3A',\\n        name: 'Creola Katherine Johnson',\\n      }} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/utils.js hidden\",\"children\":\"export function getImageUrl(person, size = 's') {\\n  return (\\n    'https://i.imgur.com/' +\\n    person.imageId +\\n    size +\\n    '.jpg'\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".avatar { margin: 5px; border-radius: 50%; }\\n.panel {\\n  border: 1px solid #aaa;\\n  border-radius: 6px;\\n  margin-top: 20px;\\n  padding: 10px;\\n  width: 200px;\\n}\\nh1 { margin: 5px; font-size: 18px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":\"请记住，React 无法保证组件函数以任何特定的顺序执行，因此你无法通过设置变量在它们之间进行通信。所有的交流都必须通过 props 进行。\"}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-broken-story-tray\",\"children\":\"修复损坏的故事集 \"}],[\"$r\",\"p\",null,{\"children\":[\"你所在公司的 CEO 要求你在在线时钟 app 中添加 “故事”，你不能拒绝。你编写了一个 \",[\"$r\",\"code\",null,{\"children\":\"StoryTray\"}],\" 组件，它接受一个 \",[\"$r\",\"code\",null,{\"children\":\"stories\"}],\" 列表，后跟一个 “Create Story” 占位符。\"]}],[\"$r\",\"p\",null,{\"children\":[\"你在作为 props 的 \",[\"$r\",\"code\",null,{\"children\":\"stories\"}],\" 数组末尾 push 了一个假故事来实现 “Create Story” 占位符。但出于某种原因，“Create Story” 出现了不止一次。请修复这个问题。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/StoryTray.js active\",\"children\":\"export default function StoryTray({ stories }) {\\n  stories.push({\\n    id: 'create',\\n    label: 'Create Story'\\n  });\\n\\n  return (\\n    <ul>\\n      {stories.map(story => (\\n        <li key={story.id}>\\n          {story.label}\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import { useState, useEffect } from 'react';\\nimport StoryTray from './StoryTray.js';\\n\\nlet initialStories = [\\n  {id: 0, label: \\\"Ankit's Story\\\" },\\n  {id: 1, label: \\\"Taylor's Story\\\" },\\n];\\n\\nexport default function App() {\\n  let [stories, setStories] = useState([...initialStories])\\n  let time = useTime();\\n\\n  // HACK: Prevent the memory from growing forever while you read docs.\\n  // We're breaking our own rules here.\\n  if (stories.length > 100) {\\n    stories.length = 100;\\n  }\\n\\n  return (\\n    <div\\n      style={{\\n        width: '100%',\\n        height: '100%',\\n        textAlign: 'center',\\n      }}\\n    >\\n      <h2>It is {time.toLocaleTimeString()} now.</h2>\\n      <StoryTray stories={stories} />\\n    </div>\\n  );\\n}\\n\\nfunction useTime() {\\n  const [time, setTime] = useState(() => new Date());\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      setTime(new Date());\\n    }, 1000);\\n    return () => clearInterval(id);\\n  }, []);\\n  return time;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul {\\n  margin: 0;\\n  list-style-type: none;\\n}\\n\\nli {\\n  border: 1px solid #aaa;\\n  border-radius: 6px;\\n  float: left;\\n  margin: 5px;\\n  margin-bottom: 20px;\\n  padding: 5px;\\n  width: 70px;\\n  height: 100px;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"sandbox.config.json hidden\",\"children\":\"{\\n  \\\"hardReloadOnChange\\\": true\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"请注意，每当时钟更新时，“Create Story” 都会被添加 \",[\"$r\",\"strong\",null,{\"children\":\"两次\"}],\"。这暗示我们在渲染过程中发生了 mutation — 严格模式调用两次组件，可以使这些问题更加明显。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"StoryTray\"}],\" 的功能不纯粹。通过在接收到的 \",[\"$r\",\"code\",null,{\"children\":\"stories\"}],\" 数组（一个 prop！）上调用 \",[\"$r\",\"code\",null,{\"children\":\"push\"}],\" 方法，它正改变着一个在 \",[\"$r\",\"code\",null,{\"children\":\"StoryTray\"}],\" 渲染 \",[\"$r\",\"strong\",null,{\"children\":\"之前\"}],\" 创建的对象。这使得它有问题并且难以预测。\"]}],[\"$r\",\"p\",null,{\"children\":\"最简单的解决方案是完全不碰数组，单独渲染 “Create Story”：\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/StoryTray.js active\",\"children\":\"export default function StoryTray({ stories }) {\\n  return (\\n    <ul>\\n      {stories.map(story => (\\n        <li key={story.id}>\\n          {story.label}\\n        </li>\\n      ))}\\n      <li>Create Story</li>\\n    </ul>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import { useState, useEffect } from 'react';\\nimport StoryTray from './StoryTray.js';\\n\\nlet initialStories = [\\n  {id: 0, label: \\\"Ankit's Story\\\" },\\n  {id: 1, label: \\\"Taylor's Story\\\" },\\n];\\n\\nexport default function App() {\\n  let [stories, setStories] = useState([...initialStories])\\n  let time = useTime();\\n\\n  // HACK: Prevent the memory from growing forever while you read docs.\\n  // We're breaking our own rules here.\\n  if (stories.length > 100) {\\n    stories.length = 100;\\n  }\\n\\n  return (\\n    <div\\n      style={{\\n        width: '100%',\\n        height: '100%',\\n        textAlign: 'center',\\n      }}\\n    >\\n      <h2>It is {time.toLocaleTimeString()} now.</h2>\\n      <StoryTray stories={stories} />\\n    </div>\\n  );\\n}\\n\\nfunction useTime() {\\n  const [time, setTime] = useState(() => new Date());\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      setTime(new Date());\\n    }, 1000);\\n    return () => clearInterval(id);\\n  }, []);\\n  return time;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul {\\n  margin: 0;\\n  list-style-type: none;\\n}\\n\\nli {\\n  border: 1px solid #aaa;\\n  border-radius: 6px;\\n  float: left;\\n  margin: 5px;\\n  margin-bottom: 20px;\\n  padding: 5px;\\n  width: 70px;\\n  height: 100px;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"或者，你可以在 push 之前创建一个 \",[\"$r\",\"strong\",null,{\"children\":\"新\"}],\" 数组（通过复制现有数组）：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/StoryTray.js active\",\"children\":\"export default function StoryTray({ stories }) {\\n  // 复制数组！\\n  let storiesToDisplay = stories.slice();\\n\\n  // 不影响原始数组：\\n  storiesToDisplay.push({\\n    id: 'create',\\n    label: 'Create Story'\\n  });\\n\\n  return (\\n    <ul>\\n      {storiesToDisplay.map(story => (\\n        <li key={story.id}>\\n          {story.label}\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import { useState, useEffect } from 'react';\\nimport StoryTray from './StoryTray.js';\\n\\nlet initialStories = [\\n  {id: 0, label: \\\"Ankit's Story\\\" },\\n  {id: 1, label: \\\"Taylor's Story\\\" },\\n];\\n\\nexport default function App() {\\n  let [stories, setStories] = useState([...initialStories])\\n  let time = useTime();\\n\\n  // HACK: Prevent the memory from growing forever while you read docs.\\n  // We're breaking our own rules here.\\n  if (stories.length > 100) {\\n    stories.length = 100;\\n  }\\n\\n  return (\\n    <div\\n      style={{\\n        width: '100%',\\n        height: '100%',\\n        textAlign: 'center',\\n      }}\\n    >\\n      <h2>It is {time.toLocaleTimeString()} now.</h2>\\n      <StoryTray stories={stories} />\\n    </div>\\n  );\\n}\\n\\nfunction useTime() {\\n  const [time, setTime] = useState(() => new Date());\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      setTime(new Date());\\n    }, 1000);\\n    return () => clearInterval(id);\\n  }, []);\\n  return time;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul {\\n  margin: 0;\\n  list-style-type: none;\\n}\\n\\nli {\\n  border: 1px solid #aaa;\\n  border-radius: 6px;\\n  float: left;\\n  margin: 5px;\\n  margin-bottom: 20px;\\n  padding: 5px;\\n  width: 70px;\\n  height: 100px;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":\"这使你的 mutation 保持在局部，并使你的渲染函数保持纯粹。但你仍然需要小心：例如，当你想要更改数组的任意项时，必须先对其进行拷贝。\"}],[\"$r\",\"p\",null,{\"children\":[\"记住数组上的哪些操作会修改原始数组、哪些不会，这非常有帮助。例如，\",[\"$r\",\"code\",null,{\"children\":\"push\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"pop\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"reverse\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"sort\"}],\" 会改变原始数组，但 \",[\"$r\",\"code\",null,{\"children\":\"slice\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"filter\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\" 则会创建一个新数组。\"]}]]}]]}]]","meta":{"title":"保持组件纯粹","translators":["7ooz","Hyuain","QC-L"]}},"__N_SSG":true}