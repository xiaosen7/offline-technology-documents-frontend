{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#react-batches-state-updates\",\"depth\":2,\"text\":\"React 会对 state 更新进行批处理 \"},{\"url\":\"#updating-the-same-state-multiple-times-before-the-next-render\",\"depth\":2,\"text\":\"在下次渲染前多次更新同一个 state \"},{\"url\":\"#what-happens-if-you-update-state-after-replacing-it\",\"depth\":3,\"text\":\"如果你在替换 state 后更新 state 会发生什么 \"},{\"url\":\"#what-happens-if-you-replace-state-after-updating-it\",\"depth\":3,\"text\":\"如果你在更新 state 后替换 state 会发生什么 \"},{\"url\":\"#naming-conventions\",\"depth\":3,\"text\":\"命名惯例 \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"8\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"设置组件 state 会把一次重新渲染加入队列。但有时你可能会希望在下次渲染加入队列之前对 state 的值执行多次操作。为此，了解 React 如何批量更新 state 会很有帮助。\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"什么是“批处理”以及 React 如何使用它来处理多个 state 更新\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何连续多次对同一 state 变量进行更新\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"react-batches-state-updates\",\"children\":\"React 会对 state 更新进行批处理 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在下面的示例中，你可能会认为点击 “+3” 按钮会使计数器递增三次，因为它调用了 \",[\"$r\",\"code\",null,{\"children\":\"setNumber(number + 1)\"}],\" 三次：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [number, setNumber] = useState(0);\\n\\n  return (\\n    <>\\n      <h1>{number}</h1>\\n      <button onClick={() => {\\n        setNumber(number + 1);\\n        setNumber(number + 1);\\n        setNumber(number + 1);\\n      }}>+3</button>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: inline-block; margin: 10px; font-size: 20px; }\\nh1 { display: inline-block; margin: 10px; width: 30px; text-align: center; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"18\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"但是，你可能还记得上一节中的内容，\",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time\",\"children\":\"每一次渲染的 state 值都是固定的\"}],\"，因此无论你调用多少次 \",[\"$r\",\"code\",null,{\"children\":\"setNumber(1)\"}],\"，在第一次渲染的事件处理函数内部的 \",[\"$r\",\"code\",null,{\"children\":\"number\"}],\" 值总是 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" ：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setNumber(0 + 1);\\nsetNumber(0 + 1);\\nsetNumber(0 + 1);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"但是这里还有另外一个影响因素需要讨论。\",[\"$r\",\"strong\",null,{\"children\":\"React 会等到事件处理函数中的\"}],\" 所有 \",[\"$r\",\"strong\",null,{\"children\":\"代码都运行完毕再处理你的 state 更新。\"}],\" 这就是为什么重新渲染只会发生在所有这些 \",[\"$r\",\"code\",null,{\"children\":\"setNumber()\"}],\" 调用 \",[\"$r\",\"strong\",null,{\"children\":\"之后\"}],\" 的原因。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这可能会让你想起餐厅里帮你点菜的服务员。服务员不会在你说第一道菜的时候就跑到厨房！相反，他们会让你把菜点完，让你修改菜品，甚至会帮桌上的其他人点菜。\"}],\"\\n\"]}],[\"$r\",\"Illustration\",null,{\"src\":\"/images/docs/illustrations/i_react-batching.png\",\"alt\":\"在餐厅里，优雅的光标跟扮演服务员角色的 React 多次点菜。在她多次调用 setState() 之后，服务员将她所点的最后一个作为她的最终订单记录下来。\"}],[\"$r\",\"MaxWidth\",\"30\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这让你可以更新多个 state 变量——甚至来自多个组件的 state 变量——而不会触发太多的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/render-and-commit#re-renders-when-state-updates\",\"children\":\"重新渲染\"}],\"。但这也意味着只有在你的事件处理函数及其中任何代码执行完成 \",[\"$r\",\"strong\",null,{\"children\":\"之后\"}],\"，UI 才会更新。这种特性也就是 \",[\"$r\",\"strong\",null,{\"children\":\"批处理\"}],\"，它会使你的 React 应用运行得更快。它还会帮你避免处理只​​更新了一部分 state 变量的令人困惑的“半成品”渲染。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"React 不会跨 \",[\"$r\",\"em\",null,{\"children\":\"多个\"}],\" 需要刻意触发的事件（如点击）进行批处理\"]}],\"——每次点击都是单独处理的。请放心，React 只会在一般来说安全的情况下才进行批处理。这可以确保，例如，如果第一次点击按钮会禁用表单，那么第二次点击就不会再次提交它。\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"updating-the-same-state-multiple-times-before-the-next-render\",\"children\":\"在下次渲染前多次更新同一个 state \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这是一个不常见的用例，但是如果你想在下次渲染之前多次更新同一个 state，你可以像 \",[\"$r\",\"code\",null,{\"children\":\"setNumber(n => n + 1)\"}],\" 这样传入一个根据队列中的前一个 state 计算下一个 state 的 \",[\"$r\",\"strong\",null,{\"children\":\"函数\"}],\"，而不是像 \",[\"$r\",\"code\",null,{\"children\":\"setNumber(number + 1)\"}],\" 这样传入 \",[\"$r\",\"strong\",null,{\"children\":\"下一个 state 值\"}],\"。这是一种告诉 React “用 state 值做某事”而不是仅仅替换它的方法。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在尝试递增计数器：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [number, setNumber] = useState(0);\\n\\n  return (\\n    <>\\n      <h1>{number}</h1>\\n      <button onClick={() => {\\n        setNumber(n => n + 1);\\n        setNumber(n => n + 1);\\n        setNumber(n => n + 1);\\n      }}>+3</button>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: inline-block; margin: 10px; font-size: 20px; }\\nh1 { display: inline-block; margin: 10px; width: 30px; text-align: center; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"56\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这里，\",[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}],\" 被称为 \",[\"$r\",\"strong\",null,{\"children\":\"更新函数\"}],\"。当你将它传递给一个 state 设置函数时：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"React 会将此函数加入队列，以便在事件处理函数中的所有其他代码运行后进行处理。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"在下一次渲染期间，React 会遍历队列并给你更新之后的最终 state。\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setNumber(n => n + 1);\\nsetNumber(n => n + 1);\\nsetNumber(n => n + 1);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"下面是 React 在执行事件处理函数时处理这几行代码的过程：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setNumber(n => n + 1)\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}],\" 是一个函数。React 将它加入队列。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setNumber(n => n + 1)\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}],\" 是一个函数。React 将它加入队列。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setNumber(n => n + 1)\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}],\" 是一个函数。React 将它加入队列。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你在下次渲染期间调用 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 时，React 会遍历队列。之前的 \",[\"$r\",\"code\",null,{\"children\":\"number\"}],\" state 的值是 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\"，所以这就是 React 作为参数 \",[\"$r\",\"code\",null,{\"children\":\"n\"}],\" 传递给第一个更新函数的值。然后 React 会获取你上一个更新函数的返回值，并将其作为 \",[\"$r\",\"code\",null,{\"children\":\"n\"}],\" 传递给下一个更新函数，以此类推：\"]}],\"\\n\",[\"$r\",\"table\",null,{\"children\":[[\"$r\",\"thead\",null,{\"children\":[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"th\",null,{\"children\":\"更新队列\"}],[\"$r\",\"th\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"n\"}]}],[\"$r\",\"th\",null,{\"children\":\"返回值\"}]]}]}],[\"$r\",\"tbody\",null,{\"children\":[[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"0\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"0 + 1 = 1\"}]}]]}],[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"1\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"1 + 1 = 2\"}]}]]}],[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"2\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"2 + 1 = 3\"}]}]]}]]}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 会保存 \",[\"$r\",\"code\",null,{\"children\":\"3\"}],\" 为最终结果并从 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 中返回。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这就是为什么在上面的示例中点击“+3”正确地将值增加“+3”。\"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"what-happens-if-you-update-state-after-replacing-it\",\"children\":\"如果你在替换 state 后更新 state 会发生什么 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个事件处理函数会怎么样？你认为 \",[\"$r\",\"code\",null,{\"children\":\"number\"}],\" 在下一次渲染中的值是什么？\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<button onClick={() => {\\n  setNumber(number + 5);\\n  setNumber(n => n + 1);\\n}}>\\n\"}]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [number, setNumber] = useState(0);\\n\\n  return (\\n    <>\\n      <h1>{number}</h1>\\n      <button onClick={() => {\\n        setNumber(number + 5);\\n        setNumber(n => n + 1);\\n      }}>增加数字</button>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: inline-block; margin: 10px; font-size: 20px; }\\nh1 { display: inline-block; margin: 10px; width: 30px; text-align: center; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"76\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这是事件处理函数告诉 React 要做的事情：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setNumber(number + 5)\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"number\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\"，所以 \",[\"$r\",\"code\",null,{\"children\":\"setNumber(0 + 5)\"}],\"。React 将 \",[\"$r\",\"em\",null,{\"children\":[\"“替换为 \",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"”\"]}],\" 添加到其队列中。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setNumber(n => n + 1)\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}],\" 是一个更新函数。 React 将 \",[\"$r\",\"strong\",null,{\"children\":\"该函数\"}],\" 添加到其队列中。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在下一次渲染期间，React 会遍历 state 队列：\"}],\"\\n\",[\"$r\",\"table\",null,{\"children\":[[\"$r\",\"thead\",null,{\"children\":[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"th\",null,{\"children\":\"更新队列\"}],[\"$r\",\"th\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"n\"}]}],[\"$r\",\"th\",null,{\"children\":\"返回值\"}]]}]}],[\"$r\",\"tbody\",null,{\"children\":[[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"“替换为 \",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"”\"]}],[\"$r\",\"td\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"0\"}],\"（未使用）\"]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"5\"}]}]]}],[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"5\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"5 + 1 = 6\"}]}]]}]]}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 会保存 \",[\"$r\",\"code\",null,{\"children\":\"6\"}],\" 为最终结果并从 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 中返回。\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"你可能已经注意到，\",[\"$r\",\"code\",null,{\"children\":\"setState(x)\"}],\" 实际上会像 \",[\"$r\",\"code\",null,{\"children\":\"setState(n => x)\"}],\" 一样运行，只是没有使用 \",[\"$r\",\"code\",null,{\"children\":\"n\"}],\"！\"]}]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"what-happens-if-you-replace-state-after-updating-it\",\"children\":\"如果你在更新 state 后替换 state 会发生什么 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"让我们再看一个例子。你认为 \",[\"$r\",\"code\",null,{\"children\":\"number\"}],\" 在下一次渲染中的值是什么？\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<button onClick={() => {\\n  setNumber(number + 5);\\n  setNumber(n => n + 1);\\n  setNumber(42);\\n}}>\\n\"}]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [number, setNumber] = useState(0);\\n\\n  return (\\n    <>\\n      <h1>{number}</h1>\\n      <button onClick={() => {\\n        setNumber(number + 5);\\n        setNumber(n => n + 1);\\n        setNumber(42);\\n      }}>增加数字</button>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: inline-block; margin: 10px; font-size: 20px; }\\nh1 { display: inline-block; margin: 10px; width: 30px; text-align: center; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"104\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"以下是 React 在执行事件处理函数时处理这几行代码的过程：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setNumber(number + 5)\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"number\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\"，所以 \",[\"$r\",\"code\",null,{\"children\":\"setNumber(0 + 5)\"}],\"。React 将 \",[\"$r\",\"em\",null,{\"children\":[\"“替换为 \",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"”\"]}],\" 添加到其队列中。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setNumber(n => n + 1)\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}],\" 是一个更新函数。React 将该函数添加到其队列中。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setNumber(42)\"}],\"：React 将 \",[\"$r\",\"em\",null,{\"children\":[\"“替换为 \",[\"$r\",\"code\",null,{\"children\":\"42\"}],\"”\"]}],\" 添加到其队列中。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在下一次渲染期间，React 会遍历 state 队列：\"}],\"\\n\",[\"$r\",\"table\",null,{\"children\":[[\"$r\",\"thead\",null,{\"children\":[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"th\",null,{\"children\":\"更新队列\"}],[\"$r\",\"th\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"n\"}]}],[\"$r\",\"th\",null,{\"children\":\"返回值\"}]]}]}],[\"$r\",\"tbody\",null,{\"children\":[[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"“替换为 \",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"”\"]}],[\"$r\",\"td\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"0\"}],\"（未使用）\"]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"5\"}]}]]}],[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"5\"}]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"5 + 1 = 6\"}]}]]}],[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"“替换为 \",[\"$r\",\"code\",null,{\"children\":\"42\"}],\"”\"]}],[\"$r\",\"td\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"6\"}],\"（未使用）\"]}],[\"$r\",\"td\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"42\"}]}]]}]]}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然后 React 会保存 \",[\"$r\",\"code\",null,{\"children\":\"42\"}],\" 为最终结果并从 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 中返回。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"总而言之，以下是你可以考虑传递给 \",[\"$r\",\"code\",null,{\"children\":\"setNumber\"}],\" state 设置函数的内容：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"一个更新函数\"}],\"（例如：\",[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}],\"）会被添加到队列中。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"任何其他的值\"}],\"（例如：数字 \",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"）会导致“替换为 \",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"”被添加到队列中，已经在队列中的内容会被忽略。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"事件处理函数执行完成后，React 将触发重新渲染。在重新渲染期间，React 将处理队列。更新函数会在渲染期间执行，因此 \",[\"$r\",\"strong\",null,{\"children\":[\"更新函数必须是 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"纯函数\"}]]}],\" 并且只 \",[\"$r\",\"strong\",null,{\"children\":\"返回\"}],\" 结果。不要尝试从它们内部设置 state 或者执行其他副作用。在严格模式下，React 会执行每个更新函数两次（但是丢弃第二个结果）以便帮助你发现错误。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"naming-conventions\",\"children\":\"命名惯例 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通常可以通过相应 state 变量的第一个字母来命名更新函数的参数：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setEnabled(e => !e);\\nsetLastName(ln => ln.reverse());\\nsetFriendCount(fc => fc * 2);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你喜欢更冗长的代码，另一个常见的惯例是重复使用完整的 state 变量名称，如 \",[\"$r\",\"code\",null,{\"children\":\"setEnabled(enabled => !enabled)\"}],\"，或使用前缀，如 \",[\"$r\",\"code\",null,{\"children\":\"setEnabled(prevEnabled => !prevEnabled)\"}],\"。\"]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"设置 state 不会更改现有渲染中的变量，但会请求一次新的渲染。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"React 会在事件处理函数执行完成之后处理 state 更新。这被称为批处理。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"要在一个事件中多次更新某些 state，你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"setNumber(n => n + 1)\"}],\" 更新函数。\"]}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"fix-a-request-counter\",\"children\":\"修复请求计数器 \"}],[\"$r\",\"p\",null,{\"children\":\"你正在开发一个艺术市场应用，该应用允许一个用户为一个艺术品同时提交多个订单。每次用户按下“购买”按钮，“等待”计数器应该增加一。三秒后，“等待”计数器应该减少，“完成”计数器应该增加。\"}],[\"$r\",\"p\",null,{\"children\":[\"但是，“等待”计数器的行为并不符合预期。当你按下“购买”按钮时，它会减少到 \",[\"$r\",\"code\",null,{\"children\":\"-1\"}],\"（这本应该是不可能的）。如果你快速点击两次，两个计数器似乎都会出现无法预测的行为。\"]}],[\"$r\",\"p\",null,{\"children\":\"为什么会发生这种情况？修复两个计数器。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function RequestTracker() {\\n  const [pending, setPending] = useState(0);\\n  const [completed, setCompleted] = useState(0);\\n\\n  async function handleClick() {\\n    setPending(pending + 1);\\n    await delay(3000);\\n    setPending(pending - 1);\\n    setCompleted(completed + 1);\\n  }\\n\\n  return (\\n    <>\\n      <h3>\\n        等待：{pending}\\n      </h3>\\n      <h3>\\n        完成：{completed}\\n      </h3>\\n      <button onClick={handleClick}>\\n        购买\\n      </button>\\n    </>\\n  );\\n}\\n\\nfunction delay(ms) {\\n  return new Promise(resolve => {\\n    setTimeout(resolve, ms);\\n  });\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"在 \",[\"$r\",\"code\",null,{\"children\":\"handleClick\"}],\" 事件处理函数内部，\",[\"$r\",\"code\",null,{\"children\":\"pending\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"completed\"}],\" 的值与他们在点击事件发生时的值相对应。对于第一次渲染，\",[\"$r\",\"code\",null,{\"children\":\"pending\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" ，因此 \",[\"$r\",\"code\",null,{\"children\":\"setPending(pending - 1)\"}],\" 变成了 \",[\"$r\",\"code\",null,{\"children\":\"setPending(-1)\"}],\"，而这是错误的。既然你想要 \",[\"$r\",\"em\",null,{\"children\":\"增加\"}],\" 或 \",[\"$r\",\"em\",null,{\"children\":\"减少\"}],\" 计数器，你可以改为传递更新函数，而不是将计数器设置为在点击期间确定的具体值：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function RequestTracker() {\\n  const [pending, setPending] = useState(0);\\n  const [completed, setCompleted] = useState(0);\\n\\n  async function handleClick() {\\n    setPending(p => p + 1);\\n    await delay(3000);\\n    setPending(p => p - 1);\\n    setCompleted(c => c + 1);\\n  }\\n\\n  return (\\n    <>\\n      <h3>\\n        等待：{pending}\\n      </h3>\\n      <h3>\\n        完成：{completed}\\n      </h3>\\n      <button onClick={handleClick}>\\n        购买\\n      </button>\\n    </>\\n  );\\n}\\n\\nfunction delay(ms) {\\n  return new Promise(resolve => {\\n    setTimeout(resolve, ms);\\n  });\\n}\\n\"}]}]}],[\"$r\",\"p\",null,{\"children\":[\"这可以确保你在增加或减少计数器时是根据其 \",[\"$r\",\"strong\",null,{\"children\":\"最新\"}],\" 的 state 而不是点击时的 state 来进行增减的。\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"implement-the-state-queue-yourself\",\"children\":\"自己实现状态队列 \"}],[\"$r\",\"p\",null,{\"children\":\"在这个挑战中，你将从头开始重新实现 React 的一小部分！这并不像听起来那么难。\"}],[\"$r\",\"p\",null,{\"children\":[\"滚动 sandbox 进行预览。请注意，它显示了 \",[\"$r\",\"strong\",null,{\"children\":\"四个测试用例\"}],\" 。它们与你之前在本页上看到过的示例相对应。你的任务是实现 \",[\"$r\",\"code\",null,{\"children\":\"getFinalState\"}],\" 函数，让它为每种情况返回正确的结果。如果你对它进行了正确的实现的话，那么所有四个测试用例都应该会通过。\"]}],[\"$r\",\"p\",null,{\"children\":[\"你将收到两个参数：\",[\"$r\",\"code\",null,{\"children\":\"baseState\"}],\" 是初始状态（例如：\",[\"$r\",\"code\",null,{\"children\":\"0\"}],\"），\",[\"$r\",\"code\",null,{\"children\":\"queue\"}],\" 是一个既包含数字（例如：\",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"）也包含更新函数（例如：\",[\"$r\",\"code\",null,{\"children\":\"n => n + 1\"}],\"）的数组，这些数字和数组会被按照它们被添加进来的顺序排列。\"]}],[\"$r\",\"p\",null,{\"children\":\"你的任务是返回最终的 state，如同页面上的表格展示的那样！\"}],[\"$r\",\"Hint\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"如果你没有思路，可以从下面的代码结构开始:\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"export function getFinalState(baseState, queue) {\\n  let finalState = baseState;\\n\\n  for (let update of queue) {\\n    if (typeof update === 'function') {\\n      // TODO: 调用更新函数\\n    } else {\\n      // TODO: 替换 state\\n    }\\n  }\\n\\n  return finalState;\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"补全缺失的几行代码！\"}]]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/processQueue.js active\",\"children\":\"export function getFinalState(baseState, queue) {\\n  let finalState = baseState;\\n\\n  // TODO: 对队列做些什么...\\n\\n  return finalState;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { getFinalState } from './processQueue.js';\\n\\nfunction increment(n) {\\n  return n + 1;\\n}\\nincrement.toString = () => 'n => n+1';\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <TestCase\\n        baseState={0}\\n        queue={[1, 1, 1]}\\n        expected={1}\\n      />\\n      <hr />\\n      <TestCase\\n        baseState={0}\\n        queue={[\\n          increment,\\n          increment,\\n          increment\\n        ]}\\n        expected={3}\\n      />\\n      <hr />\\n      <TestCase\\n        baseState={0}\\n        queue={[\\n          5,\\n          increment,\\n        ]}\\n        expected={6}\\n      />\\n      <hr />\\n      <TestCase\\n        baseState={0}\\n        queue={[\\n          5,\\n          increment,\\n          42,\\n        ]}\\n        expected={42}\\n      />\\n    </>\\n  );\\n}\\n\\nfunction TestCase({\\n  baseState,\\n  queue,\\n  expected\\n}) {\\n  const actual = getFinalState(baseState, queue);\\n  return (\\n    <>\\n      <p>初始 state：<b>{baseState}</b></p>\\n      <p>队列：<b>[{queue.join(', ')}]</b></p>\\n      <p>预期结果：<b>{expected}</b></p>\\n      <p style={{\\n        color: actual === expected ?\\n        'green' :\\n        'red'\\n      }}>\\n        你的结果：<b>{actual}</b>\\n        {' '}\\n        ({actual === expected ?\\n          '正确' :\\n          '错误'\\n        })\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"这其实就是这一页中所描述的 React 用来计算最终 state 的算法:\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/processQueue.js active\",\"children\":\"export function getFinalState(baseState, queue) {\\n  let finalState = baseState;\\n\\n  for (let update of queue) {\\n    if (typeof update === 'function') {\\n      // 调用更新函数\\n      finalState = update(finalState);\\n    } else {\\n      // 替换下一个 state\\n      finalState = update;\\n    }\\n  }\\n\\n  return finalState;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { getFinalState } from './processQueue.js';\\n\\nfunction increment(n) {\\n  return n + 1;\\n}\\nincrement.toString = () => 'n => n+1';\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <TestCase\\n        baseState={0}\\n        queue={[1, 1, 1]}\\n        expected={1}\\n      />\\n      <hr />\\n      <TestCase\\n        baseState={0}\\n        queue={[\\n          increment,\\n          increment,\\n          increment\\n        ]}\\n        expected={3}\\n      />\\n      <hr />\\n      <TestCase\\n        baseState={0}\\n        queue={[\\n          5,\\n          increment,\\n        ]}\\n        expected={6}\\n      />\\n      <hr />\\n      <TestCase\\n        baseState={0}\\n        queue={[\\n          5,\\n          increment,\\n          42,\\n        ]}\\n        expected={42}\\n      />\\n    </>\\n  );\\n}\\n\\nfunction TestCase({\\n  baseState,\\n  queue,\\n  expected\\n}) {\\n  const actual = getFinalState(baseState, queue);\\n  return (\\n    <>\\n      <p>初始 state：<b>{baseState}</b></p>\\n      <p>队列：<b>[{queue.join(', ')}]</b></p>\\n      <p>预期结果：<b>{expected}</b></p>\\n      <p style={{\\n        color: actual === expected ?\\n        'green' :\\n        'red'\\n      }}>\\n        你的结果：<b>{actual}</b>\\n        {' '}\\n        ({actual === expected ?\\n          '正确' :\\n          '错误'\\n        })\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":\"现在你知道 React 的这一部分是如何运行的了吧！\"}]]}]]}]]","meta":{"title":"把一系列 state 更新加入队列","translators":["Jiacheng787","Neo42"]}},"__N_SSG":true}