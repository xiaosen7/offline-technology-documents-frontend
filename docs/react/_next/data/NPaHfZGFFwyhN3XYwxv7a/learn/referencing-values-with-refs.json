{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#adding-a-ref-to-your-component\",\"depth\":2,\"text\":\"给你的组件添加 ref \"},{\"url\":\"#example-building-a-stopwatch\",\"depth\":2,\"text\":\"示例：制作秒表 \"},{\"url\":\"#differences-between-refs-and-state\",\"depth\":2,\"text\":\"ref 和 state 的不同之处 \"},{\"url\":\"#when-to-use-refs\",\"depth\":2,\"text\":\"何时使用 ref \"},{\"url\":\"#best-practices-for-refs\",\"depth\":2,\"text\":\"ref 的最佳实践 \"},{\"url\":\"#refs-and-the-dom\",\"depth\":2,\"text\":\"ref 和 DOM \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"18\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"当你希望组件“记住”某些信息，但又不想让这些信息 \",[\"$r\",\"a\",null,{\"href\":\"/learn/render-and-commit\",\"children\":\"触发新的渲染\"}],\" 时，你可以使用 \",[\"$r\",\"strong\",null,{\"children\":\"ref\"}],\" 。\"]}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何向组件添加 ref\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何更新 ref 的值\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"ref 与 state 有何不同\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何安全地使用 ref\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"adding-a-ref-to-your-component\",\"children\":\"给你的组件添加 ref \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以通过从 React 导入 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" Hook 来为你的组件添加一个 ref：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在你的组件内，调用 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" Hook 并传入你想要引用的初始值作为唯一参数。例如，这里的 ref 引用的值是“0”：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const ref = useRef(0);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 返回一个这样的对象:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"{ \\n  current: 0 // 你向 useRef 传入的值\\n}\\n\"}]}],\"\\n\"]}],[\"$r\",\"Illustration\",null,{\"src\":\"/images/docs/illustrations/i_ref.png\",\"alt\":\"An arrow with 'current' written on it stuffed into a pocket with 'ref' written on it.\"}],[\"$r\",\"MaxWidth\",\"24\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以用 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 属性访问该 ref 的当前值。这个值是有意被设置为可变的，意味着你既可以读取它也可以写入它。就像一个 React 追踪不到的、用来存储组件信息的秘密“口袋”。（这就是让它成为 React 单向数据流的“脱围机制”的原因 —— 详见下文！）\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这里，每次点击按钮时会使 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 递增：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Counter() {\\n  let ref = useRef(0);\\n\\n  function handleClick() {\\n    ref.current = ref.current + 1;\\n    alert('你点击了 ' + ref.current + ' 次！');\\n  }\\n\\n  return (\\n    <button onClick={handleClick}>\\n      点击我！\\n    </button>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"38\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这里的 ref 指向一个数字，但是，像 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"state\"}],\" 一样，你可以让它指向任何东西：字符串、对象，甚至是函数。与 state 不同的是，ref 是一个普通的 JavaScript 对象，具有可以被读取和修改的 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，\",[\"$r\",\"strong\",null,{\"children\":\"组件不会在每次递增时重新渲染。\"}],\" 与 state 一样，React 会在每次重新渲染之间保留 ref。但是，设置 state 会重新渲染组件，更改 ref 不会！\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"example-building-a-stopwatch\",\"children\":\"示例：制作秒表 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以在单个组件中把 ref 和 state 结合起来使用。例如，让我们制作一个秒表，用户可以通过按按钮来使其启动或停止。为了显示从用户按下“开始”以来经过的时间长度，你需要追踪按下“开始”按钮的时间和当前时间。\",[\"$r\",\"strong\",null,{\"children\":\"此信息用于渲染，所以你会把它保存在 state 中：\"}]]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [startTime, setStartTime] = useState(null);\\nconst [now, setNow] = useState(null);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当用户按下“开始”时，你将用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/API/setInterval\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"setInterval\"}]}],\" 每 10 毫秒更新一次时间：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Stopwatch() {\\n  const [startTime, setStartTime] = useState(null);\\n  const [now, setNow] = useState(null);\\n\\n  function handleStart() {\\n    // 开始计时。\\n    setStartTime(Date.now());\\n    setNow(Date.now());\\n\\n    setInterval(() => {\\n      // 每 10ms 更新一次当前时间。\\n      setNow(Date.now());\\n    }, 10);\\n  }\\n\\n  let secondsPassed = 0;\\n  if (startTime != null && now != null) {\\n    secondsPassed = (now - startTime) / 1000;\\n  }\\n\\n  return (\\n    <>\\n      <h1>时间过去了： {secondsPassed.toFixed(3)}</h1>\\n      <button onClick={handleStart}>\\n        开始\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"42\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当按下“停止”按钮时，你需要取消现有的 interval，以便让它停止更新 \",[\"$r\",\"code\",null,{\"children\":\"now\"}],\" state 变量。你可以通过调用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/clearInterval\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"clearInterval\"}]}],\" 来完成此操作。但你需要为其提供 interval ID，此 ID 是之前用户按下 Start、调用 \",[\"$r\",\"code\",null,{\"children\":\"setInterval\"}],\" 时返回的。你需要将 interval ID 保留在某处。 \",[\"$r\",\"strong\",null,{\"children\":\"由于 interval ID 不用于渲染，你可以将其保存在 ref 中：\"}]]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function Stopwatch() {\\n  const [startTime, setStartTime] = useState(null);\\n  const [now, setNow] = useState(null);\\n  const intervalRef = useRef(null);\\n\\n  function handleStart() {\\n    setStartTime(Date.now());\\n    setNow(Date.now());\\n\\n    clearInterval(intervalRef.current);\\n    intervalRef.current = setInterval(() => {\\n      setNow(Date.now());\\n    }, 10);\\n  }\\n\\n  function handleStop() {\\n    clearInterval(intervalRef.current);\\n  }\\n\\n  let secondsPassed = 0;\\n  if (startTime != null && now != null) {\\n    secondsPassed = (now - startTime) / 1000;\\n  }\\n\\n  return (\\n    <>\\n      <h1>时间过去了： {secondsPassed.toFixed(3)}</h1>\\n      <button onClick={handleStart}>\\n        开始\\n      </button>\\n      <button onClick={handleStop}>\\n        停止\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"54\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"当一条信息用于渲染时，将它保存在 state 中。当一条信息仅被事件处理器需要，并且更改它不需要重新渲染时，使用 ref 可能会更高效。\"}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"differences-between-refs-and-state\",\"children\":\"ref 和 state 的不同之处 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"也许你觉得 ref 似乎没有 state 那样“严格” —— 例如，你可以改变它们而非总是必须使用 state 设置函数。但在大多数情况下，我们建议你使用 state。ref 是一种“脱围机制”，你并不会经常用到它。 以下是 state 和 ref 的对比：\"}],\"\\n\",[\"$r\",\"table\",null,{\"children\":[[\"$r\",\"thead\",null,{\"children\":[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"th\",null,{\"children\":\"ref\"}],[\"$r\",\"th\",null,{\"children\":\"state\"}]]}]}],[\"$r\",\"tbody\",null,{\"children\":[[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useRef(initialValue)\"}],\"返回 \",[\"$r\",\"code\",null,{\"children\":\"{ current: initialValue }\"}]]}],[\"$r\",\"td\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState(initialValue)\"}],\" 返回 state 变量的当前值和一个 state 设置函数 ( \",[\"$r\",\"code\",null,{\"children\":\"[value, setValue]\"}],\")\"]}]]}],[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":\"更改时不会触发重新渲染\"}],[\"$r\",\"td\",null,{\"children\":\"更改时触发重新渲染。\"}]]}],[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"可变 —— 你可以在渲染过程之外修改和更新 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 的值。\"]}],[\"$r\",\"td\",null,{\"children\":\"“不可变” —— 你必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。\"}]]}],[\"$r\",\"tr\",null,{\"children\":[[\"$r\",\"td\",null,{\"children\":[\"你不应在渲染期间读取（或写入） \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 值。\"]}],[\"$r\",\"td\",null,{\"children\":[\"你可以随时读取 state。但是，每次渲染都有自己不变的 state \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"快照\"}],\"。\"]}]]}]]}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这是一个使用 state 实现的计数器按钮：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [count, setCount] = useState(0);\\n\\n  function handleClick() {\\n    setCount(count + 1);\\n  }\\n\\n  return (\\n    <button onClick={handleClick}>\\n      你点击了 {count} 次\\n    </button>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"60\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"因为 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" 的值将会被显示，所以为其使用 state 是合理的。当使用 setCount() 设置计数器的值时，React 会重新渲染组件，并且屏幕会更新以展示新的计数。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你试图用 ref 来实现它，React 永远不会重新渲染组件，所以你永远不会看到计数变化！看看点击这个按钮如何 \",[\"$r\",\"strong\",null,{\"children\":\"不更新它的文本\"}],\"：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Counter() {\\n  let countRef = useRef(0);\\n\\n  function handleClick() {\\n    // 这样并未重新渲染组件！\\n    countRef.current = countRef.current + 1;\\n  }\\n\\n  return (\\n    <button onClick={handleClick}>\\n      你点击了 {countRef.current} 次\\n    </button>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"94\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这就是为什么在渲染期间读取 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 会导致代码不可靠的原因。如果需要，请改用 state。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"how-does-use-ref-work-inside\",\"children\":\"useRef 内部是如何运行的？ \"}],[\"$r\",\"p\",null,{\"children\":[\"尽管 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 都是由 React 提供的，原则上 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 可以在 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" \",[\"$r\",\"strong\",null,{\"children\":\"的基础上\"}],\" 实现。 你可以想象在 React 内部，\",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 是这样实现的：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"// React 内部\\nfunction useRef(initialValue) {\\n  const [ref, unused] = useState({ current: initialValue });\\n  return ref;\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"第一次渲染期间，\",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 返回 \",[\"$r\",\"code\",null,{\"children\":\"{ current: initialValue }\"}],\"。 该对象由 React 存储，因此在下一次渲染期间将返回相同的对象。 请注意，在这个示例中，state 设置函数没有被用到。它是不必要的，因为 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 总是需要返回相同的对象！\"]}],[\"$r\",\"p\",null,{\"children\":[\"React 提供了一个内置版本的 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\"，因为它在实践中很常见。 但是你可以将其视为没有设置函数的常规 state 变量。 如果你熟悉面向对象编程，ref 可能会让你想起实例字段 —— 但是你写的不是 \",[\"$r\",\"code\",null,{\"children\":\"this.something\"}],\"，而是 \",[\"$r\",\"code\",null,{\"children\":\"somethingRef.current\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"when-to-use-refs\",\"children\":\"何时使用 ref \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通常，当你的组件需要“跳出” React 并与外部 API 通信时，你会用到 ref —— 通常是不会影响组件外观的浏览器 API。以下是这些罕见情况中的几个：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"存储 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/API/setTimeout\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"timeout ID\"}]]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"存储和操作 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/API/Element\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DOM 元素\"}],\"，我们将在 \",[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs\",\"children\":\"下一页\"}],\" 中介绍\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"存储不需要被用来计算 JSX 的其他对象。\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果你的组件需要存储一些值，但不影响渲染逻辑，请选择 ref。\"}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"best-practices-for-refs\",\"children\":\"ref 的最佳实践 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"遵循这些原则将使你的组件更具可预测性：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"将 ref 视为脱围机制\"}],\"。当你使用外部系统或浏览器 API 时，ref 很有用。如果你很大一部分应用程序逻辑和数据流都依赖于 ref，你可能需要重新考虑你的方法。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"不要在渲染过程中读取或写入 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\"。\"]}],\" 如果渲染过程中需要某些信息，请使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"state\"}],\" 代替。由于 React 不知道 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 何时发生变化，即使在渲染时读取它也会使组件的行为难以预测。（唯一的例外是像 \",[\"$r\",\"code\",null,{\"children\":\"if (!ref.current) ref.current = new Thing()\"}],\" 这样的代码，它只在第一次渲染期间设置一次 ref。）\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React state 的限制不适用于 ref。例如，state 就像 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"每次渲染的快照\"}],\"，并且 \",[\"$r\",\"a\",null,{\"href\":\"/learn/queueing-a-series-of-state-updates\",\"children\":\"不会同步更新\"}],\"。但是当你改变 ref 的 current 值时，它会立即改变：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"ref.current = 5;\\nconsole.log(ref.current); // 5\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这是因为 \",[\"$r\",\"strong\",null,{\"children\":\"ref 本身是一个普通的 JavaScript 对象，\"}],\" 所以它的行为就像对象那样。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你使用 ref 时，也无需担心 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-objects-in-state\",\"children\":\"避免变更\"}],\"。只要你改变的对象不用于渲染，React 就不会关心你对 ref 或其内容做了什么。\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"refs-and-the-dom\",\"children\":\"ref 和 DOM \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以将 ref 指向任何值。但是，ref 最常见的用法是访问 DOM 元素。例如，如果你想以编程方式聚焦一个输入框，这种用法就会派上用场。当你将 ref 传递给 JSX 中的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性时，比如 \",[\"$r\",\"code\",null,{\"children\":\"<div ref={myRef}>\"}],\"，React 会将相应的 DOM 元素放入 \",[\"$r\",\"code\",null,{\"children\":\"myRef.current\"}],\" 中。当元素从 DOM 中删除时，React 会将 \",[\"$r\",\"code\",null,{\"children\":\"myRef.current\"}],\" 更新为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。你可以在 \",[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs\",\"children\":\"使用 ref 操作 DOM\"}],\" 中阅读更多相关信息。\"]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"ref 是一种脱围机制，用于保留不用于渲染的值。 你不会经常需要它们。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"ref 是一个普通的 JavaScript 对象，具有一个名为 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 的属性，你可以对其进行读取或设置。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你可以通过调用 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" Hook 来让 React 给你一个 ref。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"与 state 一样，ref 允许你在组件的重新渲染之间保留信息。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"与 state 不同，设置 ref 的 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 值不会触发重新渲染。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"不要在渲染过程中读取或写入 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\"。这使你的组件难以预测。\"]}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"fix-a-broken-chat-input\",\"children\":\"修复坏掉的聊天输入框 \"}],[\"$r\",\"p\",null,{\"children\":[\"输入消息并单击“发送”。你会注意到，在看到“已发送！”提示框之前有 3 秒的延迟。在此延迟期间，你可以看到一个“撤消”按钮。点击它。这个“撤消”按钮应该阻止“发送！”消息弹出。它通过调用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/clearTimeout\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"clearTimeout\"}]}],\" 来做到这点，这一步骤需要使用在 \",[\"$r\",\"code\",null,{\"children\":\"handleSend\"}],\" 时保存的 timeout ID。但是，即使在单击“撤消”后，“已发送！”消息仍然出现。找出它不起作用的原因，然后修复它。\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"像\",[\"$r\",\"code\",null,{\"children\":\"let timeoutID\"}],\" 这样的常规变量不会在重新渲染之间“存活”，因为每次渲染都从头开始运行你的组件（并初始化其变量）。你应该将 timeout ID 保存在其他地方吗？\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Chat() {\\n  const [text, setText] = useState('');\\n  const [isSending, setIsSending] = useState(false);\\n  let timeoutID = null;\\n\\n  function handleSend() {\\n    setIsSending(true);\\n    timeoutID = setTimeout(() => {\\n      alert('已发送！');\\n      setIsSending(false);\\n    }, 3000);\\n  }\\n\\n  function handleUndo() {\\n    setIsSending(false);\\n    clearTimeout(timeoutID);\\n  }\\n\\n  return (\\n    <>\\n      <input\\n        disabled={isSending}\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button\\n        disabled={isSending}\\n        onClick={handleSend}>\\n        {isSending ? '发送中……' : '发送'}\\n      </button>\\n      {isSending &&\\n        <button onClick={handleUndo}>\\n          撤销\\n        </button>\\n      }\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"每当你的组件重新渲染时（例如当你设置 state 时），所有局部变量都会从头开始初始化。这就是为什么你不能将 timeout ID 保存在像 \",[\"$r\",\"code\",null,{\"children\":\"timeoutID\"}],\" 这样的局部变量中，然后期望未来另一个事件处理器“看到”它。相反，将它存储在一个 ref 中，React 将在渲染之间保留它。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function Chat() {\\n  const [text, setText] = useState('');\\n  const [isSending, setIsSending] = useState(false);\\n  const timeoutRef = useRef(null);\\n\\n  function handleSend() {\\n    setIsSending(true);\\n    timeoutRef.current = setTimeout(() => {\\n      alert('已发送!');\\n      setIsSending(false);\\n    }, 3000);\\n  }\\n\\n  function handleUndo() {\\n    setIsSending(false);\\n    clearTimeout(timeoutRef.current);\\n  }\\n\\n  return (\\n    <>\\n      <input\\n        disabled={isSending}\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button\\n        disabled={isSending}\\n        onClick={handleSend}>\\n        {isSending ? '发送中……' : '发送'}\\n      </button>\\n      {isSending &&\\n        <button onClick={handleUndo}>\\n          撤销\\n        </button>\\n      }\\n    </>\\n  );\\n}\\n\"}]}]}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-component-failing-to-re-render\",\"children\":\"修复无法重新渲染的组件 \"}],[\"$r\",\"p\",null,{\"children\":\"这个按钮本该在显示“开”和“关”之间切换。但是，它始终显示“关”。这段代码有什么问题？修复它。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Toggle() {\\n  const isOnRef = useRef(false);\\n\\n  return (\\n    <button onClick={() => {\\n      isOnRef.current = !isOnRef.current;\\n    }}>\\n      {isOnRef.current ? '开' : '关'}\\n    </button>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，ref 的 current 值被用于计算渲染输出：\",[\"$r\",\"code\",null,{\"children\":\"{isOnRef.current ? '开'：'关'}\"}],\"。这表明此信息本来不应该在 ref 中，而应该放在 state 里。要修复它，请删除 ref ，使用 state 代替：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Toggle() {\\n  const [isOn, setIsOn] = useState(false);\\n\\n  return (\\n    <button onClick={() => {\\n      setIsOn(!isOn);\\n    }}>\\n      {isOn ? '开' : '关'}\\n    </button>\\n  );\\n}\\n\"}]}]}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-debouncing\",\"children\":\"修复防抖 \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，所有按钮点击处理器都是 \",[\"$r\",\"a\",null,{\"href\":\"https://redd.one/blog/debounce-vs-throttle\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"“防抖的”\"}],\"。 要了解这意味着什么，请按下其中一个按钮。注意消息在一秒后显示。如果你在等待消息时按下按钮，计时器将重置。因此如果你多次快速单击同一个按钮，则直到你停止单击 \",[\"$r\",\"strong\",null,{\"children\":\"之后\"}],\" 1 秒钟，该消息才会显示。防抖可以让你将一些动作推迟到用户“停止动作”之后。\"]}],[\"$r\",\"p\",null,{\"children\":\"这个例子可以正常运行，但并不完全符合预期。按钮不是独立的。要查看问题，请单击其中一个按钮，然后立即单击另一个按钮。你本来期望在延迟之后，你会看到两个按钮的消息。但只有最后一个按钮的消息出现了。第一个按钮的消息丢失了。\"}],[\"$r\",\"p\",null,{\"children\":\"为什么按钮会相互干扰呢？查找并修复问题。\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"最后一个 timeout ID 变量是被所有 \",[\"$r\",\"code\",null,{\"children\":\"DebouncedButton\"}],\" 组件所共享的。这就是为什么单击一个按钮会重置另一个按钮的 timeout 时间。你能为每个按钮存储一个单独的 timeout ID 吗？\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let timeoutID;\\n\\nfunction DebouncedButton({ onClick, children }) {\\n  return (\\n    <button onClick={() => {\\n      clearTimeout(timeoutID);\\n      timeoutID = setTimeout(() => {\\n        onClick();\\n      }, 1000);\\n    }}>\\n      {children}\\n    </button>\\n  );\\n}\\n\\nexport default function Dashboard() {\\n  return (\\n    <>\\n      <DebouncedButton\\n        onClick={() => alert('宇宙飞船已发射！')}\\n      >\\n        发射宇宙飞船\\n      </DebouncedButton>\\n      <DebouncedButton\\n        onClick={() => alert('汤煮好了！')}\\n      >\\n        煮点儿汤\\n      </DebouncedButton>\\n      <DebouncedButton\\n        onClick={() => alert('摇篮曲唱完了！')}\\n      >\\n        唱首摇篮曲\\n      </DebouncedButton>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"像 \",[\"$r\",\"code\",null,{\"children\":\"timeoutID\"}],\" 这样的变量是被所有组件共享的。这就是为什么单击第二个按钮会重置第一个按钮未完成的 timeout 的原因。要解决此问题，你可以把 timeout 保存在 ref 中。每个按钮都有自己的 ref，因此它们不会相互冲突。请注意快速单击两个按钮如何显示两个消息。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nfunction DebouncedButton({ onClick, children }) {\\n  const timeoutRef = useRef(null);\\n  return (\\n    <button onClick={() => {\\n      clearTimeout(timeoutRef.current);\\n      timeoutRef.current = setTimeout(() => {\\n        onClick();\\n      }, 1000);\\n    }}>\\n      {children}\\n    </button>\\n  );\\n}\\n\\nexport default function Dashboard() {\\n  return (\\n    <>\\n      <DebouncedButton\\n        onClick={() => alert('宇宙飞船已发射！')}\\n      >\\n        发射宇宙飞船\\n      </DebouncedButton>\\n      <DebouncedButton\\n        onClick={() => alert('汤煮好了！')}\\n      >\\n        煮点儿汤\\n      </DebouncedButton>\\n      <DebouncedButton\\n        onClick={() => alert('摇篮曲唱完了！')}\\n      >\\n        唱首摇篮曲\\n      </DebouncedButton>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin: 10px; }\\n\"}]}]]}]]}],[\"$r\",\"h4\",null,{\"id\":\"read-the-latest-state\",\"children\":\"读取最新的 state \"}],[\"$r\",\"p\",null,{\"children\":[\"在此示例中，当你按下“发送”后，在显示消息之前会有一小段延迟。输入“你好”，按下发送，然后再次快速编辑输入。尽管你进行了编辑，提示框仍会显示“你好”（这是按钮被点击 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot#state-over-time\",\"children\":\"那一刻\"}],\" state 的值）。\"]}],[\"$r\",\"p\",null,{\"children\":[\"通常，这种行为是你在应用程序中想要的。但是，有时可能需要一些异步代码来读取某些 state 的 \",[\"$r\",\"strong\",null,{\"children\":\"最新\"}],\" 版本。你能想出一种方法，让提示框显示 \",[\"$r\",\"strong\",null,{\"children\":\"当前\"}],\" 输入文本而不是点击时的内容吗？\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function Chat() {\\n  const [text, setText] = useState('');\\n\\n  function handleSend() {\\n    setTimeout(() => {\\n      alert('正在发送：' + text);\\n    }, 3000);\\n  }\\n\\n  return (\\n    <>\\n      <input\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button\\n        onClick={handleSend}>\\n        发送\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"state 运作起来 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"就像快照\"}],\"，因此你无法从 timeout 等异步操作中读取最新的 state。但是，你可以在 ref 中保存最新的输入文本。ref 是可变的，因此你可以随时读取 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性。由于当前文本也用于渲染，在这个例子中，你需要 \",[\"$r\",\"strong\",null,{\"children\":\"同时\"}],\" 使用一个 state 变量（用于渲染）\",[\"$r\",\"strong\",null,{\"children\":\"和\"}],\" 一个 ref（在 timeout 时读取它）。你需要手动更新当前的 ref 值。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function Chat() {\\n  const [text, setText] = useState('');\\n  const textRef = useRef(text);\\n\\n  function handleChange(e) {\\n    setText(e.target.value);\\n    textRef.current = e.target.value;\\n  }\\n\\n  function handleSend() {\\n    setTimeout(() => {\\n      alert('正在发送：' + textRef.current);\\n    }, 3000);\\n  }\\n\\n  return (\\n    <>\\n      <input\\n        value={text}\\n        onChange={handleChange}\\n      />\\n      <button\\n        onClick={handleSend}>\\n        发送\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}]]}]]}]]","meta":{"title":"使用 ref 引用值","translators":["SylviaZ89","Neo42"]}},"__N_SSG":true}