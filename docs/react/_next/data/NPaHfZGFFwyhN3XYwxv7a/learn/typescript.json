{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#installation\",\"depth\":2,\"text\":\"安装 \"},{\"url\":\"#adding-typescript-to-an-existing-react-project\",\"depth\":3,\"text\":\"在现有 React 项目中添加 TypeScript \"},{\"url\":\"#typescript-with-react-components\",\"depth\":2,\"text\":\"在 React 组件中使用 TypeScript \"},{\"url\":\"#example-hooks\",\"depth\":2,\"text\":\"Hooks 示例 \"},{\"url\":\"#typing-usestate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" \"]},{\"url\":\"#typing-usereducer\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" \"]},{\"url\":\"#typing-usecontext\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" \"]},{\"url\":\"#typing-usememo\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" \"]},{\"url\":\"#typing-usecallback\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useCallback\"}],\" \"]},{\"url\":\"#useful-types\",\"depth\":2,\"text\":\"常用类型 \"},{\"url\":\"#typing-dom-events\",\"depth\":3,\"text\":\"DOM 事件 \"},{\"url\":\"#typing-children\",\"depth\":3,\"text\":\"子元素 \"},{\"url\":\"#typing-style-props\",\"depth\":3,\"text\":\"样式属性 \"},{\"url\":\"#further-learning\",\"depth\":2,\"text\":\"更多学习资源 \"}]","content":"[[\"$r\",\"MaxWidth\",\"28\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"TypeScript 是一种向 JavaScript 代码添加类型定义的常用方法。TypeScript 天然支持 JSX——只需在项目中添加 \",[\"$r\",\"a\",null,{\"href\":\"https://www.npmjs.com/package/@types/react\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"@types/react\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"https://www.npmjs.com/package/@types/react-dom\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"@types/react-dom\"}]}],\" 即可获得完整的 React Web 支持。\"]}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/typescript#typescript-with-react-components\",\"children\":\"在 React 组件中使用 TypeScript\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/typescript#example-hooks\",\"children\":\"带有 Hook 的类型示例\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/typescript/#useful-types\",\"children\":[\"来自 \",[\"$r\",\"code\",null,{\"children\":\"@types/react\"}],\" 的常见类型\"]}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/typescript/#further-learning\",\"children\":\"更多学习资源\"}]}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"installation\",\"children\":\"安装 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"所有的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/start-a-new-react-project#production-grade-react-framework\",\"children\":\"生产级 React 框架\"}],\" 都支持使用 TypeScript。请按照框架特定的指南进行安装：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"https://nextjs.org/docs/app/building-your-application/configuring/typescript\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Next.js\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"https://remix.run/docs/en/1.19.2/guides/typescript\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Remix\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"https://www.gatsbyjs.com/docs/how-to/custom-configuration/typescript/\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Gatsby\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"https://docs.expo.dev/guides/typescript/\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Expo\"}]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"adding-typescript-to-an-existing-react-project\",\"children\":\"在现有 React 项目中添加 TypeScript \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"使用下面命令安装最新版本的 React 类型定义：\"}],\"\\n\",[\"$r\",\"TerminalBlock\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"npm install @types/react @types/react-dom\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然后在 \",[\"$r\",\"code\",null,{\"children\":\"tsconfig.json\"}],\" 中设置以下编译器选项：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"必须在 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/tsconfig/#lib\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"lib\"}]}],\" 中包含 \",[\"$r\",\"code\",null,{\"children\":\"dom\"}],\"（注意：如果没有指定 \",[\"$r\",\"code\",null,{\"children\":\"lib\"}],\" 选项，默认情况下会包含 \",[\"$r\",\"code\",null,{\"children\":\"dom\"}],\"）。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/tsconfig/#jsx\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"jsx\"}]}],\" 必须设置为一个有效的选项。对于大多数应用程序，\",[\"$r\",\"code\",null,{\"children\":\"preserve\"}],\" 应该足够了。\\n如果你正在发布一个库，请查阅 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/tsconfig/#jsx\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"jsx\"}],\" 文档\"]}],\" 以选择合适的值。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"typescript-with-react-components\",\"children\":\"在 React 组件中使用 TypeScript \"}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"每个包含 JSX 的文件都必须使用 \",[\"$r\",\"code\",null,{\"children\":\".tsx\"}],\" 文件扩展名。这是一个 TypeScript 特定的扩展，告诉 TypeScript 该文件包含 JSX。\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"使用 TypeScript 编写 React 与使用 JavaScript 编写 React 非常相似。与组件一起工作时的关键区别是，你可以为组件的 props 提供类型。这些类型可用于正确性检查，并在编辑器中提供内联文档。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"以 \",[\"$r\",\"a\",null,{\"href\":\"/learn\",\"children\":\"快速入门\"}],\" 指南中的 \",[\"$r\",\"a\",null,{\"href\":\"/learn#components\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"MyButton\"}],\" 组件\"]}],\" 为例，我们可以为按钮的 \",[\"$r\",\"code\",null,{\"children\":\"title\"}],\" 添加一个描述类型：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-tsx\",\"meta\":\"src/App.tsx active\",\"children\":\"function MyButton({ title }: { title: string }) {\\n  return (\\n    <button>{title}</button>\\n  );\\n}\\n\\nexport default function MyApp() {\\n  return (\\n    <div>\\n      <h1>欢迎来到我的应用</h1>\\n      <MyButton title=\\\"我是一个按钮\\\" />\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import AppTSX from \\\"./App.tsx\\\";\\nexport default App = AppTSX;\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"34\",{\"children\":[\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"这些沙盒可以处理 TypeScript 代码，但它们不运行类型检查器。这意味着你可以修改 TypeScript 沙盒以进行学习，但你不会收到任何类型错误或警告。要进行类型检查，你可以使用 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/play\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"TypeScript Playground\"}],\" 或使用更完整的在线沙盒。\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这种内联语法是为组件提供类型的最简单方法，但是一旦你开始描述几个字段，它可能变得难以管理。相反，你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"interface\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"type\"}],\" 来描述组件的 props：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-tsx\",\"meta\":\"src/App.tsx active\",\"children\":\"interface MyButtonProps {\\n  /** 按钮文字 */\\n  title: string;\\n  /** 按钮是否禁用 */\\n  disabled: boolean;\\n}\\n\\nfunction MyButton({ title, disabled }: MyButtonProps) {\\n  return (\\n    <button disabled={disabled}>{title}</button>\\n  );\\n}\\n\\nexport default function MyApp() {\\n  return (\\n    <div>\\n      <h1>Welcome to my app</h1>\\n      <MyButton title=\\\"我是一个禁用按钮\\\" disabled={true}/>\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import AppTSX from \\\"./App.tsx\\\";\\nexport default App = AppTSX;\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"66\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"描述组件 props 的类型可以根据需要变得简单或复杂，但它们应该是使用 \",[\"$r\",\"code\",null,{\"children\":\"type\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"interface\"}],\" 描述的对象类型。你可以在 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/docs/handbook/2/objects.html\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"对象类型\"}],\" 中了解 TypeScript 如何描述对象，但你可能还对使用 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"联合类型\"}],\" 描述可以是几种不同类型之一的 prop，以及在 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/docs/handbook/2/types-from-types.html\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"从类型创建类型\"}],\" 指南中参考更高级的用例。\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"example-hooks\",\"children\":\"Hooks 示例 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"来自 \",[\"$r\",\"code\",null,{\"children\":\"@types/react\"}],\" 的类型定义包括内置的 Hook，因此你可以在组件中使用它们，无需任何额外设置。它们是根据你在组件中编写的代码构建的，所以你会得到很多 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/docs/handbook/type-inference.html\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"类型推断\"}],\"，并且理想情况下不需要处理提供类型的细节。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"但是，我们可以看一下如何为 Hook 提供类型的几个示例。\"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"typing-usestate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" Hook\"]}],\" 会重用作为初始 state 传入的值以确定值的类型。例如：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// 推断类型为 \\\"boolean\\\"\\nconst [enabled, setEnabled] = useState(false);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这将为 \",[\"$r\",\"code\",null,{\"children\":\"enabled\"}],\" 分配 \",[\"$r\",\"code\",null,{\"children\":\"boolean\"}],\" 类型，而 \",[\"$r\",\"code\",null,{\"children\":\"setEnabled\"}],\" 将是一个接受 \",[\"$r\",\"code\",null,{\"children\":\"boolean\"}],\" 参数的函数，或者返回 \",[\"$r\",\"code\",null,{\"children\":\"boolean\"}],\" 的函数。如果你想为 state 显式提供一个类型，你可以通过为 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 调用提供一个类型参数来实现：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// 显式设置类型为 \\\"boolean\\\"\\nconst [enabled, setEnabled] = useState<boolean>(false);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这种情况下，这并不是很有用，但是当你有一个联合类型时，你可能想要提供一个 \",[\"$r\",\"code\",null,{\"children\":\"type\"}],\"。例如，这里的 \",[\"$r\",\"code\",null,{\"children\":\"status\"}],\" 可以是几个不同的字符串之一：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"type Status = \\\"idle\\\" | \\\"loading\\\" | \\\"success\\\" | \\\"error\\\";\\n\\nconst [status, setStatus] = useState<Status>(\\\"idle\\\");\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"或者，如 \",[\"$r\",\"a\",null,{\"href\":\"/learn/choosing-the-state-structure#principles-for-structuring-state\",\"children\":\"选择 state 结构原则\"}],\" 中推荐的，你可以将相关的 state 作为一个对象分组，并通过对象类型描述不同的可能性：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"type RequestState =\\n  | { status: 'idle' }\\n  | { status: 'loading' }\\n  | { status: 'success', data: any }\\n  | { status: 'error', error: Error };\\n\\nconst [requestState, setRequestState] = useState<RequestState>({ status: 'idle' });\\n\"}]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"typing-usereducer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useReducer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useReducer\"}]}],\" 是一个更复杂的 Hook，它接受一个 reducer 函数和一个初始 state 作为参数，并将从初始 state 推断出 reducer 函数的类型。你可以选择性地为 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 提供类型参数以为 state 提供类型。但是更高的做法仍然是在初始 state 上添加类型：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-tsx\",\"meta\":\"src/App.tsx active\",\"children\":\"import {useReducer} from 'react';\\n\\ninterface State {\\n   count: number \\n};\\n\\ntype CounterAction =\\n  | { type: \\\"reset\\\" }\\n  | { type: \\\"setCount\\\"; value: State[\\\"count\\\"] }\\n\\nconst initialState: State = { count: 0 };\\n\\nfunction stateReducer(state: State, action: CounterAction): State {\\n  switch (action.type) {\\n    case \\\"reset\\\":\\n      return initialState;\\n    case \\\"setCount\\\":\\n      return { ...state, count: action.value };\\n    default:\\n      throw new Error(\\\"Unknown action\\\");\\n  }\\n}\\n\\nexport default function App() {\\n  const [state, dispatch] = useReducer(stateReducer, initialState);\\n\\n  const addFive = () => dispatch({ type: \\\"setCount\\\", value: state.count + 5 });\\n  const reset = () => dispatch({ type: \\\"reset\\\" });\\n\\n  return (\\n    <div>\\n      <h1>欢迎来到我的计数器</h1>\\n\\n      <p>计数： {state.count}</p>\\n      <button onClick={addFive}>加 5</button>\\n      <button onClick={reset}>重置</button>\\n    </div>\\n  );\\n}\\n\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import AppTSX from \\\"./App.tsx\\\";\\nexport default App = AppTSX;\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"82\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"我们在几个关键位置使用了 TypeScript：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"interface State\"}],\" 描述了 reducer state 的类型。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"type CounterAction\"}],\" 描述了可以 dispatch 至 reducer 的不同 action。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"const initialState: State\"}],\" 为初始 state 提供类型，并且也将成为 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 默认使用的类型。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"stateReducer(state: State, action: CounterAction): State\"}],\" 设置了 reducer 函数参数和返回值的类型。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 提供类型参数的更明确的替代方法是在 \",[\"$r\",\"code\",null,{\"children\":\"initialState\"}],\" 上设置类型：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"import { stateReducer, State } from './your-reducer-implementation';\\n\\nconst initialState = { count: 0 };\\n\\nexport default function App() {\\n  const [state, dispatch] = useReducer<State>(stateReducer, initialState);\\n}\\n\"}]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"typing-usecontext\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useContext\"}]}],\" 是一种无需通过组件传递 props 而可以直接在组件树中传递数据的技术。它是通过创建 provider 组件使用，通常还会创建一个 Hook 以在子组件中使用该值。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"从传递给 \",[\"$r\",\"code\",null,{\"children\":\"createContext\"}],\" 调用的值推断 context 提供的值的类型：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-tsx\",\"meta\":\"src/App.tsx active\",\"children\":\"import { createContext, useContext, useState } from 'react';\\n\\ntype Theme = \\\"light\\\" | \\\"dark\\\" | \\\"system\\\";\\nconst ThemeContext = createContext<Theme>(\\\"system\\\");\\n\\nconst useGetTheme = () => useContext(ThemeContext);\\n\\nexport default function MyApp() {\\n  const [theme, setTheme] = useState<Theme>('light');\\n\\n  return (\\n    <ThemeContext.Provider value={theme}>\\n      <MyComponent />\\n    </ThemeContext.Provider>\\n  )\\n}\\n\\nfunction MyComponent() {\\n  const theme = useGetTheme();\\n\\n  return (\\n    <div>\\n      <p>当前主题：{theme}</p>\\n    </div>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import AppTSX from \\\"./App.tsx\\\";\\nexport default App = AppTSX;\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"116\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你没有一个合理的默认值时，这种技术是有效的，而在这些情况下，\",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 作为默认值可能感觉是合理的。但是，为了让类型系统理解你的代码，你需要在 \",[\"$r\",\"code\",null,{\"children\":\"createContext\"}],\" 上显式设置 \",[\"$r\",\"code\",null,{\"children\":\"ContextShape | null\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这会导致一个问题，你需要在 context consumer 中消除 \",[\"$r\",\"code\",null,{\"children\":\"| null\"}],\" 的类型。我们建议让 Hook 在运行时检查它的存在，并在不存在时抛出一个错误：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5, 16-20}\",\"children\":\"import { createContext, useContext, useState, useMemo } from 'react';\\n\\n// 这是一个简单的示例，但你可以想象一个更复杂的对象\\ntype ComplexObject = {\\n  kind: string\\n};\\n\\n// 上下文在类型中创建为 `| null`，以准确反映默认值。\\nconst Context = createContext<ComplexObject | null>(null);\\n\\n// 这个 Hook 会在运行时检查 context 是否存在，并在不存在时抛出一个错误。\\nconst useGetComplexObject = () => {\\n  const object = useContext(Context);\\n  if (!object) { throw new Error(\\\"useGetComplexObject must be used within a Provider\\\") }\\n  return object;\\n}\\n\\nexport default function MyApp() {\\n  const object = useMemo(() => ({ kind: \\\"complex\\\" }), []);\\n\\n  return (\\n    <Context.Provider value={object}>\\n      <MyComponent />\\n    </Context.Provider>\\n  )\\n}\\n\\nfunction MyComponent() {\\n  const object = useGetComplexObject();\\n\\n  return (\\n    <div>\\n      <p>Current object: {object.kind}</p>\\n    </div>\\n  )\\n}\\n\"}]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"typing-usememo\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\" 会从函数调用中创建/重新访问记忆化值，只有在第二个参数中传入的依赖项发生变化时，才会重新运行该函数。函数的类型是根据第一个参数中函数的返回值进行推断的，如果希望明确指定，可以为该 Hook 提供一个类型参数以指定函数类型。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"// 从 filterTodos 的返回值推断 visibleTodos 的类型\\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\\n\"}]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"typing-usecallback\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useCallback\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useCallback\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useCallback\"}]}],\" 会在第二个参数中传入的依赖项保持不变的情况下，为函数提供相同的引用。与 \",[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" 类似，函数的类型是根据第一个参数中函数的返回值进行推断的，如果希望明确指定，可以为这个 Hook 提供一个类型参数以指定函数类型。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const handleClick = useCallback(() => {\\n  // ...\\n}, [todos]);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当在 TypeScript 严格模式下，使用 \",[\"$r\",\"code\",null,{\"children\":\"useCallback\"}],\" 需要为回调函数中的参数添加类型注解。这是因为回调函数的类型是根据函数的返回值进行推断的——如果没有参数，那么类型就不能完全理解。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"根据自身的代码风格偏好，你可以使用 React 类型中的 \",[\"$r\",\"code\",null,{\"children\":\"*EventHandler\"}],\" 函数以在定义回调函数的同时为事件处理程序提供类型注解：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"import { useState, useCallback } from 'react';\\n\\nexport default function Form() {\\n  const [value, setValue] = useState(\\\"Change me\\\");\\n\\n  const handleChange = useCallback<React.ChangeEventHandler<HTMLInputElement>>((event) => {\\n    setValue(event.currentTarget.value);\\n  }, [setValue])\\n  \\n  return (\\n    <>\\n      <input value={value} onChange={handleChange} />\\n      <p>值： {value}</p>\\n    </>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"useful-types\",\"children\":\"常用类型 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当逐渐适应 React 和 TypeScript 的搭配使用后, 可以尝试阅读 \",[\"$r\",\"code\",null,{\"children\":\"@types/react\"}],\"，此库提供了一整套类型。你可以在 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DefinitelyTyped 的 React 目录中\"}],\" 找到它们。我们将在这里介绍一些更常见的类型。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"typing-dom-events\",\"children\":\"DOM 事件 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在 React 中处理 DOM 事件时，事件的类型通常可以从事件处理程序中推断出来。但是，当你想提取一个函数以传递给事件处理程序时，你需要明确设置事件的类型。\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-tsx\",\"meta\":\"src/App.tsx active\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [value, setValue] = useState(\\\"Change me\\\");\\n\\n  function handleChange(event: React.ChangeEvent<HTMLInputElement>) {\\n    setValue(event.currentTarget.value);\\n  }\\n\\n  return (\\n    <>\\n      <input value={value} onChange={handleChange} />\\n      <p>值： {value}</p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import AppTSX from \\\"./App.tsx\\\";\\nexport default App = AppTSX;\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 类型中提供了许多事件类型 —— 完整列表可以在 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/b580df54c0819ec9df62b0835a315dd48b8594a9/types/react/index.d.ts#L1247C1-L1373\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"这里\"}],\" 查看，它基于 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/Events\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DOM 的常用事件\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"当你需要确定某个类型时，可以先将鼠标悬停在你使用的事件处理器上，这样可以查看到事件的具体类型。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你需要使用不包含在此列表中的事件时，你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"React.SyntheticEvent\"}],\" 类型，这是所有事件的基类型。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"typing-children\",\"children\":\"子元素 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"描述组件的子元素有两种常见方法。第一种是使用 \",[\"$r\",\"code\",null,{\"children\":\"React.ReactNode\"}],\" 类型，这是可以在 JSX 中作为子元素传递的所有可能类型的并集：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"interface ModalRendererProps {\\n  title: string;\\n  children: React.ReactNode;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这是对子元素的一个非常宽泛的定义。第二种方法是使用 \",[\"$r\",\"code\",null,{\"children\":\"React.ReactElement\"}],\" 类型，它只包括 JSX 元素，而不包括 JavaScript 原始类型，如 string 或 number：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"interface ModalRendererProps {\\n  title: string;\\n  children: React.ReactElement;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"注意，你不能使用 TypeScript 来描述子元素是某种类型的 JSX 元素，所以你不能使用类型系统来描述一个只接受 \",[\"$r\",\"code\",null,{\"children\":\"<li>\"}],\" 子元素的组件。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以在这个 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgIilQ3wChSB6CxYmAOmXRgDkIATJOdNJMGAZzgwAFpxAR+8YADswAVwGkZMJFEzpOjDKw4AFHGEEBvUnDhphwADZsi0gFw0mDWjqQBuUgF9yaCNMlENzgAXjgACjADfkctFnYkfQhDAEpQgD44AB42YAA3dKMo5P46C2tbJGkvLIpcgt9-QLi3AEEwMFCItJDMrPTTbIQ3dKywdIB5aU4kKyQQKpha8drhhIGzLLWODbNs3b3s8YAxKBQAcwXpAThMaGWDvbH0gFloGbmrgQfBzYpd1YjQZbEYARkB6zMwO2SHSAAlZlYIBCdtCRkZpHIrFYahQYQD8UYYFA5EhcfjyGYqHAXnJAsIUHlOOUbHYhMIIHJzsI0Qk4P9SLUBuRqXEXEwAKKfRZcNA8PiCfxWACecAAUgBlAAacFm80W-CU11U6h4TgwUv11yShjgJjMLMqDnN9Dilq+nh8pD8AXgCHdMrCkWisVoAet0R6fXqhWKhjKllZVVxMcavpd4Zg7U6Qaj+2hmdG4zeRF10uu-Aeq0LBfLMEe-V+T2L7zLVu+FBWLdLeq+lc7DYFf39deFVOotMCACNOCh1dq219a+30uC8YWoZsRyuEdjkevR8uvoVMdjyTWt4WiSSydXD4NqZP4AymeZE072ZzuUeZQKheQgA\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"TypeScript playground\"}],\" 中查看 \",[\"$r\",\"code\",null,{\"children\":\"React.ReactNode\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"React.ReactElement\"}],\" 的示例，并使用类型检查器进行验证。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"typing-style-props\",\"children\":\"样式属性 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当在 React 中使用内联样式时，你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"React.CSSProperties\"}],\" 来描述传递给 \",[\"$r\",\"code\",null,{\"children\":\"style\"}],\" 属性的对象。这个类型是所有可能的 CSS 属性的并集，它能确保你传递给 \",[\"$r\",\"code\",null,{\"children\":\"style\"}],\" 属性的是有效的 CSS 属性，并且你能在编辑器中获得样式编码提示。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"interface MyComponentProps {\\n  style: React.CSSProperties;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"further-learning\",\"children\":\"更多学习资源 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"本指南已经介绍了如何在 React 中使用 TypeScript 的基础知识，但还有更多内容等待学习。官网中的单个 API 页面或许包含了如何与 TypeScript 一起使用它们的更深入的说明。\\n文档中的各个 API 页面可能会包含更深入的说明，介绍如何在 TypeScript 中使用它们。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"我们推荐以下资源：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/docs/handbook/\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"TypeScript 官方文档\"}],\" 涵盖了大多数关键的语言特性。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://devblogs.microsoft.com/typescript/\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"TypeScript 发布笔记\"}],\" 深入介绍了每一个新特性。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://react-typescript-cheatsheet.netlify.app/\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"React TypeScript Cheatsheet\"}],\" 是一个社区维护的，用于在 React 中使用 TypeScript 的速查表，涵盖了许多有用的边界情况，并提供了比本文更广泛全面的内容。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://discord.com/invite/typescript\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"TypeScript Community Discord\"}],\" 是一个提问并获得有关 TypeScript 和 React issues 帮助的好地方。\"]}],\"\\n\"]}],\"\\n\"]}]]}]]","meta":{"title":"使用 TypeScript","re":"https://github.com/reactjs/react.dev/issues/5960"}},"__N_SSG":true}