{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#rendering-data-from-arrays\",\"depth\":2,\"text\":\"从数组中渲染数据 \"},{\"url\":\"#filtering-arrays-of-items\",\"depth\":2,\"text\":\"对数组项进行过滤 \"},{\"url\":\"#keeping-list-items-in-order-with-key\",\"depth\":2,\"text\":[\"用 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 保持列表项的顺序 \"]},{\"url\":\"#where-to-get-your-key\",\"depth\":3,\"text\":[\"如何设定 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 值 \"]},{\"url\":\"#rules-of-keys\",\"depth\":3,\"text\":\"key 需要满足的条件 \"},{\"url\":\"#why-does-react-need-keys\",\"depth\":3,\"text\":\"React 中为什么需要 key？ \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"28\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"你可能经常需要通过 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array#\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"JavaScript 的数组方法\"}],\" 来操作数组中的数据，从而将一个数据集渲染成多个相似的组件。在这篇文章中，你将学会如何在 React 中使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"filter()\"}]}],\" 筛选需要渲染的组件和使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"map()\"}]}],\" 把数组转换成组件数组。\"]}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如何通过 JavaScript 的 \",[\"$r\",\"code\",null,{\"children\":\"map()\"}],\" 方法从数组中生成组件\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如何通过 JavaScript 的 \",[\"$r\",\"code\",null,{\"children\":\"filter()\"}],\" 筛选需要渲染的组件\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"何时以及为何使用 React 中的 key\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"rendering-data-from-arrays\",\"children\":\"从数组中渲染数据 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这里我们有一个列表。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<ul>\\n  <li>凯瑟琳·约翰逊: 数学家</li>\\n  <li>马里奥·莫利纳: 化学家</li>\\n  <li>穆罕默德·阿卜杜勒·萨拉姆: 物理学家</li>\\n  <li>珀西·莱温·朱利亚: 化学家</li>\\n  <li>苏布拉马尼扬·钱德拉塞卡: 天体物理学家</li>\\n</ul>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"可以看到，这些列表项之间唯一的区别就是其中的内容/数据。未来你可能会碰到很多类似的情况，在那些场景中，你想基于不同的数据渲染出相似的组件，比如评论列表或者个人资料的图库。在这样的场景下，可以把要用到的数据存入 JavaScript 对象或数组，然后用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"map()\"}]}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"filter()\"}]}],\" 这样的方法来渲染出一个组件列表。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这里给出一个由数组生成一系列列表项的简单示例：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"首先，把数据 \",[\"$r\",\"strong\",null,{\"children\":\"存储\"}],\" 到数组中：\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const people = [\\n  '凯瑟琳·约翰逊: 数学家',\\n  '马里奥·莫利纳: 化学家',\\n  '穆罕默德·阿卜杜勒·萨拉姆: 物理学家',\\n  '珀西·莱温·朱利亚: 化学家',\\n  '苏布拉马尼扬·钱德拉塞卡: 天体物理学家',\\n];\\n\"}]}],\"\\n\",[\"$r\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"遍历\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"people\"}],\" 这个数组中的每一项，并获得一个新的 JSX 节点数组 \",[\"$r\",\"code\",null,{\"children\":\"listItems\"}],\"：\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const listItems = people.map(person => <li>{person}</li>);\\n\"}]}],\"\\n\",[\"$r\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"把 \",[\"$r\",\"code\",null,{\"children\":\"listItems\"}],\" 用 \",[\"$r\",\"code\",null,{\"children\":\"<ul>\"}],\" 包裹起来，然后 \",[\"$r\",\"strong\",null,{\"children\":\"返回\"}],\" 它：\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"return <ul>{listItems}</ul>;\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"来看看运行的结果：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const people = [\\n  '凯瑟琳·约翰逊: 数学家',\\n  '马里奥·莫利纳: 化学家',\\n  '穆罕默德·阿卜杜勒·萨拉姆: 物理学家',\\n  '珀西·莱温·朱利亚: 化学家',\\n  '苏布拉马尼扬·钱德拉塞卡: 天体物理学家',\\n];\\n\\nexport default function List() {\\n  const listItems = people.map(person =>\\n    <li>{person}</li>\\n  );\\n  return <ul>{listItems}</ul>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"li { margin-bottom: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"58\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"注意上面的沙盒可能会输出这样一个控制台错误：\"}],\"\\n\",[\"$r\",\"ConsoleBlock\",null,{\"level\":\"error\",\"children\":[\"$r\",\"p\",null,{\"children\":\"Warning: Each child in a list should have a unique “key” prop.\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"等会我们会学到怎么修复它。在此之前，我们先来看看如何把这个数组变得更加结构化。\"}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"filtering-arrays-of-items\",\"children\":\"对数组项进行过滤 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"让我们把 \",[\"$r\",\"code\",null,{\"children\":\"people\"}],\" 数组变得更加结构化一点。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const people = [\\n  {\\n    id: 0,\\n    name: '凯瑟琳·约翰逊',\\n    profession: '数学家',\\n  },\\n  {\\n    id: 1,\\n    name: '马里奥·莫利纳',\\n    profession: '化学家',\\n  },\\n  {\\n    id: 2,\\n    name: '穆罕默德·阿卜杜勒·萨拉姆',\\n    profession: '物理学家',\\n  },\\n  {\\n    name: '珀西·莱温·朱利亚',\\n    profession: '化学家',\\n  },\\n  {\\n    name: '苏布拉马尼扬·钱德拉塞卡',\\n    profession: '天体物理学家',\\n  },\\n];\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在，假设你只想在屏幕上显示职业是 \",[\"$r\",\"code\",null,{\"children\":\"化学家\"}],\" 的人。那么你可以使用 JavaScript 的 \",[\"$r\",\"code\",null,{\"children\":\"filter()\"}],\" 方法来返回满足条件的项。这个方法会让数组的子项经过 “过滤器”（一个返回值为 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\" 的函数）的筛选，最终返回一个只包含满足条件的项的新数组。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"既然你只想显示 \",[\"$r\",\"code\",null,{\"children\":\"profession\"}],\" 值是 \",[\"$r\",\"code\",null,{\"children\":\"化学家\"}],\" 的人，那么这里的 “过滤器” 函数应该长这样：\",[\"$r\",\"code\",null,{\"children\":\"(person) => person.profession === '化学家'\"}],\"。下面我们来看看该怎么把它们组合在一起：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"首先，\",[\"$r\",\"strong\",null,{\"children\":\"创建\"}],\" 一个用来存化学家们的新数组 \",[\"$r\",\"code\",null,{\"children\":\"chemists\"}],\"，这里用到 \",[\"$r\",\"code\",null,{\"children\":\"filter()\"}],\" 方法过滤 \",[\"$r\",\"code\",null,{\"children\":\"people\"}],\" 数组来得到所有的化学家，过滤的条件应该是 \",[\"$r\",\"code\",null,{\"children\":\"person.profession === '化学家'\"}],\"：\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const chemists = people.filter(person =>\\n  person.profession === '化学家'\\n);\\n\"}]}],\"\\n\",[\"$r\",\"ol\",null,{\"start\":\"2\",\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"接下来 \",[\"$r\",\"strong\",null,{\"children\":\"用 map 方法遍历\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"chemists\"}],\" 数组:\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,13}\",\"children\":\"const listItems = chemists.map(person =>\\n  <li>\\n     <img\\n       src={getImageUrl(person)}\\n       alt={person.name}\\n     />\\n     <p>\\n       <b>{person.name}:</b>\\n       {' ' + person.profession + ' '}\\n       因{person.accomplishment}而闻名世界\\n     </p>\\n  </li>\\n);\\n\"}]}],\"\\n\",[\"$r\",\"ol\",null,{\"start\":\"3\",\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"最后，\",[\"$r\",\"strong\",null,{\"children\":\"返回\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"listItems\"}],\"：\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"return <ul>{listItems}</ul>;\\n\"}]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { people } from './data.js';\\nimport { getImageUrl } from './utils.js';\\n\\nexport default function List() {\\n  const chemists = people.filter(person =>\\n    person.profession === '化学家'\\n  );\\n  const listItems = chemists.map(person =>\\n    <li>\\n      <img\\n        src={getImageUrl(person)}\\n        alt={person.name}\\n      />\\n      <p>\\n        <b>{person.name}:</b>\\n        {' ' + person.profession + ' '}\\n        因{person.accomplishment}而闻名世界\\n      </p>\\n    </li>\\n  );\\n  return <ul>{listItems}</ul>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const people = [\\n  {\\n    id: 0,\\n    name: '凯瑟琳·约翰逊',\\n    profession: '数学家',\\n    accomplishment: '太空飞行相关数值的核算',\\n    imageId: 'MK3eW3A',\\n  },\\n  {\\n    id: 1,\\n    name: '马里奥·莫利纳',\\n    profession: '化学家',\\n    accomplishment: '北极臭氧空洞的发现',\\n    imageId: 'mynHUSa',\\n  },\\n  {\\n    id: 2,\\n    name: '穆罕默德·阿卜杜勒·萨拉姆',\\n    profession: '物理学家',\\n    accomplishment: '关于基本粒子间弱相互作用和电磁相互作用的统一理论',\\n    imageId: 'bE7W1ji',\\n  },\\n  {\\n    id: 3,\\n    name: '珀西·莱温·朱利亚',\\n    profession: '化学家',\\n    accomplishment: '开创性的可的松药物、类固醇和避孕药的研究',\\n    imageId: 'IOjWm71',\\n  },\\n  {\\n    id: 4,\\n    name: '苏布拉马尼扬·钱德拉塞卡',\\n    profession: '天体物理学家',\\n    accomplishment: '白矮星质量计算',\\n    imageId: 'lrWQx8l',\\n  },\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/utils.js\",\"children\":\"export function getImageUrl(person) {\\n  return (\\n    'https://i.imgur.com/' +\\n    person.imageId +\\n    's.jpg'\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul { list-style-type: none; padding: 0px 10px; }\\nli { \\n  margin-bottom: 10px; \\n  display: grid; \\n  grid-template-columns: auto 1fr;\\n  gap: 20px;\\n  align-items: center;\\n}\\nimg { width: 100px; height: 100px; border-radius: 50%; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"78\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"因为箭头函数会隐式地返回位于 \",[\"$r\",\"code\",null,{\"children\":\"=>\"}],\" 之后的表达式，所以你可以省略 \",[\"$r\",\"code\",null,{\"children\":\"return\"}],\" 语句。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const listItems = chemists.map(person =>\\n  <li>...</li> // 隐式地返回！\\n);\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"不过，\",[\"$r\",\"strong\",null,{\"children\":[\"如果你的 \",[\"$r\",\"code\",null,{\"children\":\"=>\"}],\" 后面跟了一对花括号 \",[\"$r\",\"code\",null,{\"children\":\"{\"}],\" ，那你必须使用 \",[\"$r\",\"code\",null,{\"children\":\"return\"}],\" 来指定返回值！\"]}]]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const listItems = chemists.map(person => { // 花括号\\n  return <li>...</li>;\\n});\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"箭头函数 \",[\"$r\",\"code\",null,{\"children\":\"=> {\"}],\" 后面的部分被称为 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#function_body\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"“块函数体”\"}],\"，块函数体支持多行代码的写法，但要用 \",[\"$r\",\"code\",null,{\"children\":\"return\"}],\" 语句才能指定返回值。假如你忘了写 \",[\"$r\",\"code\",null,{\"children\":\"return\"}],\"，那这个函数什么都不会返回！\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"keeping-list-items-in-order-with-key\",\"children\":[\"用 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 保持列表项的顺序 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果把上面任何一个沙盒示例在新标签页打开，你就会发现控制台有这样一个报错：\"}],\"\\n\",[\"$r\",\"ConsoleBlock\",null,{\"level\":\"error\",\"children\":[\"$r\",\"p\",null,{\"children\":\"Warning: Each child in a list should have a unique “key” prop.\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这是因为你必须给数组中的每一项都指定一个 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"——它可以是字符串或数字的形式，只要能唯一标识出各个数组项就行：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<li key={person.id}>...</li>\\n\"}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"直接放在 \",[\"$r\",\"code\",null,{\"children\":\"map()\"}],\" 方法里的 JSX 元素一般都需要指定 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 值！\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这些 key 会告诉 React，每个组件对应着数组里的哪一项，所以 React 可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 可以帮助 React 推断发生了什么，从而得以正确地更新 DOM 树。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"用作 key 的值应该在数据中提前就准备好，而不是在运行时才随手生成：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { people } from './data.js';\\nimport { getImageUrl } from './utils.js';\\n\\nexport default function List() {\\n  const listItems = people.map(person =>\\n    <li key={person.id}>\\n      <img\\n        src={getImageUrl(person)}\\n        alt={person.name}\\n      />\\n      <p>\\n        <b>{person.name}</b>\\n          {' ' + person.profession + ' '}\\n          因{person.accomplishment}而闻名世界\\n      </p>\\n    </li>\\n  );\\n  return <ul>{listItems}</ul>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js active\",\"children\":\"export const people = [\\n  {\\n    id: 0, // 在 JSX 中作为 key 使用\\n    name: '凯瑟琳·约翰逊',\\n    profession: '数学家',\\n    accomplishment: '太空飞行相关数值的核算',\\n    imageId: 'MK3eW3A',\\n  },\\n  {\\n    id: 1, // 在 JSX 中作为 key 使用\\n    name: '马里奥·莫利纳',\\n    profession: '化学家',\\n    accomplishment: '北极臭氧空洞的发现',\\n    imageId: 'mynHUSa',\\n  },\\n  {\\n    id: 2, // 在 JSX 中作为 key 使用\\n    name: '穆罕默德·阿卜杜勒·萨拉姆',\\n    profession: '物理学家',\\n    accomplishment: '关于基本粒子间弱相互作用和电磁相互作用的统一理论',\\n    imageId: 'bE7W1ji',\\n  },\\n  {\\n    id: 3, // 在 JSX 中作为 key 使用\\n    name: '珀西·莱温·朱利亚',\\n    profession: '化学家',\\n    accomplishment: '开创性的可的松药物、类固醇和避孕药',\\n    imageId: 'IOjWm71',\\n  },\\n  {\\n    id: 4, // 在 JSX 中作为 key 使用\\n    name: '苏布拉马尼扬·钱德拉塞卡',\\n    profession: '天体物理学家',\\n    accomplishment: '白矮星质量计算',\\n    imageId: 'lrWQx8l',\\n  },\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/utils.js\",\"children\":\"export function getImageUrl(person) {\\n  return (\\n    'https://i.imgur.com/' +\\n    person.imageId +\\n    's.jpg'\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul { list-style-type: none; padding: 0px 10px; }\\nli { \\n  margin-bottom: 10px; \\n  display: grid; \\n  grid-template-columns: auto 1fr;\\n  gap: 20px;\\n  align-items: center;\\n}\\nimg { width: 100px; height: 100px; border-radius: 50%; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"102\",{\"children\":[\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"displaying-several-dom-nodes-for-each-list-item\",\"children\":\"为每个列表项显示多个 DOM 节点 \"}],[\"$r\",\"p\",null,{\"children\":\"如果你想让每个列表项都输出多个 DOM 节点而非一个的话，该怎么做呢？\"}],[\"$r\",\"p\",null,{\"children\":[\"Fragment 语法的简写形式 \",[\"$r\",\"code\",null,{\"children\":\"<> </>\"}],\" 无法接受 key 值，所以你只能要么把生成的节点用一个 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 标签包裹起来，要么使用长一点但更明确的 \",[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\" 写法：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Fragment } from 'react';\\n\\n// ...\\n\\nconst listItems = people.map(person =>\\n  <Fragment key={person.id}>\\n    <h1>{person.name}</h1>\\n    <p>{person.bio}</p>\\n  </Fragment>\\n);\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"这里的 Fragment 标签本身并不会出现在 DOM 上，这串代码最终会转换成 \",[\"$r\",\"code\",null,{\"children\":\"<h1>\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"<h1>\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\"…… 的列表。\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"where-to-get-your-key\",\"children\":[\"如何设定 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 值 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"不同来源的数据往往对应不同的 key 值获取方式：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"来自数据库的数据：\"}],\" 如果你的数据是从数据库中获取的，那你可以直接使用数据表中的主键，因为它们天然具有唯一性。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"本地产生数据：\"}],\" 如果你数据的产生和保存都在本地（例如笔记软件里的笔记），那么你可以使用一个自增计数器或者一个类似 \",[\"$r\",\"a\",null,{\"href\":\"https://www.npmjs.com/package/uuid\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"uuid\"}]}],\" 的库来生成 key。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rules-of-keys\",\"children\":\"key 需要满足的条件 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"key 值在兄弟节点之间必须是唯一的。\"}],\" 不过不要求全局唯一，在不同的数组中可以使用相同的 key。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"key 值不能改变\"}],\"，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"why-does-react-need-keys\",\"children\":\"React 中为什么需要 key？ \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 值也能让 React 在整个生命周期中一直认得它。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"你可能会想直接把数组项的索引当作 key 值来用，实际上，如果你没有显式地指定 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 值，React 确实默认会这么做。但是数组项的顺序在插入、删除或者重新排序等操作中会发生改变，此时把索引顺序用作 key 值会产生一些微妙且令人困惑的 bug。\"]}],[\"$r\",\"p\",null,{\"children\":[\"与之类似，请不要在运行过程中动态地产生 key，像是 \",[\"$r\",\"code\",null,{\"children\":\"key={Math.random()}\"}],\" 这种方式。这会导致每次重新渲染后的 key 值都不一样，从而使得所有的组件和 DOM 元素每次都要重新创建。这不仅会造成运行变慢的问题，更有可能导致用户输入的丢失。所以，使用能从给定数据中稳定取得的值才是明智的选择。\"]}],[\"$r\",\"p\",null,{\"children\":[\"有一点需要注意，组件不会把 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 当作 props 的一部分。Key 的存在只对 React 本身起到提示作用。如果你的组件需要一个 ID，那么请把它作为一个单独的 prop 传给组件： \",[\"$r\",\"code\",null,{\"children\":\"<Profile key={id} userId={id} />\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"在这篇文章中，你学习了：\"}],[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何从组件中抽离出数据，并把它们放入像数组、对象这样的数据结构中。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如何使用 JavaScript 的 \",[\"$r\",\"code\",null,{\"children\":\"map()\"}],\" 方法来生成一组相似的组件。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如何使用 JavaScript 的 \",[\"$r\",\"code\",null,{\"children\":\"filter()\"}],\" 方法来筛选数组。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"为何以及如何给集合中的每个组件设置一个 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 值：它使 React 能追踪这些组件，即便后者的位置或数据发生了变化。\"]}],\"\\n\"]}]]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"splitting-a-list-in-two\",\"children\":\"把列表一分为二 \"}],[\"$r\",\"p\",null,{\"children\":\"下面的示例中有一个包含所有人员信息的列表。\"}],[\"$r\",\"p\",null,{\"children\":[\"请试着把它分成一前一后的两个列表：分别是 \",[\"$r\",\"strong\",null,{\"children\":\"化学家们\"}],\" 和 \",[\"$r\",\"strong\",null,{\"children\":\"其余的人\"}],\"。像之前一样，你可以通过 \",[\"$r\",\"code\",null,{\"children\":\"person.profession === '化学家'\"}],\" 这个条件来判断一个人是不是化学家。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { people } from './data.js';\\nimport { getImageUrl } from './utils.js';\\n\\nexport default function List() {\\n  const listItems = people.map(person =>\\n    <li key={person.id}>\\n      <img\\n        src={getImageUrl(person)}\\n        alt={person.name}\\n      />\\n      <p>\\n        <b>{person.name}:</b>\\n        {' ' + person.profession + ' '}\\n        因{person.accomplishment}而闻名世界\\n      </p>\\n    </li>\\n  );\\n  return (\\n    <article>\\n      <h1>科学家</h1>\\n      <ul>{listItems}</ul>\\n    </article>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const people = [\\n  {\\n    id: 0,\\n    name: '凯瑟琳·约翰逊',\\n    profession: '数学家',\\n    accomplishment: '太空飞行相关数值的核算',\\n    imageId: 'MK3eW3A',\\n  },\\n  {\\n    id: 1,\\n    name: '马里奥·莫利纳',\\n    profession: '化学家',\\n    accomplishment: '北极臭氧空洞的发现',\\n    imageId: 'mynHUSa',\\n  },\\n  {\\n    id: 2,\\n    name: '穆罕默德·阿卜杜勒·萨拉姆',\\n    profession: '物理学家',\\n    accomplishment: '关于基本粒子间弱相互作用和电磁相互作用的统一理论',\\n    imageId: 'bE7W1ji',\\n  },\\n  {\\n    id: 3,\\n    name: '珀西·莱温·朱利亚',\\n    profession: '化学家',\\n    accomplishment: '开创性的可的松药物、类固醇和避孕药',\\n    imageId: 'IOjWm71',\\n  },\\n  {\\n    id: 4,\\n    name: '苏布拉马尼扬·钱德拉塞卡',\\n    profession: '天体物理学家',\\n    accomplishment: '白矮星质量计算',\\n    imageId: 'lrWQx8l',\\n  },\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/utils.js\",\"children\":\"export function getImageUrl(person) {\\n  return (\\n    'https://i.imgur.com/' +\\n    person.imageId +\\n    's.jpg'\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul { list-style-type: none; padding: 0px 10px; }\\nli {\\n  margin-bottom: 10px;\\n  display: grid;\\n  grid-template-columns: auto 1fr;\\n  gap: 20px;\\n  align-items: center;\\n}\\nimg { width: 100px; height: 100px; border-radius: 50%; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"使用两次 \",[\"$r\",\"code\",null,{\"children\":\"filter()\"}],\" 方法来获得两个单独的数组，然后用 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\" 方法分别遍历它们来得到结果。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { people } from './data.js';\\nimport { getImageUrl } from './utils.js';\\n\\nexport default function List() {\\n  const chemists = people.filter(person =>\\n    person.profession === '化学家'\\n  );\\n  const everyoneElse = people.filter(person =>\\n    person.profession !== '化学家'\\n  );\\n  return (\\n    <article>\\n      <h1>科学家</h1>\\n      <h2>化学家</h2>\\n      <ul>\\n        {chemists.map(person =>\\n          <li key={person.id}>\\n            <img\\n              src={getImageUrl(person)}\\n              alt={person.name}\\n            />\\n            <p>\\n              <b>{person.name}:</b>\\n              {' ' + person.profession + ' '}\\n              因{person.accomplishment}而闻名世界\\n            </p>\\n          </li>\\n        )}\\n      </ul>\\n      <h2>其余的人</h2>\\n      <ul>\\n        {everyoneElse.map(person =>\\n          <li key={person.id}>\\n            <img\\n              src={getImageUrl(person)}\\n              alt={person.name}\\n            />\\n            <p>\\n              <b>{person.name}:</b>\\n              {' ' + person.profession + ' '}\\n              因{person.accomplishment}而闻名世界\\n            </p>\\n          </li>\\n        )}\\n      </ul>\\n    </article>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const people = [\\n  {\\n    id: 0,\\n    name: '凯瑟琳·约翰逊',\\n    profession: '数学家',\\n    accomplishment: '太空飞行相关数值的核算',\\n    imageId: 'MK3eW3A',\\n  },\\n  {\\n    id: 1,\\n    name: '马里奥·莫利纳',\\n    profession: '化学家',\\n    accomplishment: '北极臭氧空洞的发现',\\n    imageId: 'mynHUSa',\\n  },\\n  {\\n    id: 2,\\n    name: '穆罕默德·阿卜杜勒·萨拉姆',\\n    profession: '物理学家',\\n    accomplishment: '关于基本粒子间弱相互作用和电磁相互作用的统一理论',\\n    imageId: 'bE7W1ji',\\n  },\\n  {\\n    id: 3,\\n    name: '珀西·莱温·朱利亚',\\n    profession: '化学家',\\n    accomplishment: '开创性的可的松药物、类固醇和避孕药',\\n    imageId: 'IOjWm71',\\n  },\\n  {\\n    id: 4,\\n    name: '苏布拉马尼扬·钱德拉塞卡',\\n    profession: '天体物理学家',\\n    accomplishment: '白矮星质量计算',\\n    imageId: 'lrWQx8l',\\n  },\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/utils.js\",\"children\":\"export function getImageUrl(person) {\\n  return (\\n    'https://i.imgur.com/' +\\n    person.imageId +\\n    's.jpg'\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul { list-style-type: none; padding: 0px 10px; }\\nli {\\n  margin-bottom: 10px;\\n  display: grid;\\n  grid-template-columns: auto 1fr;\\n  gap: 20px;\\n  align-items: center;\\n}\\nimg { width: 100px; height: 100px; border-radius: 50%; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"这个解决方案中，我们直接在父级的 \",[\"$r\",\"code\",null,{\"children\":\"<ul>\"}],\" 元素里就执行了 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\" 方法。当然如果你想提高代码的可读性，你也可以先用变量保存一下 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\" 之后的结果。\"]}],[\"$r\",\"p\",null,{\"children\":[\"现在得到的列表中仍然存在一些重复的代码，我们可以更进一步，将这些重复的部分提取成一个 \",[\"$r\",\"code\",null,{\"children\":\"<ListSection>\"}],\" 组件：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { people } from './data.js';\\nimport { getImageUrl } from './utils.js';\\n\\nfunction ListSection({ title, people }) {\\n  return (\\n    <>\\n      <h2>{title}</h2>\\n      <ul>\\n        {people.map(person =>\\n          <li key={person.id}>\\n            <img\\n              src={getImageUrl(person)}\\n              alt={person.name}\\n            />\\n            <p>\\n              <b>{person.name}:</b>\\n              {' ' + person.profession + ' '}\\n              因{person.accomplishment}而闻名世界\\n            </p>\\n          </li>\\n        )}\\n      </ul>\\n    </>\\n  );\\n}\\n\\nexport default function List() {\\n  const chemists = people.filter(person =>\\n    person.profession === '化学家'\\n  );\\n  const everyoneElse = people.filter(person =>\\n    person.profession !== '化学家'\\n  );\\n  return (\\n    <article>\\n      <h1>科学家</h1>\\n      <ListSection\\n        title=\\\"化学家\\\"\\n        people={chemists}\\n      />\\n      <ListSection\\n      title=\\\"其余的人\\\"\\n      people={everyoneElse} \\n      />\\n    </article>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const people = [\\n  {\\n    id: 0,\\n    name: '凯瑟琳·约翰逊',\\n    profession: '数学家',\\n    accomplishment: '太空飞行相关数值的核算',\\n    imageId: 'MK3eW3A',\\n  },\\n  {\\n    id: 1,\\n    name: '马里奥·莫利纳',\\n    profession: '化学家',\\n    accomplishment: '北极臭氧空洞的发现',\\n    imageId: 'mynHUSa',\\n  },\\n  {\\n    id: 2,\\n    name: '穆罕默德·阿卜杜勒·萨拉姆',\\n    profession: '物理学家',\\n    accomplishment: '关于基本粒子间弱相互作用和电磁相互作用的统一理论',\\n    imageId: 'bE7W1ji',\\n  },\\n  {\\n    id: 3,\\n    name: '珀西·莱温·朱利亚',\\n    profession: '化学家',\\n    accomplishment: '开创性的可的松药物、类固醇和避孕药',\\n    imageId: 'IOjWm71',\\n  },\\n  {\\n    id: 4,\\n    name: '苏布拉马尼扬·钱德拉塞卡',\\n    profession: '天体物理学家',\\n    accomplishment: '白矮星质量计算',\\n    imageId: 'lrWQx8l',\\n  },\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/utils.js\",\"children\":\"export function getImageUrl(person) {\\n  return (\\n    'https://i.imgur.com/' +\\n    person.imageId +\\n    's.jpg'\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul { list-style-type: none; padding: 0px 10px; }\\nli {\\n  margin-bottom: 10px;\\n  display: grid;\\n  grid-template-columns: auto 1fr;\\n  gap: 20px;\\n  align-items: center;\\n}\\nimg { width: 100px; height: 100px; border-radius: 50%; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"仔细的读者会发现我们在这写了两个 \",[\"$r\",\"code\",null,{\"children\":\"filter\"}],\"，对于每个人的职业我们都进行了两次过滤。读取一个属性的值花不了多少时间，因此放在这个简单的示例中没什么大问题。但是如果你的代码逻辑比这里复杂和“昂贵”得多，那你可以把两次的 \",[\"$r\",\"code\",null,{\"children\":\"filter\"}],\" 替换成一个只需进行一次检查就能构造两个数组的循环。\"]}],[\"$r\",\"p\",null,{\"children\":[\"实际上，如果 \",[\"$r\",\"code\",null,{\"children\":\"people\"}],\" 的数据不会改变，可以直接把这段代码移到组件外面。从 React 的视角来看，它只关心你最后给它的是不是包含 JSX 节点的数组，并不在乎数组是怎么来的：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { people } from './data.js';\\nimport { getImageUrl } from './utils.js';\\n\\nlet chemists = [];\\nlet everyoneElse = [];\\npeople.forEach(person => {\\n  if (person.profession === '化学家') {\\n    chemists.push(person);\\n  } else {\\n    everyoneElse.push(person);\\n  }\\n});\\n\\nfunction ListSection({ title, people }) {\\n  return (\\n    <>\\n      <h2>{title}</h2>\\n      <ul>\\n        {people.map(person =>\\n          <li key={person.id}>\\n            <img\\n              src={getImageUrl(person)}\\n              alt={person.name}\\n            />\\n            <p>\\n              <b>{person.name}:</b>\\n              {' ' + person.profession + ' '}\\n              因{person.accomplishment}而闻名世界\\n            </p>\\n          </li>\\n        )}\\n      </ul>\\n    </>\\n  );\\n}\\n\\nexport default function List() {\\n  return (\\n    <article>\\n      <h1>科学家</h1>\\n      <ListSection\\n        title=\\\"化学家\\\"\\n        people={chemists}\\n      />\\n      <ListSection\\n        title=\\\"其余的人\\\"\\n        people={everyoneElse}\\n      />\\n    </article>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const people = [\\n  {\\n    id: 0,\\n    name: '凯瑟琳·约翰逊',\\n    profession: '数学家',\\n    accomplishment: '太空飞行相关数值的核算',\\n    imageId: 'MK3eW3A',\\n  },\\n  {\\n    id: 1,\\n    name: '马里奥·莫利纳',\\n    profession: '化学家',\\n    accomplishment: '北极臭氧空洞的发现',\\n    imageId: 'mynHUSa',\\n  },\\n  {\\n    id: 2,\\n    name: '穆罕默德·阿卜杜勒·萨拉姆',\\n    profession: '物理学家',\\n    accomplishment: '关于基本粒子间弱相互作用和电磁相互作用的统一理论',\\n    imageId: 'bE7W1ji',\\n  },\\n  {\\n    id: 3,\\n    name: '珀西·莱温·朱利亚',\\n    profession: '化学家',\\n    accomplishment: '开创性的可的松药物、类固醇和避孕药',\\n    imageId: 'IOjWm71',\\n  },\\n  {\\n    id: 4,\\n    name: '苏布拉马尼扬·钱德拉塞卡',\\n    profession: '天体物理学家',\\n    accomplishment: '白矮星质量计算',\\n    imageId: 'lrWQx8l',\\n  },\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/utils.js\",\"children\":\"export function getImageUrl(person) {\\n  return (\\n    'https://i.imgur.com/' +\\n    person.imageId +\\n    's.jpg'\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"ul { list-style-type: none; padding: 0px 10px; }\\nli {\\n  margin-bottom: 10px;\\n  display: grid;\\n  grid-template-columns: auto 1fr;\\n  gap: 20px;\\n  align-items: center;\\n}\\nimg { width: 100px; height: 100px; border-radius: 50%; }\\n\"}]}]]}]]}],[\"$r\",\"h4\",null,{\"id\":\"nested-lists-in-one-component\",\"children\":\"嵌套列表 \"}],[\"$r\",\"p\",null,{\"children\":[\"请根据给你的数组生成菜谱列表！其中每个菜谱，都用 \",[\"$r\",\"code\",null,{\"children\":\"<h2>\"}],\" 来显示它的名称，并在 \",[\"$r\",\"code\",null,{\"children\":\"<ul>\"}],\" 里列出它所需的原料。\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"这里的写法需要嵌套两层 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\"。\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { recipes } from './data.js';\\n\\nexport default function RecipeList() {\\n  return (\\n    <div>\\n      <h1>菜谱</h1>\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const recipes = [\\n  {\\n    id: 'greek-salad',\\n    name: '希腊沙拉',\\n    ingredients: ['西红柿', '黄瓜', '洋葱', '油橄榄', '羊奶酪'],\\n  },\\n  {\\n    id: 'hawaiian-pizza',\\n    name: '夏威夷披萨',\\n    ingredients: ['披萨饼皮', '披萨酱', '马苏里拉奶酪', '火腿', '菠萝'],\\n  },\\n  {\\n    id: 'hummus',\\n    name: '鹰嘴豆泥',\\n    ingredients: ['鹰嘴豆', '橄榄油', '蒜瓣', '柠檬', '芝麻酱'],\\n  },\\n];\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"这是一种可能的解法：\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { recipes } from './data.js';\\n\\nexport default function RecipeList() {\\n  return (\\n    <div>\\n      <h1>菜谱</h1>\\n      {recipes.map(recipe =>\\n        <div key={recipe.id}>\\n          <h2>{recipe.name}</h2>\\n          <ul>\\n            {recipe.ingredients.map(ingredient =>\\n              <li key={ingredient}>\\n                {ingredient}\\n              </li>\\n            )}\\n          </ul>\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const recipes = [\\n  {\\n    id: 'greek-salad',\\n    name: '希腊沙拉',\\n    ingredients: ['西红柿', '黄瓜', '洋葱', '油橄榄', '羊奶酪'],\\n  },\\n  {\\n    id: 'hawaiian-pizza',\\n    name: '夏威夷披萨',\\n    ingredients: ['披萨饼皮', '披萨酱', '马苏里拉奶酪', '火腿', '菠萝'],\\n  },\\n  {\\n    id: 'hummus',\\n    name: '鹰嘴豆泥',\\n    ingredients: ['鹰嘴豆', '橄榄油', '蒜瓣', '柠檬', '芝麻酱'],\\n  },\\n];\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"recipes\"}],\" 数组中每一项都拥有一个 \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\"，所以外层的循环可以直接拿它作为 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"。不过，在循环遍历原料的时候就没有现成的 \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\" 可以用了。但是，合理推测一下，一份菜谱里不会罗列多次同一种原料，所以其实原料的名字就适合作为 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"。此外，你也可以自行修改原本的数据人为增加一项 \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\"，或是使用索引作为 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"（需要注意的是，这么做会使你无法正常地对原料进行排序）。\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"extracting-a-list-item-component\",\"children\":\"把列表项提取成一个组件 \"}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"RecipeList\"}],\" 组件的代码里嵌套了两层 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\"。出于简化代码的考虑，我们提取出一个接受 \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"name\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"ingredients\"}],\" 作为 props 的 \",[\"$r\",\"code\",null,{\"children\":\"Recipe\"}],\" 组件。这种情况下，你会把外层的 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 放在哪里呢？原因是什么？\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { recipes } from './data.js';\\n\\nexport default function RecipeList() {\\n  return (\\n    <div>\\n      <h1>菜谱</h1>\\n      {recipes.map(recipe =>\\n        <div key={recipe.id}>\\n          <h2>{recipe.name}</h2>\\n          <ul>\\n            {recipe.ingredients.map(ingredient =>\\n              <li key={ingredient}>\\n                {ingredient}\\n              </li>\\n            )}\\n          </ul>\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const recipes = [\\n  {\\n    id: 'greek-salad',\\n    name: '希腊沙拉',\\n    ingredients: ['西红柿', '黄瓜', '洋葱', '油橄榄', '羊奶酪'],\\n  },\\n  {\\n    id: 'hawaiian-pizza',\\n    name: '夏威夷披萨',\\n    ingredients: ['披萨饼皮', '披萨酱', '马苏里拉奶酪', '火腿', '菠萝'],\\n  },\\n  {\\n    id: 'hummus',\\n    name: '鹰嘴豆泥',\\n    ingredients: ['鹰嘴豆', '橄榄油', '蒜瓣', '柠檬', '芝麻酱'],\\n  },\\n];\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"你可以将外层 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\" 里的 JSX 复制粘贴到新的 \",[\"$r\",\"code\",null,{\"children\":\"Recipe\"}],\" 组件中，并作为这个新组件的返回值。接着把原先的 \",[\"$r\",\"code\",null,{\"children\":\"recipe.name\"}],\" 改成 \",[\"$r\",\"code\",null,{\"children\":\"name\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"recipe.id\"}],\" 改成 \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\"，以此类推，最后把它们作为 props 传给 \",[\"$r\",\"code\",null,{\"children\":\"Recipe\"}],\"：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { recipes } from './data.js';\\n\\nfunction Recipe({ id, name, ingredients }) {\\n  return (\\n    <div>\\n      <h2>{name}</h2>\\n      <ul>\\n        {ingredients.map(ingredient =>\\n          <li key={ingredient}>\\n            {ingredient}\\n          </li>\\n        )}\\n      </ul>\\n    </div>\\n  );\\n}\\n\\nexport default function RecipeList() {\\n  return (\\n    <div>\\n      <h1>菜谱</h1>\\n      {recipes.map(recipe =>\\n        <Recipe {...recipe} key={recipe.id} />\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/data.js\",\"children\":\"export const recipes = [\\n  {\\n    id: 'greek-salad',\\n    name: '希腊沙拉',\\n    ingredients: ['西红柿', '黄瓜', '洋葱', '油橄榄', '羊奶酪'],\\n  },\\n  {\\n    id: 'hawaiian-pizza',\\n    name: '夏威夷披萨',\\n    ingredients: ['披萨饼皮', '披萨酱', '马苏里拉奶酪', '火腿', '菠萝'],\\n  },\\n  {\\n    id: 'hummus',\\n    name: '鹰嘴豆泥',\\n    ingredients: ['鹰嘴豆', '橄榄油', '蒜瓣', '柠檬', '芝麻酱'],\\n  },\\n];\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"这里的 \",[\"$r\",\"code\",null,{\"children\":\"<Recipe {...recipe} key={recipe.id} />\"}],\" 是一种简写方式，它表示“把 \",[\"$r\",\"code\",null,{\"children\":\"recipe\"}],\" 对象里的每个属性都作为 props 传给 \",[\"$r\",\"code\",null,{\"children\":\"Recipe\"}],\" 组件”。这和直接写明每一个 prop 是等价的：\",[\"$r\",\"code\",null,{\"children\":\"<Recipe id={recipe.id} name={recipe.name} ingredients={recipe.ingredients} key={recipe.id} />\"}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"注意这里的 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 是写在 \",[\"$r\",\"code\",null,{\"children\":\"<Recipe>\"}],\" 组件本身上的，不要写在 \",[\"$r\",\"code\",null,{\"children\":\"Recipe\"}],\" 内部返回的 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 上。\"]}],\" 这是因为 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 只有在就近的数组上下文中才有意义。之前的写法里，我们生成了一个 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 的数组所以其中的每一项需要一个 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"，但是现在的写法里，生成的实际上是 \",[\"$r\",\"code\",null,{\"children\":\"<Recipe>\"}],\" 的数组。换句话说，在提取组件的时候，\",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 应该写在复制粘贴的 JSX 的外层组件上。\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"list-with-a-separator\",\"children\":\"带有分隔符的列表 \"}],[\"$r\",\"p\",null,{\"children\":[\"下面这个示例展示了立花北枝一首著名的俳句，它的每一行都由 \",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\" 标签包裹。你需要在段落之间插入分隔符 \",[\"$r\",\"code\",null,{\"children\":\"<hr />\"}],\"，最终的结果大概像这样：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<article>\\n  <p>I write, erase, rewrite</p>\\n  <hr />\\n  <p>Erase again, and then</p>\\n  <hr />\\n  <p>A poppy blooms.</p>\\n</article>\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"一首俳句通常只有三行，但是你的解答应当适用于任何行数。注意，\",[\"$r\",\"code\",null,{\"children\":\"<hr />\"}],\" 元素只应该在 \",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\" 元素 \",[\"$r\",\"strong\",null,{\"children\":\"之间\"}],\" 出现，而不是在开头或结尾。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const poem = {\\n  lines: [\\n    'I write, erase, rewrite',\\n    'Erase again, and then',\\n    'A poppy blooms.'\\n  ]\\n};\\n\\nexport default function Poem() {\\n  return (\\n    <article>\\n      {poem.lines.map((line, index) =>\\n        <p key={index}>\\n          {line}\\n        </p>\\n      )}\\n    </article>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body {\\n  text-align: center;\\n}\\np {\\n  font-family: Georgia, serif;\\n  font-size: 20px;\\n  font-style: italic;\\n}\\nhr {\\n  margin: 0 120px 0 120px;\\n  border: 1px dashed #45c3d8;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":\"（这是一个比较少见的可以把数组索引用作 key 的例子，因为诗句之间的顺序必然是固定的。）\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"你可以尝试把原本的 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\" 改造成手动循环，或者试下 Fragment 语法。\"]}]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"可以写一个循环，在循环的过程中把 \",[\"$r\",\"code\",null,{\"children\":\"<hr />\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"<p>...</p>\"}],\" 插入到输出的数组：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const poem = {\\n  lines: [\\n    'I write, erase, rewrite',\\n    'Erase again, and then',\\n    'A poppy blooms.'\\n  ]\\n};\\n\\nexport default function Poem() {\\n  let output = [];\\n\\n  // 填充输出的数组\\n  poem.lines.forEach((line, i) => {\\n    output.push(\\n      <hr key={i + '-separator'} />\\n    );\\n    output.push(\\n      <p key={i + '-text'}>\\n        {line}\\n      </p>\\n    );\\n  });\\n  // 移除第一个 <hr />\\n  output.shift();\\n\\n  return (\\n    <article>\\n      {output}\\n    </article>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body {\\n  text-align: center;\\n}\\np {\\n  font-family: Georgia, serif;\\n  font-size: 20px;\\n  font-style: italic;\\n}\\nhr {\\n  margin: 0 120px 0 120px;\\n  border: 1px dashed #45c3d8;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"原本使用诗句顺序索引作为 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 的方法已经行不通了，因为现在数组里同时包含了分隔符和诗句。但是，你可以用添加后缀的形式给它们赋予独一无二的 key 值，比如 \",[\"$r\",\"code\",null,{\"children\":\"key={i + '-text'}\"}],\" 这样。\"]}],[\"$r\",\"p\",null,{\"children\":[\"另一种做法是，生成包含 \",[\"$r\",\"code\",null,{\"children\":\"<hr />\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"<p>...</p>\"}],\" 的 Fragment 集合，但因其简写语法 \",[\"$r\",\"code\",null,{\"children\":\"<> </>\"}],\" 不支持指定 key，所以需要写成 \",[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\" 的形式。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Fragment } from 'react';\\n\\nconst poem = {\\n  lines: [\\n    'I write, erase, rewrite',\\n    'Erase again, and then',\\n    'A poppy blooms.'\\n  ]\\n};\\n\\nexport default function Poem() {\\n  return (\\n    <article>\\n      {poem.lines.map((line, i) =>\\n        <Fragment key={i}>\\n          {i > 0 && <hr />}\\n          <p>{line}</p>\\n        </Fragment>\\n      )}\\n    </article>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body {\\n  text-align: center;\\n}\\np {\\n  font-family: Georgia, serif;\\n  font-size: 20px;\\n  font-style: italic;\\n}\\nhr {\\n  margin: 0 120px 0 120px;\\n  border: 1px dashed #45c3d8;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"记住，使用 Fragment 语法（通常写作 \",[\"$r\",\"code\",null,{\"children\":\"<> </>\"}],\"）来包裹 JSX 节点可以避免引入额外的 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 元素！\"]}]]}]]}]]","meta":{"title":"渲染列表","translator":["Megrax","rottenpen"]}},"__N_SSG":true}