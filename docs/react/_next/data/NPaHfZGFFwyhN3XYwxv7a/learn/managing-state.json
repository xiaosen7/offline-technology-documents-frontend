{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reacting-to-input-with-state\",\"depth\":2,\"text\":\"使用状态响应输入 \"},{\"url\":\"#choosing-the-state-structure\",\"depth\":2,\"text\":\"选择状态结构 \"},{\"url\":\"#sharing-state-between-components\",\"depth\":2,\"text\":\"在组件间共享状态 \"},{\"url\":\"#preserving-and-resetting-state\",\"depth\":2,\"text\":\"保留和重置状态 \"},{\"url\":\"#extracting-state-logic-into-a-reducer\",\"depth\":2,\"text\":\"提取状态逻辑到 reducer 中 \"},{\"url\":\"#passing-data-deeply-with-context\",\"depth\":2,\"text\":\"使用 Context 进行深层数据传递 \"},{\"url\":\"#scaling-up-with-reducer-and-context\",\"depth\":2,\"text\":\"使用 Reducer 和 Context 进行状态扩展 \"},{\"url\":\"#whats-next\",\"depth\":2,\"text\":\"下节预告 \"}]","content":"[[\"$r\",\"MaxWidth\",\"10\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"随着你的应用不断变大，更有意识的去关注应用状态如何组织，以及数据如何在组件之间流动会对你很有帮助。冗余或重复的状态往往是缺陷的根源。在本节中，你将学习如何组织好状态，如何保持状态更新逻辑的可维护性，以及如何跨组件共享状态。\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"isChapter\":true,\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/reacting-to-input-with-state\",\"children\":\"如何将 UI 变更视为状态变更\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/choosing-the-state-structure\",\"children\":\"如何组织好状态\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/sharing-state-between-components\",\"children\":\"如何使用“状态提升”在组件之间共享状态\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/preserving-and-resetting-state\",\"children\":\"如何控制状态的保留或重置\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"如何在函数中整合复杂的状态逻辑\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"如何避免数据通过 prop 逐级透传\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/scaling-up-with-reducer-and-context\",\"children\":\"如何随着应用的增长去扩展状态管理\"}]}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reacting-to-input-with-state\",\"children\":\"使用状态响应输入 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"使用 React，你不用直接从代码层面修改 UI。例如，不用编写诸如“禁用按钮”、“启用按钮”、“显示成功消息”等命令。相反，你只需要描述组件在不同状态（“初始状态”、“输入状态”、“成功状态”）下希望展现的 UI，然后根据用户输入触发状态更改。这和设计师对 UI 的理解很相似。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"下面是一个使用 React 编写的反馈表单。请注意看它是如何使用 \",[\"$r\",\"code\",null,{\"children\":\"status\"}],\" 这个状态变量来决定启用或禁用提交按钮，以及是否显示成功消息的。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [answer, setAnswer] = useState('');\\n  const [error, setError] = useState(null);\\n  const [status, setStatus] = useState('typing');\\n\\n  if (status === 'success') {\\n    return <h1>答对了！</h1>\\n  }\\n\\n  async function handleSubmit(e) {\\n    e.preventDefault();\\n    setStatus('submitting');\\n    try {\\n      await submitForm(answer);\\n      setStatus('success');\\n    } catch (err) {\\n      setStatus('typing');\\n      setError(err);\\n    }\\n  }\\n\\n  function handleTextareaChange(e) {\\n    setAnswer(e.target.value);\\n  }\\n\\n  return (\\n    <>\\n      <h2>城市测验</h2>\\n      <p>\\n        哪个城市有把空气变成饮用水的广告牌？\\n      </p>\\n      <form onSubmit={handleSubmit}>\\n        <textarea\\n          value={answer}\\n          onChange={handleTextareaChange}\\n          disabled={status === 'submitting'}\\n        />\\n        <br />\\n        <button disabled={\\n          answer.length === 0 ||\\n          status === 'submitting'\\n        }>\\n          提交\\n        </button>\\n        {error !== null &&\\n          <p className=\\\"Error\\\">\\n            {error.message}\\n          </p>\\n        }\\n      </form>\\n    </>\\n  );\\n}\\n\\nfunction submitForm(answer) {\\n  // 模拟接口请求\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      let shouldError = answer.toLowerCase() !== 'lima'\\n      if (shouldError) {\\n        reject(new Error('猜的不错，但答案不对。再试试看吧！'));\\n      } else {\\n        resolve();\\n      }\\n    }, 1500);\\n  });\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".Error { color: red; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"20\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/reacting-to-input-with-state\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/reacting-to-input-with-state\",\"children\":\"用状态对输入作出响应\"}]}],\" 来学习如何以状态驱动的思维处理交互。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"choosing-the-state-structure\",\"children\":\"选择状态结构 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"良好的状态组织，可以区分开易于修改和调试的组件与频繁出问题的组件。最重要的原则是，状态不应包含冗余或重复的信息。如果包含一些多余的状态，我们会很容易忘记去更新它，从而导致问题产生！\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如，这个表单有一个多余的 \",[\"$r\",\"code\",null,{\"children\":\"fullName\"}],\" 状态变量：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [firstName, setFirstName] = useState('');\\n  const [lastName, setLastName] = useState('');\\n  const [fullName, setFullName] = useState('');\\n\\n  function handleFirstNameChange(e) {\\n    setFirstName(e.target.value);\\n    setFullName(e.target.value + ' ' + lastName);\\n  }\\n\\n  function handleLastNameChange(e) {\\n    setLastName(e.target.value);\\n    setFullName(firstName + ' ' + e.target.value);\\n  }\\n\\n  return (\\n    <>\\n      <h2>让我们帮你登记</h2>\\n      <label>\\n        名：{' '}\\n        <input\\n          value={firstName}\\n          onChange={handleFirstNameChange}\\n        />\\n      </label>\\n      <label>\\n        姓：{' '}\\n        <input\\n          value={lastName}\\n          onChange={handleLastNameChange}\\n        />\\n      </label>\\n      <p>\\n        你的票据将签发给：<b>{fullName}</b>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"24\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以移除它并在组件渲染时通过计算 \",[\"$r\",\"code\",null,{\"children\":\"fullName\"}],\" 来简化代码：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [firstName, setFirstName] = useState('');\\n  const [lastName, setLastName] = useState('');\\n\\n  const fullName = firstName + ' ' + lastName;\\n\\n  function handleFirstNameChange(e) {\\n    setFirstName(e.target.value);\\n  }\\n\\n  function handleLastNameChange(e) {\\n    setLastName(e.target.value);\\n  }\\n\\n  return (\\n    <>\\n      <h2>让我们帮你登记</h2>\\n      <label>\\n        名：{' '}\\n        <input\\n          value={firstName}\\n          onChange={handleFirstNameChange}\\n        />\\n      </label>\\n      <label>\\n        姓：{' '}\\n        <input\\n          value={lastName}\\n          onChange={handleLastNameChange}\\n        />\\n      </label>\\n      <p>\\n        你的票将发给：<b>{fullName}</b>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"36\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这看起来似乎只是一个小改动，但却可以避免很多潜在的问题。\"}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/choosing-the-state-structure\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/choosing-the-state-structure\",\"children\":\"选择状态结构\"}]}],\" 来学习如何组织状态并避开错误。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"sharing-state-between-components\",\"children\":\"在组件间共享状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"有时候你希望两个组件的状态始终同步更改。要实现这一点，可以将相关状态从这两个组件上移除，并把这些状态移到最近的父级组件，然后通过 props 将状态传递给这两个组件。这被称为“状态提升”，这是编写 React 代码时常做的事。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在以下示例中，要求每次只能激活一个面板。要实现这一点，父组件将管理激活状态并为其子组件指定 prop，而不是将激活状态保留在各自的子组件中。\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Accordion() {\\n  const [activeIndex, setActiveIndex] = useState(0);\\n  return (\\n    <>\\n      <h2>Almaty, Kazakhstan</h2>\\n      <Panel\\n        title=\\\"关于\\\"\\n        isActive={activeIndex === 0}\\n        onShow={() => setActiveIndex(0)}\\n      >\\n        阿拉木图人口约200万，是哈萨克斯坦最大的城市。在1929年至1997年之间，它是该国首都。\\n      </Panel>\\n      <Panel\\n        title=\\\"词源\\\"\\n        isActive={activeIndex === 1}\\n        onShow={() => setActiveIndex(1)}\\n      >\\n        这个名字源于哈萨克语 <span lang=\\\"kk-KZ\\\">алма</span>，是“苹果”的意思，通常被翻译成“满是苹果”。事实上，阿拉木图周围的地区被认为是苹果的祖籍，<i lang=\\\"la\\\">Malus sieversii</i> 被认为是目前本土苹果的祖先。\\n      </Panel>\\n    </>\\n  );\\n}\\n\\nfunction Panel({\\n  title,\\n  children,\\n  isActive,\\n  onShow\\n}) {\\n  return (\\n    <section className=\\\"panel\\\">\\n      <h3>{title}</h3>\\n      {isActive ? (\\n        <p>{children}</p>\\n      ) : (\\n        <button onClick={onShow}>\\n          显示\\n        </button>\\n      )}\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"h3, p { margin: 5px 0px; }\\n.panel {\\n  padding: 10px;\\n  border: 1px solid #aaa;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"46\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/sharing-state-between-components\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/sharing-state-between-components\",\"children\":\"在组件间共享状态\"}]}],\" 来学习如何提升状态并保持组件同步。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"preserving-and-resetting-state\",\"children\":\"保留和重置状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"当你重新渲染一个组件时， React 需要决定组件树中的哪些部分要保留和更新，以及丢弃或重新创建。在大多数情况下， React 的自动处理机制已经做得足够好了。默认情况下，React 会保留树中与先前渲染的组件树“匹配”的部分。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"然而，有时这并不是你想要的。例如，在下面这个程序中，输入内容后再切换收件人并不会清空输入框。这可能会导致用户不小心发错消息：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport Chat from './Chat.js';\\nimport ContactList from './ContactList.js';\\n\\nexport default function Messenger() {\\n  const [to, setTo] = useState(contacts[0]);\\n  return (\\n    <div>\\n      <ContactList\\n        contacts={contacts}\\n        selectedContact={to}\\n        onSelect={contact => setTo(contact)}\\n      />\\n      <Chat contact={to} />\\n    </div>\\n  )\\n}\\n\\nconst contacts = [\\n  { name: 'Taylor', email: 'taylor@mail.com' },\\n  { name: 'Alice', email: 'alice@mail.com' },\\n  { name: 'Bob', email: 'bob@mail.com' }\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ContactList.js\",\"children\":\"export default function ContactList({\\n  selectedContact,\\n  contacts,\\n  onSelect\\n}) {\\n  return (\\n    <section className=\\\"contact-list\\\">\\n      <ul>\\n        {contacts.map(contact =>\\n          <li key={contact.email}>\\n            <button onClick={() => {\\n              onSelect(contact);\\n            }}>\\n              {contact.name}\\n            </button>\\n          </li>\\n        )}\\n      </ul>\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Chat.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Chat({ contact }) {\\n  const [text, setText] = useState('');\\n  return (\\n    <section className=\\\"chat\\\">\\n      <textarea\\n        value={text}\\n        placeholder={'Chat to ' + contact.name}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <br />\\n      <button>发送给 {contact.email}</button>\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".chat, .contact-list {\\n  float: left;\\n  margin-bottom: 20px;\\n}\\nul, li {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\nli button {\\n  width: 100px;\\n  padding: 10px;\\n  margin-right: 10px;\\n}\\ntextarea {\\n  height: 150px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"50\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 允许你覆盖默认行为，可通过向组件传递一个唯一 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"（如 \",[\"$r\",\"code\",null,{\"children\":\"<Chat key={email}/>\"}],\" 来 \",[\"$r\",\"em\",null,{\"children\":\"强制\"}],\" 重置其状态。这会告诉 React ，如果收件人不同，应将其作为一个 \",[\"$r\",\"strong\",null,{\"children\":\"不同的\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"Chat\"}],\" 组件，需要使用新数据和 UI（比如输入框）来重新创建它。现在，在接收者之间切换时就会重置输入框——即使渲染的是同一个组件。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport Chat from './Chat.js';\\nimport ContactList from './ContactList.js';\\n\\nexport default function Messenger() {\\n  const [to, setTo] = useState(contacts[0]);\\n  return (\\n    <div>\\n      <ContactList\\n        contacts={contacts}\\n        selectedContact={to}\\n        onSelect={contact => setTo(contact)}\\n      />\\n      <Chat key={to.email} contact={to} />\\n    </div>\\n  )\\n}\\n\\nconst contacts = [\\n  { name: 'Taylor', email: 'taylor@mail.com' },\\n  { name: 'Alice', email: 'alice@mail.com' },\\n  { name: 'Bob', email: 'bob@mail.com' }\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ContactList.js\",\"children\":\"export default function ContactList({\\n  selectedContact,\\n  contacts,\\n  onSelect\\n}) {\\n  return (\\n    <section className=\\\"contact-list\\\">\\n      <ul>\\n        {contacts.map(contact =>\\n          <li key={contact.email}>\\n            <button onClick={() => {\\n              onSelect(contact);\\n            }}>\\n              {contact.name}\\n            </button>\\n          </li>\\n        )}\\n      </ul>\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Chat.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Chat({ contact }) {\\n  const [text, setText] = useState('');\\n  return (\\n    <section className=\\\"chat\\\">\\n      <textarea\\n        value={text}\\n        placeholder={'Chat to ' + contact.name}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <br />\\n      <button>发送给 {contact.email}</button>\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".chat, .contact-list {\\n  float: left;\\n  margin-bottom: 20px;\\n}\\nul, li {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\nli button {\\n  width: 100px;\\n  padding: 10px;\\n  margin-right: 10px;\\n}\\ntextarea {\\n  height: 150px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"58\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/preserving-and-resetting-state\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/preserving-and-resetting-state\",\"children\":\"保留和重置状态\"}]}],\" 来学习状态的生命周期以及如何控制它。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"extracting-state-logic-into-a-reducer\",\"children\":\"提取状态逻辑到 reducer 中 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"对于那些需要更新多个状态的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以在组件外部将所有状态更新逻辑合并到一个称为 “reducer” 的函数中。这样，事件处理程序就会变得简洁，因为它们只需要指定用户的 “actions”。在文件的底部，reducer 函数指定状态应该如何更新以响应每个 action！\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useReducer } from 'react';\\nimport AddTask from './AddTask.js';\\nimport TaskList from './TaskList.js';\\n\\nexport default function TaskApp() {\\n  const [tasks, dispatch] = useReducer(\\n    tasksReducer,\\n    initialTasks\\n  );\\n\\n  function handleAddTask(text) {\\n    dispatch({\\n      type: 'added',\\n      id: nextId++,\\n      text: text,\\n    });\\n  }\\n\\n  function handleChangeTask(task) {\\n    dispatch({\\n      type: 'changed',\\n      task: task\\n    });\\n  }\\n\\n  function handleDeleteTask(taskId) {\\n    dispatch({\\n      type: 'deleted',\\n      id: taskId\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <h1>布拉格行程</h1>\\n      <AddTask\\n        onAddTask={handleAddTask}\\n      />\\n      <TaskList\\n        tasks={tasks}\\n        onChangeTask={handleChangeTask}\\n        onDeleteTask={handleDeleteTask}\\n      />\\n    </>\\n  );\\n}\\n\\nfunction tasksReducer(tasks, action) {\\n  switch (action.type) {\\n    case 'added': {\\n      return [...tasks, {\\n        id: action.id,\\n        text: action.text,\\n        done: false\\n      }];\\n    }\\n    case 'changed': {\\n      return tasks.map(t => {\\n        if (t.id === action.task.id) {\\n          return action.task;\\n        } else {\\n          return t;\\n        }\\n      });\\n    }\\n    case 'deleted': {\\n      return tasks.filter(t => t.id !== action.id);\\n    }\\n    default: {\\n      throw Error('未知操作：' + action.type);\\n    }\\n  }\\n}\\n\\nlet nextId = 3;\\nconst initialTasks = [\\n  { id: 0, text: '参观卡夫卡博物馆', done: true },\\n  { id: 1, text: '看木偶戏', done: false },\\n  { id: 2, text: '列侬墙图片', done: false }\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js hidden\",\"children\":\"import { useState } from 'react';\\n\\nexport default function AddTask({ onAddTask }) {\\n  const [text, setText] = useState('');\\n  return (\\n    <>\\n      <input\\n        placeholder=\\\"添加任务\\\"\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button onClick={() => {\\n        setText('');\\n        onAddTask(text);\\n      }}>添加</button>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js hidden\",\"children\":\"import { useState } from 'react';\\n\\nexport default function TaskList({\\n  tasks,\\n  onChangeTask,\\n  onDeleteTask\\n  }) {\\n  return (\\n    <ul>\\n      {tasks.map(task => (\\n        <li key={task.id}>\\n          <Task\\n            task={task}\\n            onChange={onChangeTask}\\n            onDelete={onDeleteTask}\\n          />\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\\nfunction Task({ task, onChange, onDelete }) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  let taskContent;\\n  if (isEditing) {\\n    taskContent = (\\n      <>\\n        <input\\n          value={task.text}\\n          onChange={e => {\\n            onChange({\\n              ...task,\\n              text: e.target.value\\n            });\\n          }} />\\n        <button onClick={() => setIsEditing(false)}>\\n          保存\\n        </button>\\n      </>\\n    );\\n  } else {\\n    taskContent = (\\n      <>\\n        {task.text}\\n        <button onClick={() => setIsEditing(true)}>\\n          编辑\\n        </button>\\n      </>\\n    );\\n  }\\n  return (\\n    <label>\\n      <input\\n        type=\\\"checkbox\\\"\\n        checked={task.done}\\n        onChange={e => {\\n          onChange({\\n            ...task,\\n            done: e.target.checked\\n          });\\n        }}\\n      />\\n      {taskContent}\\n      <button onClick={() => onDelete(task.id)}>\\n        删除\\n      </button>\\n    </label>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\nli { list-style-type: none; }\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"68\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"提取状态逻辑到 reducer 中\"}]}],\" 来学习如何在 reducer 函数中整合逻辑。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"passing-data-deeply-with-context\",\"children\":\"使用 Context 进行深层数据传递 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通常，你会通过 props 将信息从父组件传递给子组件。但是，如果要在组件树中深入传递一些 prop，或者树里的许多组件需要使用相同的 prop，那么传递 prop 可能会变得很麻烦。Context 允许父组件将一些信息提供给它下层的任何组件，不管该组件多深层也无需通过 props 逐层透传。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这里的 \",[\"$r\",\"code\",null,{\"children\":\"Heading\"}],\" 组件通过“询问”最近的 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 来确定其标题级别。每个 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 的级别是通过给父 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 添加的级别来确定的。每个 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 都向它下层的所有组件提供信息，不需要逐层传递 props，而是通过 Context 来实现。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import Heading from './Heading.js';\\nimport Section from './Section.js';\\n\\nexport default function Page() {\\n  return (\\n    <Section>\\n      <Heading>大标题</Heading>\\n      <Section>\\n        <Heading>一级标题</Heading>\\n        <Heading>一级标题</Heading>\\n        <Heading>一级标题</Heading>\\n        <Section>\\n          <Heading>二级标题</Heading>\\n          <Heading>二级标题</Heading>\\n          <Heading>二级标题</Heading>\\n          <Section>\\n            <Heading>三级标题</Heading>\\n            <Heading>三级标题</Heading>\\n            <Heading>三级标题</Heading>\\n          </Section>\\n        </Section>\\n      </Section>\\n    </Section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Section.js\",\"children\":\"import { useContext } from 'react';\\nimport { LevelContext } from './LevelContext.js';\\n\\nexport default function Section({ children }) {\\n  const level = useContext(LevelContext);\\n  return (\\n    <section className=\\\"section\\\">\\n      <LevelContext.Provider value={level + 1}>\\n        {children}\\n      </LevelContext.Provider>\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Heading.js\",\"children\":\"import { useContext } from 'react';\\nimport { LevelContext } from './LevelContext.js';\\n\\nexport default function Heading({ children }) {\\n  const level = useContext(LevelContext);\\n  switch (level) {\\n    case 0:\\n      throw Error('标题必须在 Section 内！');\\n    case 1:\\n      return <h1>{children}</h1>;\\n    case 2:\\n      return <h2>{children}</h2>;\\n    case 3:\\n      return <h3>{children}</h3>;\\n    case 4:\\n      return <h4>{children}</h4>;\\n    case 5:\\n      return <h5>{children}</h5>;\\n    case 6:\\n      return <h6>{children}</h6>;\\n    default:\\n      throw Error('未知级别：' + level);\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/LevelContext.js\",\"children\":\"import { createContext } from 'react';\\n\\nexport const LevelContext = createContext(0);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".section {\\n  padding: 10px;\\n  margin: 5px;\\n  border-radius: 5px;\\n  border: 1px solid #aaa;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"78\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/passing-data-deeply-with-context\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"使用 Context 进行深层数据传递\"}]}],\" 来学习如何使用 Context 来代替传递 props。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"scaling-up-with-reducer-and-context\",\"children\":\"使用 Reducer 和 Context 进行状态扩展 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Reducer 帮助你合并组件的状态更新逻辑。Context 帮助你将信息深入传递给其他组件。你可以将 reducers 和 context 组合在一起使用，以管理复杂应用的状态。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"基于这种想法，使用 reducer 来管理一个具有复杂状态的父组件。组件树中任何深度的其他组件都可以通过 context 读取其状态。还可以 dispatch 一些 action 来更新状态。\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import AddTask from './AddTask.js';\\nimport TaskList from './TaskList.js';\\nimport { TasksProvider } from './TasksContext.js';\\n\\nexport default function TaskApp() {\\n  return (\\n    <TasksProvider>\\n      <h1>在京都休息一天</h1>\\n      <AddTask />\\n      <TaskList />\\n    </TasksProvider>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TasksContext.js\",\"children\":\"import { createContext, useContext, useReducer } from 'react';\\n\\nconst TasksContext = createContext(null);\\nconst TasksDispatchContext = createContext(null);\\n\\nexport function TasksProvider({ children }) {\\n  const [tasks, dispatch] = useReducer(\\n    tasksReducer,\\n    initialTasks\\n  );\\n\\n  return (\\n    <TasksContext.Provider value={tasks}>\\n      <TasksDispatchContext.Provider\\n        value={dispatch}\\n      >\\n        {children}\\n      </TasksDispatchContext.Provider>\\n    </TasksContext.Provider>\\n  );\\n}\\n\\nexport function useTasks() {\\n  return useContext(TasksContext);\\n}\\n\\nexport function useTasksDispatch() {\\n  return useContext(TasksDispatchContext);\\n}\\n\\nfunction tasksReducer(tasks, action) {\\n  switch (action.type) {\\n    case 'added': {\\n      return [...tasks, {\\n        id: action.id,\\n        text: action.text,\\n        done: false\\n      }];\\n    }\\n    case 'changed': {\\n      return tasks.map(t => {\\n        if (t.id === action.task.id) {\\n          return action.task;\\n        } else {\\n          return t;\\n        }\\n      });\\n    }\\n    case 'deleted': {\\n      return tasks.filter(t => t.id !== action.id);\\n    }\\n    default: {\\n      throw Error('未知操作：' + action.type);\\n    }\\n  }\\n}\\n\\nconst initialTasks = [\\n  { id: 0, text: '哲学家之路', done: true },\\n  { id: 1, text: '参观寺庙', done: false },\\n  { id: 2, text: '喝抹茶', done: false }\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js\",\"children\":\"import { useState, useContext } from 'react';\\nimport { useTasksDispatch } from './TasksContext.js';\\n\\nexport default function AddTask({ onAddTask }) {\\n  const [text, setText] = useState('');\\n  const dispatch = useTasksDispatch();\\n  return (\\n    <>\\n      <input\\n        placeholder=\\\"添加任务\\\"\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button onClick={() => {\\n        setText('');\\n        dispatch({\\n          type: 'added',\\n          id: nextId++,\\n          text: text,\\n        });\\n      }}>添加</button>\\n    </>\\n  );\\n}\\n\\nlet nextId = 3;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js\",\"children\":\"import { useState, useContext } from 'react';\\nimport { useTasks, useTasksDispatch } from './TasksContext.js';\\n\\nexport default function TaskList() {\\n  const tasks = useTasks();\\n  return (\\n    <ul>\\n      {tasks.map(task => (\\n        <li key={task.id}>\\n          <Task task={task} />\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\\nfunction Task({ task }) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  const dispatch = useTasksDispatch();\\n  let taskContent;\\n  if (isEditing) {\\n    taskContent = (\\n      <>\\n        <input\\n          value={task.text}\\n          onChange={e => {\\n            dispatch({\\n              type: 'changed',\\n              task: {\\n                ...task,\\n                text: e.target.value\\n              }\\n            });\\n          }} />\\n        <button onClick={() => setIsEditing(false)}>\\n          保存\\n        </button>\\n      </>\\n    );\\n  } else {\\n    taskContent = (\\n      <>\\n        {task.text}\\n        <button onClick={() => setIsEditing(true)}>\\n          编辑\\n        </button>\\n      </>\\n    );\\n  }\\n  return (\\n    <label>\\n      <input\\n        type=\\\"checkbox\\\"\\n        checked={task.done}\\n        onChange={e => {\\n          dispatch({\\n            type: 'changed',\\n            task: {\\n              ...task,\\n              done: e.target.checked\\n            }\\n          });\\n        }}\\n      />\\n      {taskContent}\\n      <button onClick={() => {\\n        dispatch({\\n          type: 'deleted',\\n          id: task.id\\n        });\\n      }}>\\n        删除\\n      </button>\\n    </label>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\nli { list-style-type: none; }\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/scaling-up-with-reducer-and-context\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/scaling-up-with-reducer-and-context\",\"children\":\"使用 Reducer 和 Context 进行扩展\"}]}],\" 来学习如何在不断增长的应用程序中扩展状态管理。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"whats-next\",\"children\":\"下节预告 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"跳转到 \",[\"$r\",\"a\",null,{\"href\":\"/learn/reacting-to-input-with-state\",\"children\":\"使用状态响应输入\"}],\" 这一节并开始一页页的阅读！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当然，如果你已经熟悉了这些内容，可以去读一读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/escape-hatches\",\"children\":\"脱围机制\"}],\"?\"]}]]}]]","meta":{"title":"状态管理","translators":["qinhua","KnowsCount","QC-L"]}},"__N_SSG":true}