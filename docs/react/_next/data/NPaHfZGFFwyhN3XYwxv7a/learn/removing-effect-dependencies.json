{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#dependencies-should-match-the-code\",\"depth\":2,\"text\":\"依赖应该和代码保持一致 \"},{\"url\":\"#to-remove-a-dependency-prove-that-its-not-a-dependency\",\"depth\":3,\"text\":\"当要移除一个依赖时，请证明它不是一个依赖 \"},{\"url\":\"#to-change-the-dependencies-change-the-code\",\"depth\":3,\"text\":\"要改变依赖，请改变代码 \"},{\"url\":\"#removing-unnecessary-dependencies\",\"depth\":2,\"text\":\"移除非必需的依赖 \"},{\"url\":\"#should-this-code-move-to-an-event-handler\",\"depth\":3,\"text\":\"这段代码应该移到事件处理程序中吗？ \"},{\"url\":\"#is-your-effect-doing-several-unrelated-things\",\"depth\":3,\"text\":\"Effect 是否在做几件不相关的事情？ \"},{\"url\":\"#are-you-reading-some-state-to-calculate-the-next-state\",\"depth\":3,\"text\":\"是否在读取一些状态来计算下一个状态？ \"},{\"url\":\"#do-you-want-to-read-a-value-without-reacting-to-its-changes\",\"depth\":3,\"text\":\"你想读取一个值而不对其变化做出“反应”吗？ \"},{\"url\":\"#does-some-reactive-value-change-unintentionally\",\"depth\":3,\"text\":\"一些响应式值是否无意中改变了？ \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"12\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"当编写 Effect 时，linter 会验证是否已经将 Effect 读取的每一个响应式值（如 props 和 state）包含在 Effect 的依赖中。这可以确保 Effect 与组件的 props 和 state 保持同步。不必要的依赖可能会导致 Effect 运行过于频繁，甚至产生无限循环。请按照本指南审查并移除 Effect 中不必要的依赖。\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"修复无限的 Effect 依赖性循环\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"当你想移除依赖时，该怎么做\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"从 Effect 中读取值而不对它作出“反应”\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"为什么以及如何避免对象和函数的依赖？\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"为什么抑制依赖代码检查器的检查是危险的，以及应该如何做？\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"dependencies-should-match-the-code\",\"children\":\"依赖应该和代码保持一致 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你编写 Effect 时，无论这个 Effect 要做什么，你首先要明确其 \",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#the-lifecycle-of-an-effect\",\"children\":\"生命周期\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5-7}\",\"children\":\"const serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  \\t// ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你设置 Effect 的依赖是空数组（\",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\"），那么 linter 将会建议合适的依赖：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, []); // <-- 修复这里的依赖！\\n  return <h1>欢迎来到 {roomId} 房间！</h1>;\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('所有');\\n  return (\\n    <>\\n      <label>\\n        选择聊天室：\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom roomId={roomId} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间，在 ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开“' + roomId + '”房间，在 ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"20\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"按照 linter 的建议，把它们填进去：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6}\",\"children\":\"function ChatRoom({ roomId }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]); // ✅ 所有依赖已声明\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values\",\"children\":\"Effect “反应”响应式值\"}],\" 因为这里的 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 是一个响应式值（它可能随重新渲染而改变），所以 linter 会验证你是否将它指定为依赖。如果 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 变成不同的值，React 将重新运行 Effect。这可以确保聊天界面与所选房间保持一致，并把变化“反馈”给下拉菜单：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n  return <h1>欢迎来到 {roomId} 房间！</h1>;\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('所有');\\n  return (\\n    <>\\n      <label>\\n        选择聊天室：\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom roomId={roomId} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间，在 ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开“' + roomId + '”房间，在 ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"40\",{\"children\":[\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"to-remove-a-dependency-prove-that-its-not-a-dependency\",\"children\":\"当要移除一个依赖时，请证明它不是一个依赖 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"注意，你不能“选择” Effect 的依赖。每个被 Effect 所使用的\",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"响应式值\"}],\"，必须在依赖中声明。依赖是由 Effect 的代码决定的：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 3, \\\"roomId\\\"], [2, 5, \\\"roomId\\\"], [2, 8, \\\"roomId\\\"]]\",\"children\":\"const serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) { // 这是一个响应式值\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId); // Effect 在这里读取响应式值\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]); // ✅ 所以你必须在依赖中声明 Effect 使用的响应式值\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#all-variables-declared-in-the-component-body-are-reactive\",\"children\":\"响应式值\"}],\" 包括 props 以及所有你直接在组件中声明的变量和函数。由于 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 是响应式值，你不能把它从依赖中移除。linter 不允许这样做：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{8}\",\"children\":\"const serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, []); // 🔴 React Hook useEffect 缺失依赖: 'roomId'\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"linter 是对的！ 由于 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 可能会随时间变化，这会在代码中引入错误。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"移除一个依赖，你需要向 linter 证明其不需要这个依赖\"}],\"。例如，你可以将 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 移出组件，以证明它不是响应的，也不会在重新渲染时改变：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,9}\",\"children\":\"const serverUrl = 'https://localhost:1234';\\nconst roomId = '音乐'; // 不再是响应式值\\n\\nfunction ChatRoom() {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, []); // ✅ 所有依赖已声明\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 不是响应式值（并且不能在重新渲染时改变），那它不就不是依赖：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\nconst roomId = '音乐';\\n\\nexport default function ChatRoom() {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, []);\\n  return <h1>欢迎来到 {roomId} 房间！</h1>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间，在 ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开“' + roomId + '”房间，在 ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"192\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这就是为什么你现在可以指定 \",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means\",\"children\":[\"空（\",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\"）依赖\"]}],\"。Effect \",[\"$r\",\"strong\",null,{\"children\":\"真的不\"}],\" 依赖任何响应式值了，也 \",[\"$r\",\"strong\",null,{\"children\":\"真的不\"}],\" 需要在组件的 props 或 state 改变时重新运行。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"to-change-the-dependencies-change-the-code\",\"children\":\"要改变依赖，请改变代码 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可能已经注意到工作流程中有一个模式：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"首先，你 \",[\"$r\",\"strong\",null,{\"children\":\"改变 Effect 的代码\"}],\" 或响应式值的声明方式。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"然后，你采纳 linter 的建议，调整依赖，以 \",[\"$r\",\"strong\",null,{\"children\":\"匹配你所改变的代码\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你对依赖不满意，你可以 \",[\"$r\",\"strong\",null,{\"children\":\"回到第一步\"}],\"（并再次修改代码）。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"最后一部分很重要。\",[\"$r\",\"strong\",null,{\"children\":\"如果你想改变依赖，首先要改变所涉及到的代码\"}],\"。你可以把依赖看作是 \",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency\",\"children\":\"Effect的代码所依赖的所有响应式值的列表\"}],\"。你不要 \",[\"$r\",\"strong\",null,{\"children\":\"选择\"}],\" 把什么放在这个列表上。该列表 \",[\"$r\",\"strong\",null,{\"children\":\"描述了\"}],\" 代码。要改变依赖，请改变代码。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这可能感觉就像解方程一样。你有一个目标（例如，移除一个依赖），你需要“找到”与该目标相匹配的代码。不是每个人都觉得解方程很有趣，写 Effect 也是如此！幸运的是，下面有一些常见的解决方案你可以去尝试。\"}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"如果你有一个已经存在的代码库，你可能会有一些像这样抑制 linter 的代码：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-4}\",\"children\":\"useEffect(() => {\\n  // ...\\n  // 🔴 避免像这样抑制 linter 的警告或错误提示：\\n  // eslint-ignore-next-line react-hooks/exhaustive-deps\\n}, []);\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"当依赖与代码不匹配时，极有可能引入 bug\"}],\"。通过抑制 linter，你是在 Effect 所依赖的值上对 React “撒谎”。\"]}],[\"$r\",\"p\",null,{\"children\":\"你可以使用如下技术。\"}]]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"why-is-suppressing-the-dependency-linter-so-dangerous\",\"children\":\"为什么抑制 linter 对依赖的检查如此危险？ \"}],[\"$r\",\"p\",null,{\"children\":\"抑制 linter 会导致非常不直观的 bug，这将很难发现和修复。这里有一个例子：\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n  const [increment, setIncrement] = useState(1);\\n\\n  function onTick() {\\n\\tsetCount(count + increment);\\n  }\\n\\n  useEffect(() => {\\n    const id = setInterval(onTick, 1000);\\n    return () => clearInterval(id);\\n    // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, []);\\n\\n  return (\\n    <>\\n      <h1>\\n        计数器：{count}\\n        <button onClick={() => setCount(0)}>重制</button>\\n      </h1>\\n      <hr />\\n      <p>\\n        每秒递增：\\n        <button disabled={increment === 0} onClick={() => {\\n          setIncrement(i => i - 1);\\n        }}>–</button>\\n        <b>{increment}</b>\\n        <button onClick={() => {\\n          setIncrement(i => i + 1);\\n        }}>+</button>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 10px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"比方说，你想“只在 mount 时”运行 Effect。你已经知道可以通过设置 \",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means\",\"children\":[\"空（\",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\"）依赖\"]}],\" 来达到这种效果，所以你决定忽略 linter 的检查，强行指定 \",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\" 为依赖。\"]}],[\"$r\",\"p\",null,{\"children\":[\"上面的计数器例子，本应该每秒递增，递增量可以通过两个按钮来控制。然而，由于你对 React “撒谎”，说这个 Effect 不依赖于任何东西，React 便一直使用初次渲染时的 \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" 函数。\",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time\",\"children\":\"在后续渲染中\"}],\"， \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" 总是 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" ，\",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" 总是 \",[\"$r\",\"code\",null,{\"children\":\"1\"}],\"。为什么？因为定时器每秒调用 \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" 函数，实际运行的是 \",[\"$r\",\"code\",null,{\"children\":\"setCount(0 + 1)\"}],[\"$r\",\"sup\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"#note1\",\"children\":\"[1]\"}]}],\"，所以你总是看到 \",[\"$r\",\"code\",null,{\"children\":\"1\"}],\"。像这样的错误，当它们分散在多个组件中时，就更难解决了。\"]}],[\"$r\",\"p\",null,{\"children\":[\"这里有一个比忽略 linter 更好的解决方案! 那便是将 \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" 添加到依赖中。(为了确保 interval 只设置一次，\",[\"$r\",\"a\",null,{\"href\":\"/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events\",\"children\":[\"使 \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" 成为 Effect Event\"]}],\"。)\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"我们建议将依赖性 lint 错误作为一个编译错误来处理。如果你不抑制它，你将永远不会遇到像上面这样的错误\"}],\"。本页面的剩下部分将介绍这个和其他情况的替代方案。\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"removing-unnecessary-dependencies\",\"children\":\"移除非必需的依赖 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"每当你调整 Effect 的依赖以适配代码时，请注意一下当前的依赖。当这些依赖发生变化时，让 Effect 重新运行是否有意义？有时，答案是“不”：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你可能想在不同的条件下重新执行 Effect 的 \",[\"$r\",\"strong\",null,{\"children\":\"不同部分\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你可能想只读取某个依赖的 \",[\"$r\",\"strong\",null,{\"children\":\"最新值\"}],\"，而不是对其变化做出“反应”。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"依赖可能会因为它的类型是对象或函数而 \",[\"$r\",\"strong\",null,{\"children\":\"无意间\"}],\" 改变太频繁。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"为了找到正确的解决方案，你需要回答关于 Effect 的几个问题。让我们来看看这些问题。\"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"should-this-code-move-to-an-event-handler\",\"children\":\"这段代码应该移到事件处理程序中吗？ \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你应该考虑的第一件事是，这段代码是否应该成为 Effect。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"想象一个表单，在提交时你将 \",[\"$r\",\"code\",null,{\"children\":\"submitted\"}],\" 状态变量设置为 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\"，并在 \",[\"$r\",\"code\",null,{\"children\":\"submitted\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\" 时，需要发送 POST 请求并显示通知。你把这个逻辑放在 Effect 内，并根据 \",[\"$r\",\"code\",null,{\"children\":\"submitted\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\" “反应”。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6-8}\",\"children\":\"function Form() {\\n  const [submitted, setSubmitted] = useState(false);\\n\\n  useEffect(() => {\\n    if (submitted) {\\n      // 🔴 避免: Effect 中有特定事件的逻辑\\n      post('/api/register');\\n      showNotification('Successfully registered!');\\n    }\\n  }, [submitted]);\\n\\n  function handleSubmit() {\\n    setSubmitted(true);\\n  }\\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"后来，你想通过读取当前的主题值来调整通知信息的样式。因为 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 是在组件中声明的，所以它是响应式值，你决定把它作为依赖加入：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,9,11}\",\"children\":\"function Form() {\\n  const [submitted, setSubmitted] = useState(false);\\n  const theme = useContext(ThemeContext);\\n\\n  useEffect(() => {\\n    if (submitted) {\\n      // 🔴 避免: Effect 中有特定事件的逻辑\\n      post('/api/register');\\n      showNotification('Successfully registered!', theme);\\n    }\\n  }, [submitted, theme]); // ✅ 所有依赖已声明\\n\\n  function handleSubmit() {\\n    setSubmitted(true);\\n  }  \\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果这么做，你将引入一个错误。想象一下，你先提交表单，然后切换暗亮主题。当 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 改变后，Effect 重新运行，这将导致显示两次相同的通知！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"首先，这里的问题是，代码不应该以 Effect 实现\"}],\"。你想发送这个 POST 请求，并在 \",[\"$r\",\"strong\",null,{\"children\":\"提交表单时显示通知\"}],\"，这是一个特定的交互。特定的交互请将该逻辑直接放到相应的事件处理程序中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6-7}\",\"children\":\"function Form() {\\n  const theme = useContext(ThemeContext);\\n\\n  function handleSubmit() {\\n    // ✅ 好：从事件处理程序调用特定于事件的逻辑\\n    post('/api/register');\\n    showNotification('Successfully registered!', theme);\\n  }  \\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在，代码在事件处理程序中，它不是响应式的 —— 所以它只在用户提交表单时运行。阅读更多关于 \",[\"$r\",\"a\",null,{\"href\":\"/learn/separating-events-from-effects#reactive-values-and-reactive-logic\",\"children\":\"在事件处理程序和 Effect 之间做出选择\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/you-might-not-need-an-effect\",\"children\":\"如何删除不必要的 Effect\"}],\"。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"is-your-effect-doing-several-unrelated-things\",\"children\":\"Effect 是否在做几件不相关的事情？ \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"下一个应该问自己的问题是，Effect 是否在做几件不相关的事情。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如下例子，你正在实现运输表单，用户需要选择他们的城市和地区。你根据所选的“国家”从服务器上获取“城市”列表，然后在下拉菜单中显示：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function ShippingForm({ country }) {\\n  const [cities, setCities] = useState(null);\\n  const [city, setCity] = useState(null);\\n\\n  useEffect(() => {\\n    let ignore = false;\\n    fetch(`/api/cities?country=${country}`)\\n      .then(response => response.json())\\n      .then(json => {\\n        if (!ignore) {\\n          setCities(json);\\n        }\\n      });\\n    return () => {\\n      ignore = true;\\n    };\\n  }, [country]); // ✅ 所有依赖已声明\\n\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这是一个 \",[\"$r\",\"a\",null,{\"href\":\"/learn/you-might-not-need-an-effect#fetching-data\",\"children\":\"在Effect中获取数据\"}],\" 的好例子：\",[\"$r\",\"code\",null,{\"children\":\"cities\"}],\" state 通过网络和 \",[\"$r\",\"code\",null,{\"children\":\"country\"}],\" props 进行“同步”。但你不能在事件处理程序中这样做，因为你需要在 \",[\"$r\",\"code\",null,{\"children\":\"ShippingForm\"}],\" 显示时和 \",[\"$r\",\"code\",null,{\"children\":\"country\"}],\" 发生变化时（不管是哪个交互导致的）立即获取。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在我们假设你要为城市区域添加第二个选择框，它应该获取当前选择的 \",[\"$r\",\"code\",null,{\"children\":\"city\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"areas\"}],\"。你也许会在同一个 Effect 中添加第二个 \",[\"$r\",\"code\",null,{\"children\":\"fetch\"}],\" 调用来获取地区列表：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{15-24,28}\",\"children\":\"function ShippingForm({ country }) {\\n  const [cities, setCities] = useState(null);\\n  const [city, setCity] = useState(null);\\n  const [areas, setAreas] = useState(null);\\n\\n  useEffect(() => {\\n    let ignore = false;\\n    fetch(`/api/cities?country=${country}`)\\n      .then(response => response.json())\\n      .then(json => {\\n        if (!ignore) {\\n          setCities(json);\\n        }\\n      });\\n    // 🔴 避免: 单个 Effect 同步两个独立逻辑处理\\n    if (city) {\\n      fetch(`/api/areas?city=${city}`)\\n        .then(response => response.json())\\n        .then(json => {\\n          if (!ignore) {\\n            setAreas(json);\\n          }\\n        });\\n    }\\n    return () => {\\n      ignore = true;\\n    };\\n  }, [country, city]); // ✅ 所有依赖已声明\\n\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然而，由于 Effect 现在使用 \",[\"$r\",\"code\",null,{\"children\":\"city\"}],\" state 变量，你不得不把 \",[\"$r\",\"code\",null,{\"children\":\"city\"}],\" 加入到依赖中。这又带来一个问题：当用户选择不同的城市时，Effect 将重新运行并调用 \",[\"$r\",\"code\",null,{\"children\":\"fetchCities(country)\"}],\"。这将导致不必要地多次获取城市列表。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"这段代码的问题在于，你在同步两个不同的、不相关的东西\"}],\"：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你想要根据 \",[\"$r\",\"code\",null,{\"children\":\"country\"}],\" props 通过网络同步 \",[\"$r\",\"code\",null,{\"children\":\"city\"}],\" state\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你想要根据 \",[\"$r\",\"code\",null,{\"children\":\"city\"}],\" 状态通过网络同步 \",[\"$r\",\"code\",null,{\"children\":\"areas\"}],\" state\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"将逻辑分到 2 个 Effect 中，每个 Effect 仅响应其需要同步响应的 props：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{19-33}\",\"children\":\"function ShippingForm({ country }) {\\n  const [cities, setCities] = useState(null);\\n  useEffect(() => {\\n    let ignore = false;\\n    fetch(`/api/cities?country=${country}`)\\n      .then(response => response.json())\\n      .then(json => {\\n        if (!ignore) {\\n          setCities(json);\\n        }\\n      });\\n    return () => {\\n      ignore = true;\\n    };\\n  }, [country]); // ✅ 所有依赖已声明\\n\\n  const [city, setCity] = useState(null);\\n  const [areas, setAreas] = useState(null);\\n  useEffect(() => {\\n    if (city) {\\n      let ignore = false;\\n      fetch(`/api/areas?city=${city}`)\\n        .then(response => response.json())\\n        .then(json => {\\n          if (!ignore) {\\n            setAreas(json);\\n          }\\n        });\\n      return () => {\\n        ignore = true;\\n      };\\n    }\\n  }, [city]); // ✅ 所有依赖已声明\\n\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在，第一个 Effect 只在 \",[\"$r\",\"code\",null,{\"children\":\"country\"}],\" 改变时重新运行，而第二个 Effect 在 \",[\"$r\",\"code\",null,{\"children\":\"city\"}],\" 改变时重新运行。你已经按目的把它们分开了：两件不同的事情由两个独立的 Effect 来同步。两个独立的 Effect 有两个独立的依赖，所以它们不会在无意中相互触发。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"最终完成的代码比最初的要长，但是拆分这些 Effect 是非常正确的。\",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process\",\"children\":\"每个 Effect 应该代表一个独立的同步过程\"}],\"。在这个例子中，删除一个 Effect 并不会影响到另一个 Effect 的逻辑。这意味着他们 \",[\"$r\",\"strong\",null,{\"children\":\"同步不同的事情\"}],\"，分开他们处理是一件好事。如果你担心重复代码的问题，你可以通过 \",[\"$r\",\"a\",null,{\"href\":\"/learn/reusing-logic-with-custom-hooks#when-to-use-custom-hooks\",\"children\":\"提取相同逻辑到自定义 Hook\"}],\" 来提升代码质量\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"are-you-reading-some-state-to-calculate-the-next-state\",\"children\":\"是否在读取一些状态来计算下一个状态？ \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"每次有新的消息到达时，这个 Effect 会用新创建的数组更新 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\" state：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,6-8}\",\"children\":\"function ChatRoom({ roomId }) {\\n  const [messages, setMessages] = useState([]);\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    connection.on('message', (receivedMessage) => {\\n      setMessages([...messages, receivedMessage]);\\n    });\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"它使用 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\" 变量来 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state\",\"children\":\"创建一个新的数组\"}],\"：从所有现有的消息开始，并在最后添加新的消息。然而，由于 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\" 是一个由 Effect 读取的响应式值，它必须是一个依赖：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7,10}\",\"children\":\"function ChatRoom({ roomId }) {\\n  const [messages, setMessages] = useState([]);\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    connection.on('message', (receivedMessage) => {\\n      setMessages([...messages, receivedMessage]);\\n    });\\n    return () => connection.disconnect();\\n  }, [roomId, messages]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"而让 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\" 成为依赖会带来问题。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"每当你收到一条消息，\",[\"$r\",\"code\",null,{\"children\":\"setMessages()\"}],\" 就会使该组件重新渲染一个新的 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\" 数组，其中包括收到的消息。然而，由于该 Effect 现在依赖于 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\"，这 \",[\"$r\",\"strong\",null,{\"children\":\"也将\"}],\" 重新同步该 Effect。所以每条新消息都会使聊天重新连接。用户不会喜欢这样！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了解决这个问题，不要在 Effect 里面读取 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\"。相反，应该将一个 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#updating-state-based-the-previous-state\",\"children\":\"state 更新函数\"}],\" 传递给 \",[\"$r\",\"code\",null,{\"children\":\"setMessages\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7,10}\",\"children\":\"function ChatRoom({ roomId }) {\\n  const [messages, setMessages] = useState([]);\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    connection.on('message', (receivedMessage) => {\\n      setMessages(msgs => [...msgs, receivedMessage]);\\n    });\\n    return () => connection.disconnect();\\n  }, [roomId]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"注意 Effect 现在根本不读取 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\" 变量\"]}],\"。你只需要传递一个更新函数，比如 \",[\"$r\",\"code\",null,{\"children\":\"msgs => [...msgs, receivedMessage]\"}],\"。React \",[\"$r\",\"a\",null,{\"href\":\"/learn/queueing-a-series-of-state-updates\",\"children\":\"将更新程序函数放入队列\"}],\" 并将在下一次渲染期间向其提供 \",[\"$r\",\"code\",null,{\"children\":\"msgs\"}],\" 参数。这就是 Effect 本身不再需要依赖 \",[\"$r\",\"code\",null,{\"children\":\"messages\"}],\" 的原因。修复后，接收聊天消息将不再使聊天重新连接。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"do-you-want-to-read-a-value-without-reacting-to-its-changes\",\"children\":\"你想读取一个值而不对其变化做出“反应”吗？ \"}],\"\\n\",[\"$r\",\"Wip\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"本节描述了一个在稳定版本的 React 中 \",[\"$r\",\"strong\",null,{\"children\":\"尚未发布的实验性\"}],\" API。\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"假设你希望在用户收到新消息时播放声音，\",[\"$r\",\"code\",null,{\"children\":\"isMuted\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\" 除外：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,10-12}\",\"children\":\"function ChatRoom({ roomId }) {\\n  const [messages, setMessages] = useState([]);\\n  const [isMuted, setIsMuted] = useState(false);\\n\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    connection.on('message', (receivedMessage) => {\\n      setMessages(msgs => [...msgs, receivedMessage]);\\n      if (!isMuted) {\\n        playSound();\\n      }\\n    });\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"由于 Effect 现在在其代码中使用了 \",[\"$r\",\"code\",null,{\"children\":\"isMuted\"}],\" ，因此你必须将其添加到依赖中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{10,15}\",\"children\":\"function ChatRoom({ roomId }) {\\n  const [messages, setMessages] = useState([]);\\n  const [isMuted, setIsMuted] = useState(false);\\n\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    connection.on('message', (receivedMessage) => {\\n      setMessages(msgs => [...msgs, receivedMessage]);\\n      if (!isMuted) {\\n        playSound();\\n      }\\n    });\\n    return () => connection.disconnect();\\n  }, [roomId, isMuted]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"问题是每次 \",[\"$r\",\"code\",null,{\"children\":\"isMuted\"}],\" 改变时（例如，当用户按下“静音”开关时），Effect 将重新同步，并重新连接到聊天。这不是理想的用户体验！（在此示例中，即使禁用 linter 也不起作用——如果你这样做，\",[\"$r\",\"code\",null,{\"children\":\"isMuted\"}],\" 将“保持”其旧值。）\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"要解决这个问题，需要将不应该响应式的逻辑从 Effect 中抽取出来。你不希望此 Effect 对 \",[\"$r\",\"code\",null,{\"children\":\"isMuted\"}],\" 中的更改做出“反应”。\",[\"$r\",\"a\",null,{\"href\":\"/learn/separating-events-from-effects#declaring-an-effect-event\",\"children\":\"将这段非响应式逻辑移至 Effect Event 中\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,7-12,18,21}\",\"children\":\"import { useState, useEffect, useEffectEvent } from 'react';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [messages, setMessages] = useState([]);\\n  const [isMuted, setIsMuted] = useState(false);\\n\\n  const onMessage = useEffectEvent(receivedMessage => {\\n    setMessages(msgs => [...msgs, receivedMessage]);\\n    if (!isMuted) {\\n      playSound();\\n    }\\n  });\\n\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    connection.on('message', (receivedMessage) => {\\n      onMessage(receivedMessage);\\n    });\\n    return () => connection.disconnect();\\n  }, [roomId]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Effect Events 让你可以将 Effect 分成响应式部分（应该“反应”响应式值，如 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 及其变化）和非响应式部分（只读取它们的最新值，如 \",[\"$r\",\"code\",null,{\"children\":\"onMessage\"}],\" 读取 \",[\"$r\",\"code\",null,{\"children\":\"isMuted\"}],\"）。\",[\"$r\",\"strong\",null,{\"children\":[\"现在你在 Effect Event 中读取了 \",[\"$r\",\"code\",null,{\"children\":\"isMuted\"}],\"，它不需要添加到 Effect 依赖中\"]}],\"。因此，当你打开或者关闭“静音”设置时，聊天不会重新连接。至此，解决原始问题！\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"wrapping-an-event-handler-from-the-props\",\"children\":\"包装来自 props 的事件处理程序 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"当组件接收事件处理函数作为 props 时，你可能会遇到类似的问题：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,8,11}\",\"children\":\"function ChatRoom({ roomId, onReceiveMessage }) {\\n  const [messages, setMessages] = useState([]);\\n\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    connection.on('message', (receivedMessage) => {\\n      onReceiveMessage(receivedMessage);\\n    });\\n    return () => connection.disconnect();\\n  }, [roomId, onReceiveMessage]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"假设父组件在每次渲染时都传递了一个 \",[\"$r\",\"strong\",null,{\"children\":\"不同的\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"onReceiveMessage\"}],\" 函数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-5}\",\"children\":\"<ChatRoom\\n  roomId={roomId}\\n  onReceiveMessage={receivedMessage => {\\n    // ...\\n  }}\\n/>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"由于 \",[\"$r\",\"code\",null,{\"children\":\"onReceiveMessage\"}],\" 是依赖，它会导致 Effect 在每次父级重新渲染后重新同步。这将导致聊天重新连接。要解决此问题，请用 Effect Event 包裹之后再调用：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-6,12,15}\",\"children\":\"function ChatRoom({ roomId, onReceiveMessage }) {\\n  const [messages, setMessages] = useState([]);\\n\\n  const onMessage = useEffectEvent(receivedMessage => {\\n    onReceiveMessage(receivedMessage);\\n  });\\n\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.connect();\\n    connection.on('message', (receivedMessage) => {\\n      onMessage(receivedMessage);\\n    });\\n    return () => connection.disconnect();\\n  }, [roomId]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Effect Events 不是响应式的，因此你不需要将它们指定为依赖。因此，即使父组件传递的函数在每次重新渲染时都不同，聊天也将不再重新连接。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"separating-reactive-and-non-reactive-code\",\"children\":\"分离响应式和非响应式代码 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在此示例中，你希望在每次 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 更改时记录一次。你希望在每个日志中包含当前的 \",[\"$r\",\"code\",null,{\"children\":\"notificationCount\"}],\"，但你 \",[\"$r\",\"strong\",null,{\"children\":\"不\"}],\" 希望通过更改 \",[\"$r\",\"code\",null,{\"children\":\"notificationCount\"}],\" 来触发日志事件。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"解决方案还是将非响应式代码拆分，将其放到 Effect Event 内：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-4,7}\",\"children\":\"function Chat({ roomId, notificationCount }) {\\n  const onVisit = useEffectEvent(visitedRoomId => {\\n    logVisit(visitedRoomId, notificationCount);\\n  });\\n\\n  useEffect(() => {\\n    onVisit(roomId);\\n  }, [roomId]); // ✅ 所有依赖已声明\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你希望逻辑对 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 做出响应，因此你在 Effect 中读取 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\"。但是，你不希望更改 \",[\"$r\",\"code\",null,{\"children\":\"notificationCount\"}],\" 来记录额外的日志输出，因此你可以在 Effect Event 中读取 \",[\"$r\",\"code\",null,{\"children\":\"notificationCount\"}],\"。\",[\"$r\",\"a\",null,{\"href\":\"/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events\",\"children\":\"了解使用 Effect Events 在 Effect 中读取最新 props 和 state 的更多信息\"}],\"。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"does-some-reactive-value-change-unintentionally\",\"children\":\"一些响应式值是否无意中改变了？ \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"有时，你 \",[\"$r\",\"strong\",null,{\"children\":\"确实\"}],\" 希望 Effect 对某个值“做出反应”，但该值的变化比你希望的更频繁——并且可能不会从用户的角度反映任何实际变化。例如，假设你在组件中创建了 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 对象，然后从 Effect 内部读取该对象：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-6,9}\",\"children\":\"function ChatRoom({ roomId }) {\\n  // ...\\n  const options = {\\n    serverUrl: serverUrl,\\n    roomId: roomId\\n  };\\n\\n  useEffect(() => {\\n    const connection = createConnection(options);\\n    connection.connect();\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"该对象在组件中声明，因此它是 \",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values\",\"children\":\"响应式值\"}],\"。当你在 Effect 中读取这样的响应式值时，你将其声明为依赖。这可确保 Effect 对其更改做出“反应”：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,6}\",\"children\":\"  // ...\\n  useEffect(() => {\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [options]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"将其声明为依赖很重要！例如，这可以确保如果 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 发生变化，Effect 将使用新的 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 重新连接到聊天。但是，上面的代码也有问题。要查看它，请尝试在下面的沙盒中输入内容，然后观察控制台中发生的情况：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n\\n  // 暂时禁用 linter 以演示问题\\n  // eslint-disable-next-line react-hooks/exhaustive-deps\\n  const options = {\\n    serverUrl: serverUrl,\\n    roomId: roomId\\n  };\\n\\n  useEffect(() => {\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [options]);\\n\\n  return (\\n    <>\\n      <h1>欢迎来到 {roomId} 房间！</h1>\\n      <input value={message} onChange={e => setMessage(e.target.value)} />\\n    </>\\n  );\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('所有');\\n  return (\\n    <>\\n      <label>\\n        选择聊天室：\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom roomId={roomId} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间，在 ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开“' + roomId + '”房间，在 ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"232\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在上面的沙箱中，输入仅更新 \",[\"$r\",\"code\",null,{\"children\":\"message\"}],\" 状态变量。从用户的角度来看，这不应该影响聊天连接。但是，每次更新 \",[\"$r\",\"code\",null,{\"children\":\"message\"}],\" 时，组件都会重新渲染。当组件重新渲染时，其中的代码会从头开始重新运行。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在每次重新渲染 \",[\"$r\",\"code\",null,{\"children\":\"ChatRoom\"}],\" 组件时，都会从头开始创建一个新的 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 对象。React 发现 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 对象与上次渲染期间创建的 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 对象是 \",[\"$r\",\"strong\",null,{\"children\":\"不同的对象\"}],\"。这就是为什么它会重新同步 Effect（依赖于 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\"），并且会在你输入时重新连接聊天。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"此问题仅影响对象和函数。在 JavaScript 中，每个新创建的对象和函数都被认为与其他所有对象和函数不同。即使他们的值相同也没关系\"}],\"！\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-8}\",\"children\":\"// 第一次渲染\\nconst options1 = { serverUrl: 'https://localhost:1234', roomId: '音乐' };\\n\\n// 下一次渲染\\nconst options2 = { serverUrl: 'https://localhost:1234', roomId: '音乐' };\\n\\n// 这是 2 个不同的对象\\nconsole.log(Object.is(options1, options2)); // false\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"对象和函数作为依赖，会使 Effect 比你需要的更频繁地重新同步\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这就是为什么你应该尽可能避免将对象和函数作为 Effect 的依赖。所以，尝试将它们移到组件外部、Effect 内部，或从中提取原始值。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"move-static-objects-and-functions-outside-your-component\",\"children\":\"将静态对象和函数移出组件 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果该对象不依赖于任何 props 和 state，你可以将该对象移到组件之外：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1-4,13}\",\"children\":\"const options = {\\n  serverUrl: 'https://localhost:1234',\\n  roomId: '音乐'\\n};\\n\\nfunction ChatRoom() {\\n  const [message, setMessage] = useState('');\\n\\n  useEffect(() => {\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, []); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这样，你向 linter \",[\"$r\",\"strong\",null,{\"children\":\"证明\"}],\" 它不是响应式的。它不会因为重新渲染而改变，所以它不是依赖。现在重新渲染 \",[\"$r\",\"code\",null,{\"children\":\"ChatRoom\"}],\" 不会导致 Effect 重新同步。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这也适用于函数场景：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1-6,12}\",\"children\":\"function createOptions() {\\n  return {\\n    serverUrl: 'https://localhost:1234',\\n    roomId: '音乐'\\n  };\\n}\\n\\nfunction ChatRoom() {\\n  const [message, setMessage] = useState('');\\n\\n  useEffect(() => {\\n    const options = createOptions();\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, []); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"由于 \",[\"$r\",\"code\",null,{\"children\":\"createOptions\"}],\" 是在组件外部声明的，因此它不是响应式值。这就是为什么它不需要在 Effect 的依赖中指定，以及为什么它永远不会导致 Effect 重新同步。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"move-dynamic-objects-and-functions-inside-your-effect\",\"children\":\"将动态对象和函数移动到 Effect 中 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果对象依赖于一些可能因重新渲染而改变的响应式值，例如 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" props，那么你不能将它放置于组件 \",[\"$r\",\"strong\",null,{\"children\":\"外部\"}],\"。你可以在 Effect \",[\"$r\",\"strong\",null,{\"children\":\"内部\"}],\" 创建它：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-10,11,14}\",\"children\":\"const serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n\\n  useEffect(() => {\\n    const options = {\\n      serverUrl: serverUrl,\\n      roomId: roomId\\n    };\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 已在 Effect 中声明，它不再是 Effect 的依赖。相反，Effect 使用的唯一响应式值是 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\"。由于 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 不是对象或函数，你可以确定它不会 \",[\"$r\",\"strong\",null,{\"children\":\"无意间\"}],\" 变不同。在 JavaScript 中，数字和字符串根据它们的内容进行比较：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-8}\",\"children\":\"// 第一次渲染\\nconst roomId1 = '音乐';\\n\\n// 下一次渲染\\nconst roomId2 = '音乐';\\n\\n// 这 2 个字符串是相同的\\nconsole.log(Object.is(roomId1, roomId2)); // true\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"得益于此修复，当你编辑输入时，聊天将不再重新连接：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n\\n  useEffect(() => {\\n    const options = {\\n      serverUrl: serverUrl,\\n      roomId: roomId\\n    };\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n\\n  return (\\n    <>\\n      <h1>欢迎来到 {roomId} 房间!</h1>\\n      <input value={message} onChange={e => setMessage(e.target.value)} />\\n    </>\\n  );\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('所有');\\n  return (\\n    <>\\n      <label>\\n        选择聊天室:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom roomId={roomId} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间，在 ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开“' + roomId + '”房间，在 ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"272\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然而，当你更改 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 下拉列表时，它 \",[\"$r\",\"strong\",null,{\"children\":\"确实\"}],\" 重新连接，正如你所期望的那样。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这也适用于函数的场景：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-12,14}\",\"children\":\"const serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n\\n  useEffect(() => {\\n    function createOptions() {\\n      return {\\n        serverUrl: serverUrl,\\n        roomId: roomId\\n      };\\n    }\\n\\n    const options = createOptions();\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以编写自己的函数来组织 Effect 中的逻辑。只要将这些函数声明在 Effect \",[\"$r\",\"strong\",null,{\"children\":\"内部\"}],\"，它们就不是响应式值，因此它们也不是 Effect 的依赖。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"read-primitive-values-from-objects\",\"children\":\"从对象中读取原始值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"有时，你可能会通过 props 接收到类型为对象的值：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,5,8}\",\"children\":\"function ChatRoom({ options }) {\\n  const [message, setMessage] = useState('');\\n\\n  useEffect(() => {\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [options]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这里的风险是父组件会在渲染过程中创建对象：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-6}\",\"children\":\"<ChatRoom\\n  roomId={roomId}\\n  options={{\\n    serverUrl: serverUrl,\\n    roomId: roomId\\n  }}\\n/>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这将导致 Effect 在每次父组件重新渲染时重新连接。要解决此问题，请从 Effect \",[\"$r\",\"strong\",null,{\"children\":\"外部\"}],\" 读取对象信息，并避免依赖对象和函数类型：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,7-8,12}\",\"children\":\"function ChatRoom({ options }) {\\n  const [message, setMessage] = useState('');\\n\\n  const { roomId, serverUrl } = options;\\n  useEffect(() => {\\n    const connection = createConnection({\\n      roomId: roomId,\\n      serverUrl: serverUrl\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId, serverUrl]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"逻辑有点重复（你从 Effect 外部的对象读取一些值，然后在 Effect 内部创建具有相同值的对象）。但这使得 Effect \",[\"$r\",\"strong\",null,{\"children\":\"实际\"}],\" 依赖的信息非常明确。如果对象被父组件无意中重新创建，聊天也不会重新连接。但是，如果 \",[\"$r\",\"code\",null,{\"children\":\"options.roomId\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"options.serverUrl\"}],\" 确实不同，聊天将重新连接。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"calculate-primitive-values-from-functions\",\"children\":\"从函数中计算原始值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"同样的方法也适用于函数。例如，假设父组件传递了一个函数：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-8}\",\"children\":\"<ChatRoom\\n  roomId={roomId}\\n  getOptions={() => {\\n    return {\\n      serverUrl: serverUrl,\\n      roomId: roomId\\n    };\\n  }}\\n/>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为避免使其成为依赖（并导致它在重新渲染时重新连接），请在 Effect 外部调用它。这为你提供了不是对象的 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"serverUrl\"}],\" 值，你可以从 Effect 中读取它们：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,4}\",\"children\":\"function ChatRoom({ getOptions }) {\\n  const [message, setMessage] = useState('');\\n\\n  const { roomId, serverUrl } = getOptions();\\n  useEffect(() => {\\n    const connection = createConnection({\\n      roomId: roomId,\\n      serverUrl: serverUrl\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId, serverUrl]); // ✅ 所有依赖已声明\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这仅适用于 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"纯\"}],\" 函数，因为它们在渲染期间可以安全调用。如果函数是一个事件处理程序，但你不希望它的更改重新同步 Effect，\",[\"$r\",\"a\",null,{\"href\":\"#do-you-want-to-read-a-value-without-reacting-to-its-changes\",\"children\":\"将它包装到 Effect Event 中\"}],\"。\"]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"依赖应始终与代码匹配。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"当你对依赖不满意时，你需要编辑的是代码。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"抑制 linter 会导致非常混乱的错误，你应该始终避免它。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"要移除依赖，你需要向 linter “证明”它不是必需的。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果某些代码是为了响应特定交互，请将该代码移至事件处理的地方。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果 Effect 的不同部分因不同原因需要重新运行，请将其拆分为多个 Effect。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果你想根据以前的状态更新一些状态，传递一个更新函数。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果你想读取最新值而不“反应”它，请从 Effect 中提取出一个 Effect Event。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"在 JavaScript 中，如果对象和函数是在不同时间创建的，则它们被认为是不同的。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"尽量避免对象和函数依赖。将它们移到组件外或 Effect 内。\"}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"fix-a-resetting-interval\",\"children\":\"修复重置 interval \"}],[\"$r\",\"p\",null,{\"children\":\"这个 Effect 设置了一个每秒运行的 interval。你已经注意到一些奇怪的事情：似乎每次 interval 都会被销毁并重新创建。修复代码，使 interval 不会被不断重新创建。\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"看起来这个 Effect 的代码依赖于 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\"。有什么方法不需要这依赖吗？有，那就是根据其之前的值更新 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" state，从而避免添加对该值的依赖。\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n\\n  useEffect(() => {\\n    console.log('✅ 创建定时器');\\n    const id = setInterval(() => {\\n      console.log('⏰ Interval');\\n      setCount(count + 1);\\n    }, 1000);\\n    return () => {\\n      console.log('❌ 清除定时器');\\n      clearInterval(id);\\n    };\\n  }, [count]);\\n\\n  return <h1>计数器: {count}</h1>\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"你想要从 Effect 内部将 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" 状态更新为 \",[\"$r\",\"code\",null,{\"children\":\"count + 1\"}],\"。但是，这会使 Effect 依赖于 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\"，它会随着每次滴答而变化，这就是为什么 interval 会在每次滴答时重新创建。\"]}],[\"$r\",\"p\",null,{\"children\":[\"要解决这个问题，请使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#updating-state-based-on-the-previous-state\",\"children\":\"更新函数\"}],\" 并编写 \",[\"$r\",\"code\",null,{\"children\":\"setCount(c => c + 1)\"}],\" 而不是 \",[\"$r\",\"code\",null,{\"children\":\"setCount(count + 1)\"}],\":\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n\\n  useEffect(() => {\\n    console.log('✅ 创建定时器');\\n    const id = setInterval(() => {\\n      console.log('⏰ Interval');\\n      setCount(c => c + 1);\\n    }, 1000);\\n    return () => {\\n      console.log('❌ 清除定时器');\\n      clearInterval(id);\\n    };\\n  }, []);\\n\\n  return <h1>计数器: {count}</h1>\\n}\\n\"}]}]}],[\"$r\",\"p\",null,{\"children\":[\"你不应在 Effect 中读取 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\"，而是将 \",[\"$r\",\"code\",null,{\"children\":\"c => c + 1\"}],\" 指令（“增加此数字！”）传递给 React。React 将在下一次渲染时执行它。由于你不再需要读取 Effect 中 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" 的值，因此你可以将 Effect 的依赖保持为空（\",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\"）。这可以防止 Effect 在每次执行时重新创建定时器 interval。\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-retriggering-animation\",\"children\":\"修复重新触发动画的问题 \"}],[\"$r\",\"p\",null,{\"children\":[\"在此示例中，当你按下“显示”时，欢迎消息淡入。动画持续一秒钟。当你按下“移除”时，欢迎信息立即消失。淡入动画的逻辑在 \",[\"$r\",\"code\",null,{\"children\":\"animation.js\"}],\" 文件中以纯 JavaScript \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"动画循环\"}],\" 实现。你不需要改变那个逻辑。你可以将其视为第三方库。Effect 的逻辑是为 DOM 节点创建一个 \",[\"$r\",\"code\",null,{\"children\":\"FadeInAnimation\"}],\" 实例，然后调用 \",[\"$r\",\"code\",null,{\"children\":\"start(duration)\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"stop()\"}],\" 来控制动画。\",[\"$r\",\"code\",null,{\"children\":\"duration\"}],\" 由滑块控制。调整滑块并查看动画如何变化。\"]}],[\"$r\",\"p\",null,{\"children\":[\"此代码已经能工作，但你需要更改一些内容。目前，当你移动控制 \",[\"$r\",\"code\",null,{\"children\":\"duration\"}],\" 状态变量的滑块时，它会重新触发动画。更改行为，使 Effect 不会对 \",[\"$r\",\"code\",null,{\"children\":\"duration\"}],\" 变量做出“反应”。当你按下“显示”时，Effect 应该使用滑块上的当前 \",[\"$r\",\"code\",null,{\"children\":\"duration\"}],\" 值。但是，移动滑块本身不应重新触发动画。\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"Effect 中是否有一行代码不应该是响应式的？如何将非响应式代码移出 Effect？\"}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect, useRef } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\nimport { FadeInAnimation } from './animation.js';\\n\\nfunction Welcome({ duration }) {\\n  const ref = useRef(null);\\n\\n  useEffect(() => {\\n    const animation = new FadeInAnimation(ref.current);\\n    animation.start(duration);\\n    return () => {\\n      animation.stop();\\n    };\\n  }, [duration]);\\n\\n  return (\\n    <h1\\n      ref={ref}\\n      style={{\\n        opacity: 0,\\n        color: 'white',\\n        padding: 50,\\n        textAlign: 'center',\\n        fontSize: 50,\\n        backgroundImage: 'radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%)'\\n      }}\\n    >\\n      欢迎\\n    </h1>\\n  );\\n}\\n\\nexport default function App() {\\n  const [duration, setDuration] = useState(1000);\\n  const [show, setShow] = useState(false);\\n\\n  return (\\n    <>\\n      <label>\\n        <input\\n          type=\\\"range\\\"\\n          min=\\\"100\\\"\\n          max=\\\"3000\\\"\\n          value={duration}\\n          onChange={e => setDuration(Number(e.target.value))}\\n        />\\n        <br />\\n        淡入 interval: {duration} ms\\n      </label>\\n      <button onClick={() => setShow(!show)}>\\n        {show ? '移除' : '显示'}\\n      </button>\\n      <hr />\\n      {show && <Welcome duration={duration} />}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/animation.js\",\"children\":\"export class FadeInAnimation {\\n  constructor(node) {\\n    this.node = node;\\n  }\\n  start(duration) {\\n    this.duration = duration;\\n    if (this.duration === 0) {\\n      // Jump to end immediately\\n      this.onProgress(1);\\n    } else {\\n      this.onProgress(0);\\n      // Start animating\\n      this.startTime = performance.now();\\n      this.frameId = requestAnimationFrame(() => this.onFrame());\\n    }\\n  }\\n  onFrame() {\\n    const timePassed = performance.now() - this.startTime;\\n    const progress = Math.min(timePassed / this.duration, 1);\\n    this.onProgress(progress);\\n    if (progress < 1) {\\n      // We still have more frames to paint\\n      this.frameId = requestAnimationFrame(() => this.onFrame());\\n    }\\n  }\\n  onProgress(progress) {\\n    this.node.style.opacity = progress;\\n  }\\n  stop() {\\n    cancelAnimationFrame(this.frameId);\\n    this.startTime = null;\\n    this.frameId = null;\\n    this.duration = 0;\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label, button { display: block; margin-bottom: 20px; }\\nhtml, body { min-height: 300px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"Effect 需要读取 \",[\"$r\",\"code\",null,{\"children\":\"duration\"}],\" 的最新值，但你不希望它对 \",[\"$r\",\"code\",null,{\"children\":\"duration\"}],\" 的变化做出“反应”。你使用 \",[\"$r\",\"code\",null,{\"children\":\"duration\"}],\" 来启动动画，但启动动画不是响应式的。将非响应式代码行提取到 Effect Event 中，并从 Effect 中调用该函数。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect, useRef } from 'react';\\nimport { FadeInAnimation } from './animation.js';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\n\\nfunction Welcome({ duration }) {\\n  const ref = useRef(null);\\n\\n  const onAppear = useEffectEvent(animation => {\\n    animation.start(duration);\\n  });\\n\\n  useEffect(() => {\\n    const animation = new FadeInAnimation(ref.current);\\n    onAppear(animation);\\n    return () => {\\n      animation.stop();\\n    };\\n  }, []);\\n\\n  return (\\n    <h1\\n      ref={ref}\\n      style={{\\n        opacity: 0,\\n        color: 'white',\\n        padding: 50,\\n        textAlign: 'center',\\n        fontSize: 50,\\n        backgroundImage: 'radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%)'\\n      }}\\n    >\\n      欢迎\\n    </h1>\\n  );\\n}\\n\\nexport default function App() {\\n  const [duration, setDuration] = useState(1000);\\n  const [show, setShow] = useState(false);\\n\\n  return (\\n    <>\\n      <label>\\n        <input\\n          type=\\\"range\\\"\\n          min=\\\"100\\\"\\n          max=\\\"3000\\\"\\n          value={duration}\\n          onChange={e => setDuration(Number(e.target.value))}\\n        />\\n        <br />\\n        淡入 interval: {duration} ms\\n      </label>\\n      <button onClick={() => setShow(!show)}>\\n        {show ? '移除' : '显示'}\\n      </button>\\n      <hr />\\n      {show && <Welcome duration={duration} />}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/animation.js\",\"children\":\"export class FadeInAnimation {\\n  constructor(node) {\\n    this.node = node;\\n  }\\n  start(duration) {\\n    this.duration = duration;\\n    this.onProgress(0);\\n    this.startTime = performance.now();\\n    this.frameId = requestAnimationFrame(() => this.onFrame());\\n  }\\n  onFrame() {\\n    const timePassed = performance.now() - this.startTime;\\n    const progress = Math.min(timePassed / this.duration, 1);\\n    this.onProgress(progress);\\n    if (progress < 1) {\\n      // We still have more frames to paint\\n      this.frameId = requestAnimationFrame(() => this.onFrame());\\n    }\\n  }\\n  onProgress(progress) {\\n    this.node.style.opacity = progress;\\n  }\\n  stop() {\\n    cancelAnimationFrame(this.frameId);\\n    this.startTime = null;\\n    this.frameId = null;\\n    this.duration = 0;\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label, button { display: block; margin-bottom: 20px; }\\nhtml, body { min-height: 300px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"像 \",[\"$r\",\"code\",null,{\"children\":\"onAppear\"}],\" 这样的 Effect Events 不是响应式的，因此你可以在不重新触发动画的情况下读取内部的 \",[\"$r\",\"code\",null,{\"children\":\"duration\"}],\"。\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-reconnecting-chat\",\"children\":\"修复聊天重新连接的问题 \"}],[\"$r\",\"p\",null,{\"children\":\"在此示例中，每次你按“切换主题”时，聊天都会重新连接。为什么会这样？修复错误，只有当你编辑服务器 URL 或选择不同的聊天室时，聊天才会重新连接。\"}],[\"$r\",\"p\",null,{\"children\":[\"将 \",[\"$r\",\"code\",null,{\"children\":\"chat.js\"}],\" 视为外部第三方库：你可以查阅它以检查其 API，但不要对其进行编辑。\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"解决这个问题的方法不止一种，但最终你希望避免将对象作为依赖。\"}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport ChatRoom from './ChatRoom.js';\\n\\nexport default function App() {\\n  const [isDark, setIsDark] = useState(false);\\n  const [roomId, setRoomId] = useState('所有');\\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\\n\\n  const options = {\\n    serverUrl: serverUrl,\\n    roomId: roomId\\n  };\\n\\n  return (\\n    <div className={isDark ? 'dark' : 'light'}>\\n      <button onClick={() => setIsDark(!isDark)}>\\n        切换主题\\n      </button>\\n      <label>\\n        服务器地址：\\n        <input\\n          value={serverUrl}\\n          onChange={e => setServerUrl(e.target.value)}\\n        />\\n      </label>\\n      <label>\\n        选择聊天室：\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom options={options} />\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ChatRoom.js active\",\"children\":\"import { useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nexport default function ChatRoom({ options }) {\\n  useEffect(() => {\\n    const connection = createConnection(options);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [options]);\\n\\n  return <h1>欢迎来到 {options.roomId} 房间！</h1>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  if (typeof serverUrl !== 'string') {\\n    throw Error('期望 serverUrl 是字符串类型，收到：' + serverUrl);\\n  }\\n  if (typeof roomId !== 'string') {\\n    throw Error('期望 roomId 是字符串类型，收到：' + roomId);\\n  }\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间，在 ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开“' + roomId + '”房间，在 ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label, button { display: block; margin-bottom: 5px; }\\n.dark { background: #222; color: #eee; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"Effect 因依赖于 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" 对象，导致其重新运行。对象可能会在无意中被重新创建，你应该尽可能避免将它们作为 Effect 的依赖。\"]}],[\"$r\",\"p\",null,{\"children\":[\"侵入性最小的修复方法是在 Effect 外部读取 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"serverUrl\"}],\"，然后使 Effect 依赖于这些原始值（不能无意地更改）。在 Effect 内部，创建一个对象并将其传递给 \",[\"$r\",\"code\",null,{\"children\":\"createConnection\"}],\"：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport ChatRoom from './ChatRoom.js';\\n\\nexport default function App() {\\n  const [isDark, setIsDark] = useState(false);\\n  const [roomId, setRoomId] = useState('所有');\\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\\n\\n  const options = {\\n    serverUrl: serverUrl,\\n    roomId: roomId\\n  };\\n\\n  return (\\n    <div className={isDark ? 'dark' : 'light'}>\\n      <button onClick={() => setIsDark(!isDark)}>\\n        切换主题\\n      </button>\\n      <label>\\n        服务器地址：\\n        <input\\n          value={serverUrl}\\n          onChange={e => setServerUrl(e.target.value)}\\n        />\\n      </label>\\n      <label>\\n        选择聊天室：\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom options={options} />\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ChatRoom.js active\",\"children\":\"import { useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nexport default function ChatRoom({ options }) {\\n  const { roomId, serverUrl } = options;\\n  useEffect(() => {\\n    const connection = createConnection({\\n      roomId: roomId,\\n      serverUrl: serverUrl\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId, serverUrl]);\\n\\n  return <h1>欢迎来到 {options.roomId} 房间！</h1>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  if (typeof serverUrl !== 'string') {\\n    throw Error('期望 serverUrl 是字符串类型，收到：' + serverUrl);\\n  }\\n  if (typeof roomId !== 'string') {\\n    throw Error('期望 roomId 是字符串类型，收到：' + roomId);\\n  }\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间，在 ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开“' + roomId + '”房间，在 ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label, button { display: block; margin-bottom: 5px; }\\n.dark { background: #222; color: #eee; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"用更具体的 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"serverUrl\"}],\" props 替换对象 \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\" props 会更好：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport ChatRoom from './ChatRoom.js';\\n\\nexport default function App() {\\n  const [isDark, setIsDark] = useState(false);\\n  const [roomId, setRoomId] = useState('所有');\\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\\n\\n  return (\\n    <div className={isDark ? 'dark' : 'light'}>\\n      <button onClick={() => setIsDark(!isDark)}>\\n        切换主题\\n      </button>\\n      <label>\\n        服务器地址：\\n        <input\\n          value={serverUrl}\\n          onChange={e => setServerUrl(e.target.value)}\\n        />\\n      </label>\\n      <label>\\n        选择聊天室：\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        serverUrl={serverUrl}\\n      />\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ChatRoom.js active\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nexport default function ChatRoom({ roomId, serverUrl }) {\\n  useEffect(() => {\\n    const connection = createConnection({\\n      roomId: roomId,\\n      serverUrl: serverUrl\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId, serverUrl]);\\n\\n  return <h1>欢迎来到 {roomId} 房间！</h1>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  if (typeof serverUrl !== 'string') {\\n    throw Error('期望 serverUrl 是字符串类型，收到：' + serverUrl);\\n  }\\n  if (typeof roomId !== 'string') {\\n    throw Error('期望 roomId 是字符串类型，收到：' + roomId);\\n  }\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间，在 ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 断开“' + roomId + '”房间，在 ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label, button { display: block; margin-bottom: 5px; }\\n.dark { background: #222; color: #eee; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":\"尽可能坚持使用原始 props，以便以后更容易优化组件。\"}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-reconnecting-chat-again\",\"children\":\"再次修复聊天重新连接的问题 \"}],[\"$r\",\"p\",null,{\"children\":\"此示例使用或不使用加密连接到聊天。切换复选框并注意加密打开和关闭时控制台中的不同消息。换个房间试试，然后，尝试切换主题。当你连接到聊天室时，每隔几秒钟就会收到一条新消息。验证它们的颜色是否与你选择的主题相匹配。\"}],[\"$r\",\"p\",null,{\"children\":\"在此示例中，每次你尝试更改主题时聊天都会重新连接。解决这个问题。修复后，更改主题不应重新连接聊天，但切换加密设置或更改房间应重新连接。\"}],[\"$r\",\"p\",null,{\"children\":[\"不要更改 \",[\"$r\",\"code\",null,{\"children\":\"chat.js\"}],\" 中的任何代码。除此之外，你可以更改任何代码，只要它引起相同的行为。例如，你可能会发现更改正在传递的 props 很有帮助。\"]}],[\"$r\",\"Hint\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"你传递了两个函数：\",[\"$r\",\"code\",null,{\"children\":\"onMessage\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"createConnection\"}],\"。每次 \",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 重新渲染时，它们都是从头开始创建的。它们每次都被视为新值，这就是它们重新触发 Effect 的原因。\"]}],[\"$r\",\"p\",null,{\"children\":\"前者是事件处理程序。你知道在不对新的事件处理函数“做出反应”的情况下调用事件处理程序 Effect 的方法吗？这个问题你迟早要遇到！\"}],[\"$r\",\"p\",null,{\"children\":[\"后者仅用于将某些状态传递给导入的 API 方法。这个函数真的有必要吗？传递的基本信息是什么？你可能需要将一些导入从 \",[\"$r\",\"code\",null,{\"children\":\"App.js\"}],\" 移至 \",[\"$r\",\"code\",null,{\"children\":\"ChatRoom.js\"}],\"。\"]}]]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport ChatRoom from './ChatRoom.js';\\nimport {\\n  createEncryptedConnection,\\n  createUnencryptedConnection,\\n} from './chat.js';\\nimport { showNotification } from './notifications.js';\\n\\nexport default function App() {\\n  const [isDark, setIsDark] = useState(false);\\n  const [roomId, setRoomId] = useState('所有');\\n  const [isEncrypted, setIsEncrypted] = useState(false);\\n\\n  return (\\n    <>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        使用暗黑主题\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isEncrypted}\\n          onChange={e => setIsEncrypted(e.target.checked)}\\n        />\\n        开启加密功能\\n      </label>\\n      <label>\\n        选择聊天室：\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        onMessage={msg => {\\n          showNotification('新消息：' + msg, isDark ? 'dark' : 'light');\\n        }}\\n        createConnection={() => {\\n          const options = {\\n            serverUrl: 'https://localhost:1234',\\n            roomId: roomId\\n          };\\n          if (isEncrypted) {\\n            return createEncryptedConnection(options);\\n          } else {\\n            return createUnencryptedConnection(options);\\n          }\\n        }}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ChatRoom.js active\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\n\\nexport default function ChatRoom({ roomId, createConnection, onMessage }) {\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.on('message', (msg) => onMessage(msg));\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [createConnection, onMessage]);\\n\\n  return <h1>欢迎来到 {roomId} 房间！</h1>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createEncryptedConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  if (typeof serverUrl !== 'string') {\\n    throw Error('期望 serverUrl 是字符串类型，收到：' + serverUrl);\\n  }\\n  if (typeof roomId !== 'string') {\\n    throw Error('期望 roomId 是字符串类型，收到：' + roomId);\\n  }\\n  let intervalId;\\n  let messageCallback;\\n  return {\\n    connect() {\\n      console.log('✅ 🔐 连接到“' + roomId + '”房间...（已加密）');\\n      clearInterval(intervalId);\\n      intervalId = setInterval(() => {\\n        if (messageCallback) {\\n          if (Math.random() > 0.5) {\\n            messageCallback('hey')\\n          } else {\\n            messageCallback('lol');\\n          }\\n        }\\n      }, 3000);\\n    },\\n    disconnect() {\\n      clearInterval(intervalId);\\n      messageCallback = null;\\n      console.log('❌ 🔐 断开“' + roomId + '”房间（已加密）');\\n    },\\n    on(event, callback) {\\n      if (messageCallback) {\\n        throw Error('不能添加 handler 2次');\\n      }\\n      if (event !== 'message') {\\n        throw Error('仅支持 \\\"message\\\" 事件');\\n      }\\n      messageCallback = callback;\\n    },\\n  };\\n}\\n\\nexport function createUnencryptedConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  if (typeof serverUrl !== 'string') {\\n    throw Error('期望 serverUrl 是字符串类型，收到：' + serverUrl);\\n  }\\n  if (typeof roomId !== 'string') {\\n    throw Error('期望 roomId 是字符串类型，收到：' + roomId);\\n  }\\n  let intervalId;\\n  let messageCallback;\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间（未加密）...');\\n      clearInterval(intervalId);\\n      intervalId = setInterval(() => {\\n        if (messageCallback) {\\n          if (Math.random() > 0.5) {\\n            messageCallback('hey')\\n          } else {\\n            messageCallback('lol');\\n          }\\n        }\\n      }, 3000);\\n    },\\n    disconnect() {\\n      clearInterval(intervalId);\\n      messageCallback = null;\\n      console.log('❌ 断开“' + roomId + '”房间（未加密）');\\n    },\\n    on(event, callback) {\\n      if (messageCallback) {\\n        throw Error('不能添加 handler 2次');\\n      }\\n      if (event !== 'message') {\\n        throw Error('仅支持 \\\"message\\\" 事件');\\n      }\\n      messageCallback = callback;\\n    },\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label, button { display: block; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"解决这个问题的正确方法不止一种，下面要介绍的是一种可能的解决方案。\"}],[\"$r\",\"p\",null,{\"children\":[\"在原始示例中，切换主题会导致创建和传递不同的 \",[\"$r\",\"code\",null,{\"children\":\"onMessage\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"createConnection\"}],\" 函数。由于 Effect 依赖于这些功能，因此每次切换主题时聊天都会重新连接。\"]}],[\"$r\",\"p\",null,{\"children\":[\"要解决 \",[\"$r\",\"code\",null,{\"children\":\"onMessage\"}],\" 的问题，你需要将其包装到 Effect Event 中：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,2,6}\",\"children\":\"export default function ChatRoom({ roomId, createConnection, onMessage }) {\\n  const onReceiveMessage = useEffectEvent(onMessage);\\n\\n  useEffect(() => {\\n    const connection = createConnection();\\n    connection.on('message', (msg) => onReceiveMessage(msg));\\n    // ...\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"与 \",[\"$r\",\"code\",null,{\"children\":\"onMessage\"}],\" props 不同，\",[\"$r\",\"code\",null,{\"children\":\"onReceiveMessage\"}],\" Effect Event 不是响应式的。这就是为什么它不需要成为 Effect 的依赖。因此，对 \",[\"$r\",\"code\",null,{\"children\":\"onMessage\"}],\" 的更改不会导致聊天重新连接。\"]}],[\"$r\",\"p\",null,{\"children\":[\"你不能对 \",[\"$r\",\"code\",null,{\"children\":\"createConnection\"}],\" 做同样的事情，因为它 \",[\"$r\",\"strong\",null,{\"children\":\"应该\"}],\" 是响应式的。如果用户在加密和未加密连接之间切换，或者如果用户切换当前房间，你 \",[\"$r\",\"strong\",null,{\"children\":\"希望\"}],\" 重新触发 Effect。但是，因为 \",[\"$r\",\"code\",null,{\"children\":\"createConnection\"}],\" 是函数，你无法检查它读取的信息是否 \",[\"$r\",\"strong\",null,{\"children\":\"实际\"}],\" 发生了变化。要解决此问题，请传递原始的 \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"isEncrypted\"}],\" 值，而不是从 App 组件向下传递 \",[\"$r\",\"code\",null,{\"children\":\"createConnection\"}],\" ：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-3}\",\"children\":\"      <ChatRoom\\n        roomId={roomId}\\n        isEncrypted={isEncrypted}\\n        onMessage={msg => {\\n          showNotification('新消息：' + msg, isDark ? 'dark' : 'light');\\n        }}\\n      />\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"现在你可以将 \",[\"$r\",\"code\",null,{\"children\":\"createConnection\"}],\" 函数移到 Effect 里面，而不是从 \",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 向下传递它：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1-4,6,10-20}\",\"children\":\"import {\\n  createEncryptedConnection,\\n  createUnencryptedConnection,\\n} from './chat.js';\\n\\nexport default function ChatRoom({ roomId, isEncrypted, onMessage }) {\\n  const onReceiveMessage = useEffectEvent(onMessage);\\n\\n  useEffect(() => {\\n    function createConnection() {\\n      const options = {\\n        serverUrl: 'https://localhost:1234',\\n        roomId: roomId\\n      };\\n      if (isEncrypted) {\\n        return createEncryptedConnection(options);\\n      } else {\\n        return createUnencryptedConnection(options);\\n      }\\n    }\\n    // ...\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"在这两个更改之后，Effect 不再依赖于任何函数值：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,8,10,21}\",\"children\":\"export default function ChatRoom({ roomId, isEncrypted, onMessage }) { // Reactive values\\n  const onReceiveMessage = useEffectEvent(onMessage); // Not reactive\\n\\n  useEffect(() => {\\n    function createConnection() {\\n      const options = {\\n        serverUrl: 'https://localhost:1234',\\n        roomId: roomId // 读取响应式值\\n      };\\n      if (isEncrypted) { // 读取响应式值\\n        return createEncryptedConnection(options);\\n      } else {\\n        return createUnencryptedConnection(options);\\n      }\\n    }\\n\\n    const connection = createConnection();\\n    connection.on('message', (msg) => onReceiveMessage(msg));\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId, isEncrypted]); // ✅ 所有依赖已声明\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"因此，仅当有意义的内容（\",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"isEncrypted\"}],\"）发生变化时，聊天才会重新连接：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport ChatRoom from './ChatRoom.js';\\n\\nimport { showNotification } from './notifications.js';\\n\\nexport default function App() {\\n  const [isDark, setIsDark] = useState(false);\\n  const [roomId, setRoomId] = useState('所有');\\n  const [isEncrypted, setIsEncrypted] = useState(false);\\n\\n  return (\\n    <>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        使用暗黑主题\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isEncrypted}\\n          onChange={e => setIsEncrypted(e.target.checked)}\\n        />\\n        开启加密功能\\n      </label>\\n      <label>\\n        选择聊天室：\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"所有\\\">所有</option>\\n          <option value=\\\"旅游\\\">旅游</option>\\n          <option value=\\\"音乐\\\">音乐</option>\\n        </select>\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        isEncrypted={isEncrypted}\\n        onMessage={msg => {\\n          showNotification('新消息：' + msg, isDark ? 'dark' : 'light');\\n        }}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ChatRoom.js active\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\nimport {\\n  createEncryptedConnection,\\n  createUnencryptedConnection,\\n} from './chat.js';\\n\\nexport default function ChatRoom({ roomId, isEncrypted, onMessage }) {\\n  const onReceiveMessage = useEffectEvent(onMessage);\\n\\n  useEffect(() => {\\n    function createConnection() {\\n      const options = {\\n        serverUrl: 'https://localhost:1234',\\n        roomId: roomId\\n      };\\n      if (isEncrypted) {\\n        return createEncryptedConnection(options);\\n      } else {\\n        return createUnencryptedConnection(options);\\n      }\\n    }\\n\\n    const connection = createConnection();\\n    connection.on('message', (msg) => onReceiveMessage(msg));\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId, isEncrypted]);\\n\\n  return <h1>欢迎来到 {roomId} 房间！</h1>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createEncryptedConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  if (typeof serverUrl !== 'string') {\\n    throw Error('期望 serverUrl 是字符串类型，收到：' + serverUrl);\\n  }\\n  if (typeof roomId !== 'string') {\\n    throw Error('期望 roomId 是字符串类型，收到：' + roomId);\\n  }\\n  let intervalId;\\n  let messageCallback;\\n  return {\\n    connect() {\\n      console.log('✅ 🔐 连接到“' + roomId + '”房间...（已加密）');\\n      clearInterval(intervalId);\\n      intervalId = setInterval(() => {\\n        if (messageCallback) {\\n          if (Math.random() > 0.5) {\\n            messageCallback('hey')\\n          } else {\\n            messageCallback('lol');\\n          }\\n        }\\n      }, 3000);\\n    },\\n    disconnect() {\\n      clearInterval(intervalId);\\n      messageCallback = null;\\n      console.log('❌ 🔐 断开“' + roomId + '”房间（已加密）');\\n    },\\n    on(event, callback) {\\n      if (messageCallback) {\\n        throw Error('不能添加 handler 2次');\\n      }\\n      if (event !== 'message') {\\n        throw Error('仅支持 \\\"message\\\" 事件');\\n      }\\n      messageCallback = callback;\\n    },\\n  };\\n}\\n\\nexport function createUnencryptedConnection({ serverUrl, roomId }) {\\n  // 真正的实现实际上会连接到服务器\\n  if (typeof serverUrl !== 'string') {\\n    throw Error('期望 serverUrl 是字符串类型，收到：' + serverUrl);\\n  }\\n  if (typeof roomId !== 'string') {\\n    throw Error('期望 roomId 是字符串类型，收到：' + roomId);\\n  }\\n  let intervalId;\\n  let messageCallback;\\n  return {\\n    connect() {\\n      console.log('✅ 连接到“' + roomId + '”房间（未加密）...');\\n      clearInterval(intervalId);\\n      intervalId = setInterval(() => {\\n        if (messageCallback) {\\n          if (Math.random() > 0.5) {\\n            messageCallback('hey')\\n          } else {\\n            messageCallback('lol');\\n          }\\n        }\\n      }, 3000);\\n    },\\n    disconnect() {\\n      clearInterval(intervalId);\\n      messageCallback = null;\\n      console.log('❌ 断开“' + roomId + '”房间（未加密）');\\n    },\\n    on(event, callback) {\\n      if (messageCallback) {\\n        throw Error('不能添加 handler 2次');\\n      }\\n      if (event !== 'message') {\\n        throw Error('仅支持 \\\"message\\\" 事件');\\n      }\\n      messageCallback = callback;\\n    },\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label, button { display: block; margin-bottom: 5px; }\\n\"}]}]]}]]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"译注\"}],\"：\\n\",[\"$r\",\"a\",null,{\"name\":\"note1\"}],\" 在创建 \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" 函数时，由于闭包的缘故，\",[\"$r\",\"code\",null,{\"children\":\"setCount(count + increment)\"}],\" 捕获的是创建时 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" 值。由于这里的“说谎”，每次重新渲染时新创建的 \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" 函数不能替换掉 Effect 里旧 \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" 函数，于是最终的效果就是 \",[\"$r\",\"code\",null,{\"children\":\"setCount(0 + 1)\"}],\" \",[\"$r\",\"br\",null,{}]]}]]}]]","meta":{"title":"移除 Effect 依赖"}},"__N_SSG":true}