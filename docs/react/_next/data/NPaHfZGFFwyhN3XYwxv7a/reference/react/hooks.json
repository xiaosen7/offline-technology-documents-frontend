{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#state-hooks\",\"depth\":2,\"text\":\"State Hook \"},{\"url\":\"#context-hooks\",\"depth\":2,\"text\":\"Context Hook \"},{\"url\":\"#ref-hooks\",\"depth\":2,\"text\":\"Ref Hook \"},{\"url\":\"#effect-hooks\",\"depth\":2,\"text\":\"Effect Hook \"},{\"url\":\"#performance-hooks\",\"depth\":2,\"text\":\"性能 Hook \"},{\"url\":\"#resource-hooks\",\"depth\":2,\"text\":\"资源 Hook \"},{\"url\":\"#other-hooks\",\"depth\":2,\"text\":\"其他 Hook \"},{\"url\":\"#your-own-hooks\",\"depth\":2,\"text\":\"自定义 Hook \"}]","content":"[[\"$r\",\"MaxWidth\",\"last\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"Hook\"}],\" 可以帮助在组件中使用不同的 React 功能。你可以使用内置的 Hook 或使用自定义 Hook。本页列出了 React 中所有内置 Hook。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"state-hooks\",\"children\":\"State Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"状态帮助组件 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"“记住”用户输入的信息\"}],\"。例如，一个表单组件可以使用状态存储输入值，而一个图像库组件可以使用状态存储所选的图像索引。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"使用以下 Hook 以向组件添加状态：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useState\"}]}],\" 声明可以直接更新的状态变量。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useReducer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useReducer\"}]}],\" 在 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"reducer 函数\"}],\" 中声明带有更新逻辑的 state 变量。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function ImageGallery() {\\n  const [index, setIndex] = useState(0);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"context-hooks\",\"children\":\"Context Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"上下文帮助组件 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":\"从祖先组件接收信息，而无需将其作为 props 传递\"}],\"。例如，应用程序的顶层组件可以借助上下文将 UI 主题传递给所有下方的组件，无论这些组件层级有多深。\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useContext\"}]}],\" 读取订阅上下文。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Button() {\\n  const theme = useContext(ThemeContext);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"ref-hooks\",\"children\":\"Ref Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"ref 允许组件 \",[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs\",\"children\":\"保存一些不用于渲染的信息\"}],\"，比如 DOM 节点或 timeout ID。与状态不同，更新 ref 不会重新渲染组件。ref 是从 React 范例中的“脱围机制”。当需要与非 React 系统如浏览器内置 API 一同工作时，ref 将会非常有用。\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useRef\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useRef\"}]}],\" 声明 ref。你可以在其中保存任何值，但最常用于保存 DOM 节点。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useImperativeHandle\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}]}],\" 自定义从组件中暴露的 ref，但是很少使用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Form() {\\n  const inputRef = useRef(null);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"effect-hooks\",\"children\":\"Effect Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Effect 允许组件 \",[\"$r\",\"a\",null,{\"href\":\"/learn/synchronizing-with-effects\",\"children\":\"连接到外部系统并与之同步\"}],\"。这包括处理网络、浏览器、DOM、动画、使用不同 UI 库编写的小部件以及其他非 React 代码。\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\" 将组件连接到外部系统。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function ChatRoom({ roomId }) {\\n  useEffect(() => {\\n    const connection = createConnection(roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Effect 是从 React 范式中的“脱围机制”。避免使用 Effect 协调应用程序的数据流。如果不需要与外部系统交互，那么 \",[\"$r\",\"a\",null,{\"href\":\"/learn/you-might-not-need-an-effect\",\"children\":\"可能不需要 Effect\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useEffect\"}],\" 有两个很少使用的变换形式，它们在执行时机有所不同：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useLayoutEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}]}],\" 在浏览器重新绘制屏幕前执行，可以在此处测量布局。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useInsertionEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}]}],\" 在 React 对 DOM 进行更改之前触发，库可以在此处插入动态 CSS。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"performance-hooks\",\"children\":\"性能 Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"优化重新渲染性能的一种常见方法是跳过不必要的工作。例如，可以告诉 React 重用缓存的计算结果，或者如果数据自上次渲染以来没有更改，则跳过重新渲染。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"可以使用以下 Hook 跳过计算和不必要的重新渲染：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\" 缓存计算代价昂贵的计算结果。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useCallback\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useCallback\"}]}],\" 将函数传递给优化组件之前缓存函数定义。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function TodoList({ todos, tab, theme }) {\\n  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"有时由于屏幕确实需要更新，无法跳过重新渲染。在这种情况下，可以通过将必须同步的阻塞更新（比如使用输入法输入内容）与不需要阻塞用户界面的非阻塞更新（比如更新图表）分离以提高性能。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"使用以下 Hook 处理渲染优先级：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useTransition\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useTransition\"}]}],\" 允许将状态转换标记为非阻塞，并允许其他更新中断它。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useDeferredValue\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useDeferredValue\"}]}],\" 允许延迟更新 UI 的非关键部分，以让其他部分先更新。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"resource-hooks\",\"children\":\"资源 Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"资源可以被组件访问，而无需将它们作为状态的一部分。例如，组件可以从 Promise 中读取消息，或从上下文中读取样式信息。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"使用以下 Hook 以从资源中读取值：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/use\",\"children\":[\"$r\",\"code\",null,{\"children\":\"use\"}]}],\" 允许读取像 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Promise\"}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"上下文\"}],\" 这样的资源的值。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function MessageComponent({ messagePromise }) {\\n  const message = use(messagePromise);\\n  const theme = use(ThemeContext);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"other-hooks\",\"children\":\"其他 Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这些 Hook 主要适用于库作者，不常在应用程序代码中使用。\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useDebugValue\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useDebugValue\"}]}],\" 自定义 React 开发者工具为自定义 Hook 添加的标签。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useId\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useId\"}]}],\" 将唯一的 ID 与组件相关联，其通常与可访问性 API 一起使用。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useSyncExternalStore\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}]}],\" 订阅外部 store。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"your-own-hooks\",\"children\":\"自定义 Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"开发者可以 \",[\"$r\",\"a\",null,{\"href\":\"/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component\",\"children\":\"自定义 Hook\"}],\" 作为 JavaScript 函数。\"]}]]}]]","meta":{"title":"React 内置 Hook"}},"__N_SSG":true}