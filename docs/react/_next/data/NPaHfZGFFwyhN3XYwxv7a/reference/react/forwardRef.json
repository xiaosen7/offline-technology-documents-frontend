{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#forwardref\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"forwardRef(render)\"}],\" \"]},{\"url\":\"#render-function\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 函数 \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#exposing-a-dom-node-to-the-parent-component\",\"depth\":3,\"text\":\"将 DOM 节点暴露给父组件 \"},{\"url\":\"#forwarding-a-ref-through-multiple-components\",\"depth\":3,\"text\":\"在多个组件中转发 ref \"},{\"url\":\"#exposing-an-imperative-handle-instead-of-a-dom-node\",\"depth\":3,\"text\":\"暴露命令式句柄而非 DOM 节点 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#my-component-is-wrapped-in-forwardref-but-the-ref-to-it-is-always-null\",\"depth\":3,\"text\":[\"我的组件使用了 \",[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\"，但是它的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 总是为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" \"]}]","content":"[[\"$r\",\"MaxWidth\",\"66\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 允许组件使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs\",\"children\":\"ref\"}],\" 将 DOM 节点暴露给父组件。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const SomeComponent = forwardRef(render)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"forwardref\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"forwardRef(render)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"forwardRef()\"}],\" 让组件接收 ref 并将其传递给子组件：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { forwardRef } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  // ...\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请参阅下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\"：组件的渲染函数。React 会调用该函数并传入父组件传递的 props 和 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\"。返回的 JSX 将作为组件的输出。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 返回一个可以在 JSX 中渲染的 React 组件。与作为纯函数定义的 React 组件不同，\",[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 返回的组件还能够接收 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"警告 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在严格模式中，为了 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#my-initializer-or-updater-function-runs-twice\",\"children\":\"帮助找到意外的副作用\"}],\"，React 将会 \",[\"$r\",\"strong\",null,{\"children\":\"调用两次渲染函数\"}],\"。不过这仅限于开发环境，并不会影响生产环境。如果渲染函数是纯函数（也应该是），这不应该影响组件逻辑。其中一个调用的结果将被忽略。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"render-function\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 函数 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 接受一个渲染函数作为参数。React 将会使用 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 调用此函数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const MyInput = forwardRef(function MyInput(props, ref) {\\n  return (\\n    <label>\\n      {props.label}\\n      <input ref={ref} />\\n    </label>\\n  );\\n});\\n\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"render-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"props\"}],\"：父组件传递过来的 props。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"ref\"}],\"：父组件传递的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性。\",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 可以是一个对象或函数。如果父组件没有传递一个 ref，那么它将会是 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。你应该将接收到的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 转发给另一个组件，或者将其传递给 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useImperativeHandle\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"render-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 返回一个可以在 JSX 中渲染的 React 组件。与作为纯函数定义的 React 组件不同，\",[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 返回的组件还能够接收 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"exposing-a-dom-node-to-the-parent-component\",\"children\":\"将 DOM 节点暴露给父组件 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"默认情况下，每个组件的 DOM 节点都是私有的。然而，有时候将 DOM 节点公开给父组件是很有用的，比如允许对它进行聚焦。将组件定义包装在 \",[\"$r\",\"code\",null,{\"children\":\"forwardRef()\"}],\" 中便可以公开 DOM 节点：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,11}\",\"children\":\"import { forwardRef } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  const { label, ...otherProps } = props;\\n  return (\\n    <label>\\n      {label}\\n      <input {...otherProps} />\\n    </label>\\n  );\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你将在 props 之后收到一个 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"ref\"}],\" 作为第二个参数。将其传递到要公开的 DOM 节点中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{8} [[1, 3, \\\"ref\\\"], [1, 8, \\\"ref\\\", 30]]\",\"children\":\"import { forwardRef } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  const { label, ...otherProps } = props;\\n  return (\\n    <label>\\n      {label}\\n      <input {...otherProps} ref={ref} />\\n    </label>\\n  );\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这样，父级的 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件就能够访问 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 暴露的 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" DOM 节点\"]}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 2, \\\"ref\\\"], [1, 10, \\\"ref\\\", 41], [2, 5, \\\"ref.current\\\"]]\",\"children\":\"function Form() {\\n  const ref = useRef(null);\\n\\n  function handleClick() {\\n    ref.current.focus();\\n  }\\n\\n  return (\\n    <form>\\n      <MyInput label=\\\"Enter your name:\\\" ref={ref} />\\n      <button type=\\\"button\\\" onClick={handleClick}>\\n        编辑\\n      </button>\\n    </form>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"该 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useRef#manipulating-the-dom-with-a-ref\",\"children\":\"将 ref 传递至\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\"。\",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件将该 ref \",[\"$r\",\"strong\",null,{\"children\":\"转发\"}],\" 至 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" 浏览器标签。因此，\",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件可以访问该 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" DOM 节点并对其调用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/focus\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"focus()\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"请记住，将组件内部的 ref 暴露给 DOM 节点会使得在稍后更改组件内部更加困难。通常会暴露可重用的低级组件的 DOM 节点，例如按钮或文本输入框，但不会在应用程序级别的组件中这样做，例如头像或评论。\"}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"转发 ref 的示例\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"focusing-a-text-input\",\"children\":\"聚焦文本输入框 \"}],[\"$r\",\"p\",null,{\"children\":[\"点击该按钮将聚焦输入框。\",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件定义了一个 ref 并将其传递到 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件。\",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件将该 ref 转发至浏览器的 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" 标签，这使得 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件可以聚焦该 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\nimport MyInput from './MyInput.js';\\n\\nexport default function Form() {\\n  const ref = useRef(null);\\n\\n  function handleClick() {\\n    ref.current.focus();\\n  }\\n\\n  return (\\n    <form>\\n      <MyInput label=\\\"Enter your name:\\\" ref={ref} />\\n      <button type=\\\"button\\\" onClick={handleClick}>\\n        Edit\\n      </button>\\n    </form>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/MyInput.js\",\"children\":\"import { forwardRef } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  const { label, ...otherProps } = props;\\n  return (\\n    <label>\\n      {label}\\n      <input {...otherProps} ref={ref} />\\n    </label>\\n  );\\n});\\n\\nexport default MyInput;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input {\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"playing-and-pausing-a-video\",\"children\":\"播放和暂停视频 \"}],[\"$r\",\"p\",null,{\"children\":[\"点击按钮将调用 \",[\"$r\",\"code\",null,{\"children\":\"<video>\"}],\" DOM 节点上的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/play\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"play()\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/pause\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"pause()\"}]}],\" 方法。\",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 组件定义了一个 ref 并将其传递到 \",[\"$r\",\"code\",null,{\"children\":\"MyVideoPlayer\"}],\" 组件。\",[\"$r\",\"code\",null,{\"children\":\"MyVideoPlayer\"}],\" 组件将该 ref 转发到浏览器的 \",[\"$r\",\"code\",null,{\"children\":\"<video>\"}],\" 标签。这使得 \",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 组件可以播放和暂停 \",[\"$r\",\"code\",null,{\"children\":\"<video>\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\nimport MyVideoPlayer from './MyVideoPlayer.js';\\n\\nexport default function App() {\\n  const ref = useRef(null);\\n  return (\\n    <>\\n      <button onClick={() => ref.current.play()}>\\n        Play\\n      </button>\\n      <button onClick={() => ref.current.pause()}>\\n        Pause\\n      </button>\\n      <br />\\n      <MyVideoPlayer\\n        ref={ref}\\n        src=\\\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\\\"\\n        type=\\\"video/mp4\\\"\\n        width=\\\"250\\\"\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/MyVideoPlayer.js\",\"children\":\"import { forwardRef } from 'react';\\n\\nconst VideoPlayer = forwardRef(function VideoPlayer({ src, type, width }, ref) {\\n  return (\\n    <video width={width} ref={ref}>\\n      <source\\n        src={src}\\n        type={type}\\n      />\\n    </video>\\n  );\\n});\\n\\nexport default VideoPlayer;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin-bottom: 10px; margin-right: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"82\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"forwarding-a-ref-through-multiple-components\",\"children\":\"在多个组件中转发 ref \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"除了将 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 转发到 DOM 节点外，还可以将其转发到自定义组件，例如 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,5}\",\"children\":\"const FormField = forwardRef(function FormField(props, ref) {\\n  // ...\\n  return (\\n    <>\\n      <MyInput ref={ref} />\\n      ...\\n    </>\\n  );\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件将 ref 转发给它的 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\"，那么 \",[\"$r\",\"code\",null,{\"children\":\"FormField\"}],\" 的 ref 将会获得该 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,5,10}\",\"children\":\"function Form() {\\n  const ref = useRef(null);\\n\\n  function handleClick() {\\n    ref.current.focus();\\n  }\\n\\n  return (\\n    <form>\\n      <FormField label=\\\"Enter your name:\\\" ref={ref} isRequired={true} />\\n      <button type=\\\"button\\\" onClick={handleClick}>\\n        Edit\\n      </button>\\n    </form>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件定义了一个 ref 并将其传递给 \",[\"$r\",\"code\",null,{\"children\":\"FormField\"}],\"。\",[\"$r\",\"code\",null,{\"children\":\"FormField\"}],\" 组件将该 ref 转发给 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\"，后者又将其转发给浏览器的 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" DOM 节点。这就是 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 获取该 DOM 节点的方式。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\nimport FormField from './FormField.js';\\n\\nexport default function Form() {\\n  const ref = useRef(null);\\n\\n  function handleClick() {\\n    ref.current.focus();\\n  }\\n\\n  return (\\n    <form>\\n      <FormField label=\\\"输入你的名字：\\\" ref={ref} isRequired={true} />\\n      <button type=\\\"button\\\" onClick={handleClick}>\\n        编辑\\n      </button>\\n    </form>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/FormField.js\",\"children\":\"import { forwardRef, useState } from 'react';\\nimport MyInput from './MyInput.js';\\n\\nconst FormField = forwardRef(function FormField({ label, isRequired }, ref) {\\n  const [value, setValue] = useState('');\\n  return (\\n    <>\\n      <MyInput\\n        ref={ref}\\n        label={label}\\n        value={value}\\n        onChange={e => setValue(e.target.value)} \\n      />\\n      {(isRequired && value === '') &&\\n        <i>必填</i>\\n      }\\n    </>\\n  );\\n});\\n\\nexport default FormField;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/MyInput.js\",\"children\":\"import { forwardRef } from 'react';\\n\\nconst MyInput = forwardRef((props, ref) => {\\n  const { label, ...otherProps } = props;\\n  return (\\n    <label>\\n      {label}\\n      <input {...otherProps} ref={ref} />\\n    </label>\\n  );\\n});\\n\\nexport default MyInput;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input, button {\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"98\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"exposing-an-imperative-handle-instead-of-a-dom-node\",\"children\":\"暴露命令式句柄而非 DOM 节点 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"可以使用被称为 \",[\"$r\",\"strong\",null,{\"children\":\"命令式句柄（imperative handle）\"}],\" 的自定义对象暴露一个更加受限制的方法集，而非整个 DOM 节点。为了实现这个目的需要定义一个单独的 ref 存储 DOM 节点：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,6}\",\"children\":\"const MyInput = forwardRef(function MyInput(props, ref) {\\n  const inputRef = useRef(null);\\n\\n  // ...\\n\\n  return <input {...props} ref={inputRef} />;\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"将收到的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 传递给 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useImperativeHandle\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}]}],\" 并指定你想要暴露给 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 的值：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6-15}\",\"children\":\"import { forwardRef, useRef, useImperativeHandle } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  const inputRef = useRef(null);\\n\\n  useImperativeHandle(ref, () => {\\n    return {\\n      focus() {\\n        inputRef.current.focus();\\n      },\\n      scrollIntoView() {\\n        inputRef.current.scrollIntoView();\\n      },\\n    };\\n  }, []);\\n\\n  return <input {...props} ref={inputRef} />;\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果某个组件得到了 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 的 ref，则只会接收到 \",[\"$r\",\"code\",null,{\"children\":\"{ focus, scrollIntoView }\"}],\" 对象，而非整个 DOM 节点。这可以让 DOM 节点暴露的信息限制到最小。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\nimport MyInput from './MyInput.js';\\n\\nexport default function Form() {\\n  const ref = useRef(null);\\n\\n  function handleClick() {\\n    ref.current.focus();\\n    // 这行代码不起作用，因为 DOM 节点没有被暴露出来：\\n    // ref.current.style.opacity = 0.5;\\n  }\\n\\n  return (\\n    <form>\\n      <MyInput placeholder=\\\"Enter your name\\\" ref={ref} />\\n      <button type=\\\"button\\\" onClick={handleClick}>\\n        Edit\\n      </button>\\n    </form>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/MyInput.js\",\"children\":\"import { forwardRef, useRef, useImperativeHandle } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  const inputRef = useRef(null);\\n\\n  useImperativeHandle(ref, () => {\\n    return {\\n      focus() {\\n        inputRef.current.focus();\\n      },\\n      scrollIntoView() {\\n        inputRef.current.scrollIntoView();\\n      },\\n    };\\n  }, []);\\n\\n  return <input {...props} ref={inputRef} />;\\n});\\n\\nexport default MyInput;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input {\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/useImperativeHandle\",\"children\":\"了解更多关于命令式句柄的内容\"}],\"。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"不要滥用 ref\"}],\"。只应在无法使用 props 表达的 \",[\"$r\",\"strong\",null,{\"children\":\"命令式\"}],\" 行为中使用 ref：例如滚动到节点、将焦点放在节点上、触发动画，以及选择文本等等。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"如果可以将某些东西使用 props 表达，那就不应该使用 ref\"}],\"。例如，不要从一个 Modal 组件中暴露像 \",[\"$r\",\"code\",null,{\"children\":\"{ open, close }\"}],\" 一样的命令式句柄，更好的做法是将 \",[\"$r\",\"code\",null,{\"children\":\"isOpen\"}],\" 作为 prop，像这样 \",[\"$r\",\"code\",null,{\"children\":\"<Modal isOpen={isOpen} />\"}],\"。\",[\"$r\",\"a\",null,{\"href\":\"/learn/synchronizing-with-effects\",\"children\":\"Effect\"}],\" 可以帮助通过 props 暴露命令式行为。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-component-is-wrapped-in-forwardref-but-the-ref-to-it-is-always-null\",\"children\":[\"我的组件使用了 \",[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\"，但是它的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 总是为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这通常意味着你忘记实际使用你所接收到的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 了。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如，这个组件的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 没有被使用：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1}\",\"children\":\"const MyInput = forwardRef(function MyInput({ label }, ref) {\\n  return (\\n    <label>\\n      {label}\\n      <input />\\n    </label>\\n  );\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了修复它，将 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 传递给一个可以接受 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 的 DOM 节点或另一个组件：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,5}\",\"children\":\"const MyInput = forwardRef(function MyInput({ label }, ref) {\\n  return (\\n    <label>\\n      {label}\\n      <input ref={ref} />\\n    </label>\\n  );\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果某些逻辑是有条件的，\",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 可能也会为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,5}\",\"children\":\"const MyInput = forwardRef(function MyInput({ label, showInput }, ref) {\\n  return (\\n    <label>\\n      {label}\\n      {showInput && <input ref={ref} />}\\n    </label>\\n  );\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"showInput\"}],\" 是 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\"，则 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 将不会被转发到任何节点，并且 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 会保持为空。如果这个条件隐藏在另一个组件中，那么很容易忽略这一点，比如这个例子中的 \",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5,7}\",\"children\":\"const MyInput = forwardRef(function MyInput({ label, showInput }, ref) {\\n  return (\\n    <label>\\n      {label}\\n      <Panel isExpanded={showInput}>\\n        <input ref={ref} />\\n      </Panel>\\n    </label>\\n  );\\n});\\n\"}]}]]}]]","meta":{"title":"forwardRef"}},"__N_SSG":true}