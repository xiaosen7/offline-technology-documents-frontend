{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#useinsertioneffect\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect(setup, dependencies?)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#injecting-dynamic-styles-from-css-in-js-libraries\",\"depth\":3,\"text\":\"从 CSS-in-JS 库中注入动态样式 \"}]","content":"[[\"$r\",\"MaxWidth\",\"last\",{\"children\":[[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 是为 CSS-in-JS 库的作者特意打造的。除非你正在使用 CSS-in-JS 库并且需要注入样式，否则你应该使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\" 或者 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useLayoutEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}]}],\"。\"]}]}],\"\\n\",[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 可以在布局副作用触发之前将元素插入到 DOM 中。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"useInsertionEffect(setup, dependencies?)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"useinsertioneffect\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect(setup, dependencies?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 在任何可能需要读取布局的副作用启动之前插入样式：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useInsertionEffect } from 'react';\\n\\n// 在你的 CSS-in-JS 库中\\nfunction useCSS(rule) {\\n  useInsertionEffect(() => {\\n    // ... 在此注入 <style> 标签 ...\\n  });\\n  return rule;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请参考下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setup\"}],\": The function with your Effect’s logic. Your setup function may also optionally return a \",[\"$r\",\"em\",null,{\"children\":\"cleanup\"}],\" function. When your component is added to the DOM, but before any layout effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"optional\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"dependencies\"}],\": The list of all reactive values referenced inside of the \",[\"$r\",\"code\",null,{\"children\":\"setup\"}],\" code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is \",[\"$r\",\"a\",null,{\"href\":\"/learn/editor-setup#linting\",\"children\":\"configured for React\"}],\", it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like \",[\"$r\",\"code\",null,{\"children\":\"[dep1, dep2, dep3]\"}],\". React will compare each dependency with its previous value using the \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" comparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component.\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"dependencies\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"setup\"}],\" 代码中引用的所有响应式值的列表。响应式值包括 props、state 以及所有直接在组件内部声明的变量和函数。如果你的代码检查工具 \",[\"$r\",\"a\",null,{\"href\":\"/learn/editor-setup#linting\",\"children\":\"配置了 React\"}],\"，那么它将验证是否每个响应式值都被正确地指定为依赖项。依赖列表必须具有固定数量的项，并且必须像 \",[\"$r\",\"code\",null,{\"children\":\"[dep1, dep2, dep3]\"}],\" 这样内联编写。React 将使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 来比较每个依赖项和它先前的值。如果省略此参数，则将在每次重新渲染组件之后重新运行 Effect。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 返回 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Effects only run on the client. They don’t run during server rendering.\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"You can’t update state from inside \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\".\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"By the time \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" runs, refs are not attached yet.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" may run either before or after the DOM has been updated. You shouldn’t rely on the DOM being updated at any particular time.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect, \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" will fire both cleanup and setup one component at a time. This results in an “interleaving” of the cleanup and setup functions.\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"injecting-dynamic-styles-from-css-in-js-libraries\",\"children\":\"从 CSS-in-JS 库中注入动态样式 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"传统上，你会使用纯 CSS 为 React 组件设置样式。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"// 在你的 JS 文件中：\\n<button className=\\\"success\\\" />\\n\\n// 在你的 CSS 文件中：\\n.success { color: green; }\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"有些团队更喜欢直接在 JavaScript 代码中编写样式，而不是编写 CSS 文件。这通常需要使用 CSS-in-JS 库或工具。以下是 CSS-in-JS 三种常见的实现方法：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"使用编译器静态提取到 CSS 文件\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"内联样式，例如 \",[\"$r\",\"code\",null,{\"children\":\"<div style={{ opacity: 1 }}>\"}]]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"运行时注入 \",[\"$r\",\"code\",null,{\"children\":\"<style>\"}],\" 标签\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你使用 CSS-in-JS，我们建议结合使用前两种方法（静态样式使用 CSS 文件，动态样式使用内联样式）。\",[\"$r\",\"strong\",null,{\"children\":[\"我们不建议运行时注入 \",[\"$r\",\"code\",null,{\"children\":\"<style>\"}],\" 标签有两个原因\"]}],\"：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"运行时注入会使浏览器频繁地重新计算样式。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果在 React 生命周期中某个错误的时机进行运行时注入，它可能会非常慢。\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"第一个问题无法解决，但是 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 可以帮助你解决第二个问题。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Call \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" to insert the styles before any layout effects fire:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-11}\",\"children\":\"// 在你的 CSS-in-JS 库中\\nlet isInserted = new Set();\\nfunction useCSS(rule) {\\n  useInsertionEffect(() => {\\n    // 同前所述，我们不建议在运行时注入 <style> 标签。\\n    // 如果你必须这样做，那么应当在 useInsertionEffect 中进行。\\n    if (!isInserted.has(rule)) {\\n      isInserted.add(rule);\\n      document.head.appendChild(getStyleForRule(rule));\\n    }\\n  });\\n  return rule;\\n}\\n\\nfunction Button() {\\n  const className = useCSS('...');\\n  return <div className={className} />;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"与 \",[\"$r\",\"code\",null,{\"children\":\"useEffect\"}],\" 类似，\",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 不在服务端运行。如果你需要收集在服务端上使用了哪些 CSS 规则，你可以在渲染期间进行：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,4-6}\",\"children\":\"let collectedRulesSet = new Set();\\n\\nfunction useCSS(rule) {\\n  if (typeof window === 'undefined') {\\n    collectedRulesSet.add(rule);\\n  }\\n  useInsertionEffect(() => {\\n    // ...\\n  });\\n  return rule;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://github.com/reactwg/react-18/discussions/110\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"阅读更多使用 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 升级 CSS-in-JS 库的相关指南\"]}],\"。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect\",\"children\":[\"这与在渲染期间或 \",[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}],\" 中注入样式相比有何优势？ \"]}],[\"$r\",\"p\",null,{\"children\":[\"如果你在渲染期间注入样式并且 React 正在处理 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useTransition#marking-a-state-update-as-a-non-blocking-transition\",\"children\":\"非阻塞更新\"}],\"，那么浏览器将在渲染组件树时每一帧都会重新计算样式，这可能会 \",[\"$r\",\"strong\",null,{\"children\":\"非常慢\"}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 比在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useLayoutEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}]}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\" 期间注入样式更好。因为它会确保 \",[\"$r\",\"code\",null,{\"children\":\"<style>\"}],\" 标签在其它 Effect 运行前被注入。否则，正常的 Effect 中的布局计算将由于过时的样式而出错。\"]}]]}]]}]]","meta":{"title":"useInsertionEffect"}},"__N_SSG":true}