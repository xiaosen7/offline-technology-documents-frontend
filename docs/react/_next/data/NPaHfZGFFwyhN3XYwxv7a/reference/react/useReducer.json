{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#usereducer\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useReducer(reducer, initialArg, init?)\"}],\" \"]},{\"url\":\"#dispatch\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数 \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#adding-a-reducer-to-a-component\",\"depth\":3,\"text\":\"向组件添加 reducer \"},{\"url\":\"#writing-the-reducer-function\",\"depth\":3,\"text\":\"实现 reducer 函数 \"},{\"url\":\"#avoiding-recreating-the-initial-state\",\"depth\":3,\"text\":\"避免重新创建初始值 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value\",\"depth\":3,\"text\":\"我已经 dispatch 了一个 action，但是打印出来仍然还是旧的 state \"},{\"url\":\"#ive-dispatched-an-action-but-the-screen-doesnt-update\",\"depth\":3,\"text\":\"我已经 dispatch 了一个 action，但是屏幕并没有更新 \"},{\"url\":\"#a-part-of-my-reducer-state-becomes-undefined-after-dispatching\",\"depth\":3,\"text\":[\"在 dispatch 后 state 的某些属性变为了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]},{\"url\":\"#my-entire-reducer-state-becomes-undefined-after-dispatching\",\"depth\":3,\"text\":[\"在 dispatch 后整个 state 都变为了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]},{\"url\":\"#im-getting-an-error-too-many-re-renders\",\"depth\":3,\"text\":\"我收到了一个报错：“Too many re-renders” \"},{\"url\":\"#my-reducer-or-initializer-function-runs-twice\",\"depth\":3,\"text\":\"我的 reducer 和初始化函数运行了两次 \"}]","content":"[[\"$r\",\"MaxWidth\",\"72\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 是一个 React Hook，它允许你向组件里面添加一个 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"reducer\"}],\"。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [state, dispatch] = useReducer(reducer, initialArg, init?)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"usereducer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer(reducer, initialArg, init?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的顶层作用域调用 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 以创建一个用于管理状态的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"reducer\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useReducer } from 'react';\\n\\nfunction reducer(state, action) {\\n  // ...\\n}\\n\\nfunction MyComponent() {\\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"reducer\"}],\"：用于更新 state 的纯函数。参数为 state 和 action，返回值是更新后的 state。state 与 action 可以是任意合法值。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"initialArg\"}],\"：用于初始化 state 的任意值。初始值的计算逻辑取决于接下来的 \",[\"$r\",\"code\",null,{\"children\":\"init\"}],\" 参数。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选参数\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"init\"}],\"：用于计算初始值的函数。如果存在，使用 \",[\"$r\",\"code\",null,{\"children\":\"init(initialArg)\"}],\" 的执行结果作为初始值，否则使用 \",[\"$r\",\"code\",null,{\"children\":\"initialArg\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 返回一个由两个值组成的数组：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"当前的 state。初次渲染时，它是 \",[\"$r\",\"code\",null,{\"children\":\"init(initialArg)\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"initialArg\"}],\" （如果没有 \",[\"$r\",\"code\",null,{\"children\":\"init\"}],\" 函数）。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#dispatch\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数\"]}],\"。用于更新 state 并触发组件的重新渲染。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 是一个 Hook，所以只能在 \",[\"$r\",\"strong\",null,{\"children\":\"组件的顶层作用域\"}],\" 或自定义 Hook 中调用，而不能在循环或条件语句中调用。如果你有这种需求，可以创建一个新的组件，并把 state 移入其中。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"严格模式下 React 会 \",[\"$r\",\"strong\",null,{\"children\":\"调用两次 reducer 和初始化函数\"}],\"，这可以 \",[\"$r\",\"a\",null,{\"href\":\"#my-reducer-or-initializer-function-runs-twice\",\"children\":\"帮助你发现意外的副作用\"}],\"。这只是开发模式下的行为，并不会影响生产环境。只要 reducer 和初始化函数是纯函数（理应如此）就不会改变你的逻辑。其中一个调用结果会被忽略。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"dispatch\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 返回的 \",[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数允许你更新 state 并触发组件的重新渲染。它需要传入一个 action 作为参数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [state, dispatch] = useReducer(reducer, { age: 42 });\\n\\nfunction handleClick() {\\n  dispatch({ type: 'incremented_age' });\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 会调用 \",[\"$r\",\"code\",null,{\"children\":\"reducer\"}],\" 函数以更新 state，\",[\"$r\",\"code\",null,{\"children\":\"reducer\"}],\" 函数的参数为当前的 state 与传递的 action。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"dispatch-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"action\"}],\"：用户执行的操作。可以是任意类型的值。通常来说 action 是一个对象，其中 \",[\"$r\",\"code\",null,{\"children\":\"type\"}],\" 属性标识类型，其它属性携带额外信息。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"dispatch-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数没有返回值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"setstate-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数 \",[\"$r\",\"strong\",null,{\"children\":\"是为下一次渲染而更新 state\"}],\"。因此在调用 \",[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数后读取 state \",[\"$r\",\"a\",null,{\"href\":\"#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value\",\"children\":\"并不会拿到更新后的值\"}],\"，也就是说只能获取到调用前的值。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你提供的新值与当前的 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 相同（使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 比较），React 会 \",[\"$r\",\"strong\",null,{\"children\":\"跳过组件和子组件的重新渲染\"}],\"，这是一种优化手段。虽然在跳过重新渲染前 React 可能会调用你的组件，但是这不应该影响你的代码。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React \",[\"$r\",\"a\",null,{\"href\":\"/learn/queueing-a-series-of-state-updates\",\"children\":\"会批量更新 state\"}],\"。state 会在 \",[\"$r\",\"strong\",null,{\"children\":\"所有事件函数执行完毕\"}],\" 并且已经调用过它的 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数后进行更新，这可以防止在一个事件中多次进行重新渲染。如果在访问 DOM 等极少数情况下需要强制 React 提前更新，可以使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/flushSync\",\"children\":[\"$r\",\"code\",null,{\"children\":\"flushSync\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"adding-a-reducer-to-a-component\",\"children\":\"向组件添加 reducer \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的顶层作用域调用 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 来创建一个用于管理状态（state）的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"reducer\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 8, \\\"state\\\"], [2, 8, \\\"dispatch\\\"], [4, 8, \\\"reducer\\\"], [3, 8, \\\"{ age: 42 }\\\"]]\",\"children\":\"import { useReducer } from 'react';\\n\\nfunction reducer(state, action) {\\n  // ...\\n}\\n\\nfunction MyComponent() {\\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 返回一个由两个值组成的数组：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"当前的 state\"}],\"，首次渲染时为你提供的 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"初始值\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数\"]}],\"，让你可以根据交互修改 state。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了更新屏幕上的内容，使用一个表示用户操作的 action 来调用 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"dispatch\"}]}],\" 函数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 2, \\\"dispatch\\\"]]\",\"children\":\"function handleClick() {\\n  dispatch({ type: 'incremented_age' });\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 会把当前的 state 和这个 action 一起作为参数传给 \",[\"$r\",\"CodeStep\",null,{\"step\":4,\"children\":\"reducer 函数\"}],\"，然后 reducer 计算并返回新的 state，最后 React 保存新的 state，并使用它渲染组件和更新 UI。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useReducer } from 'react';\\n\\nfunction reducer(state, action) {\\n  if (action.type === 'incremented_age') {\\n    return {\\n      age: state.age + 1\\n    };\\n  }\\n  throw Error('Unknown action.');\\n}\\n\\nexport default function Counter() {\\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\\n\\n  return (\\n    <>\\n      <button onClick={() => {\\n        dispatch({ type: 'incremented_age' })\\n      }}>\\n        Increment age\\n      </button>\\n      <p>Hello! You are {state.age}.</p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"98\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useState\"}]}],\" 非常相似，但是它可以让你把状态更新逻辑从事件处理函数中移动到组件外部。详情可以参阅 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer\",\"children\":[\"对比 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}]]}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"writing-the-reducer-function\",\"children\":\"实现 reducer 函数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"reducer 函数的定义如下：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function reducer(state, action) {\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你需要往函数体里面添加计算并返回新的 state 的逻辑。一般会使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/switch\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"switch\"}],\" 语句\"]}],\" 来完成。在 \",[\"$r\",\"code\",null,{\"children\":\"switch\"}],\" 语句中通过匹配 \",[\"$r\",\"code\",null,{\"children\":\"case\"}],\" 条件来计算并返回相应的 state。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-7,10-13}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'incremented_age': {\\n      return {\\n        name: state.name,\\n        age: state.age + 1\\n      };\\n    }\\n    case 'changed_name': {\\n      return {\\n        name: action.nextName,\\n        age: state.age\\n      };\\n    }\\n  }\\n  throw Error('Unknown action: ' + action.type);\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"action 可以是任意类型，不过通常至少是一个存在 \",[\"$r\",\"code\",null,{\"children\":\"type\"}],\" 属性的对象。也就是说它需要携带计算新的 state 值所必须的数据。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5,9-12}\",\"children\":\"function Form() {\\n  const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });\\n  \\n  function handleButtonClick() {\\n    dispatch({ type: 'incremented_age' });\\n  }\\n\\n  function handleInputChange(e) {\\n    dispatch({\\n      type: 'changed_name',\\n      nextName: e.target.value\\n    });\\n  }\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"action 的 type 依赖于组件的实际情况。\",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer#writing-reducers-well\",\"children\":\"即使它会导致数据的多次更新，每个 action 都只描述一次交互\"}],\"。state 的类型也是任意的，不过一般会使用对象或数组。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"迁移状态逻辑至 Reducer 中\"}],\" 来了解更多内容。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"state 是只读的。即使是对象或数组也不要尝试修改它：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,5}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'incremented_age': {\\n      // 🚩 不要像下面这样修改一个对象类型的 state：\\n      state.age = state.age + 1;\\n      return state;\\n    }\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"正确的做法是返回新的对象：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-8}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'incremented_age': {\\n      // ✅ 正确的做法是返回新的对象\\n      return {\\n        ...state,\\n        age: state.age + 1\\n      };\\n    }\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-objects-in-state\",\"children\":\"更新对象类型的 state\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state\",\"children\":\"更新数组类型的 state\"}],\" 来了解更多内容。\"]}]]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"useReducer 的基础示例\",\"titleId\":\"examples-basic\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"form-object\",\"children\":\"表单（对象类型） \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，state 是一个有 \",[\"$r\",\"code\",null,{\"children\":\"name\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 属性的对象。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useReducer } from 'react';\\n\\nfunction reducer(state, action) {\\n  switch (action.type) {\\n    case 'incremented_age': {\\n      return {\\n        name: state.name,\\n        age: state.age + 1\\n      };\\n    }\\n    case 'changed_name': {\\n      return {\\n        name: action.nextName,\\n        age: state.age\\n      };\\n    }\\n  }\\n  throw Error('Unknown action: ' + action.type);\\n}\\n\\nconst initialState = { name: 'Taylor', age: 42 };\\n\\nexport default function Form() {\\n  const [state, dispatch] = useReducer(reducer, initialState);\\n\\n  function handleButtonClick() {\\n    dispatch({ type: 'incremented_age' });\\n  }\\n\\n  function handleInputChange(e) {\\n    dispatch({\\n      type: 'changed_name',\\n      nextName: e.target.value\\n    }); \\n  }\\n\\n  return (\\n    <>\\n      <input\\n        value={state.name}\\n        onChange={handleInputChange}\\n      />\\n      <button onClick={handleButtonClick}>\\n        Increment age\\n      </button>\\n      <p>Hello, {state.name}. You are {state.age}.</p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"todo-list-array\",\"children\":\"代办事项（数组类型） \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，reducer 管理一个名为 tasks 的数组。数组 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state\",\"children\":\"不能使用修改方法\"}],\" 来更新。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useReducer } from 'react';\\nimport AddTask from './AddTask.js';\\nimport TaskList from './TaskList.js';\\n\\nfunction tasksReducer(tasks, action) {\\n  switch (action.type) {\\n    case 'added': {\\n      return [...tasks, {\\n        id: action.id,\\n        text: action.text,\\n        done: false\\n      }];\\n    }\\n    case 'changed': {\\n      return tasks.map(t => {\\n        if (t.id === action.task.id) {\\n          return action.task;\\n        } else {\\n          return t;\\n        }\\n      });\\n    }\\n    case 'deleted': {\\n      return tasks.filter(t => t.id !== action.id);\\n    }\\n    default: {\\n      throw Error('Unknown action: ' + action.type);\\n    }\\n  }\\n}\\n\\nexport default function TaskApp() {\\n  const [tasks, dispatch] = useReducer(\\n    tasksReducer,\\n    initialTasks\\n  );\\n\\n  function handleAddTask(text) {\\n    dispatch({\\n      type: 'added',\\n      id: nextId++,\\n      text: text,\\n    });\\n  }\\n\\n  function handleChangeTask(task) {\\n    dispatch({\\n      type: 'changed',\\n      task: task\\n    });\\n  }\\n\\n  function handleDeleteTask(taskId) {\\n    dispatch({\\n      type: 'deleted',\\n      id: taskId\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <h1>Prague itinerary</h1>\\n      <AddTask\\n        onAddTask={handleAddTask}\\n      />\\n      <TaskList\\n        tasks={tasks}\\n        onChangeTask={handleChangeTask}\\n        onDeleteTask={handleDeleteTask}\\n      />\\n    </>\\n  );\\n}\\n\\nlet nextId = 3;\\nconst initialTasks = [\\n  { id: 0, text: 'Visit Kafka Museum', done: true },\\n  { id: 1, text: 'Watch a puppet show', done: false },\\n  { id: 2, text: 'Lennon Wall pic', done: false }\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js hidden\",\"children\":\"import { useState } from 'react';\\n\\nexport default function AddTask({ onAddTask }) {\\n  const [text, setText] = useState('');\\n  return (\\n    <>\\n      <input\\n        placeholder=\\\"Add task\\\"\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button onClick={() => {\\n        setText('');\\n        onAddTask(text);\\n      }}>Add</button>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js hidden\",\"children\":\"import { useState } from 'react';\\n\\nexport default function TaskList({\\n  tasks,\\n  onChangeTask,\\n  onDeleteTask\\n}) {\\n  return (\\n    <ul>\\n      {tasks.map(task => (\\n        <li key={task.id}>\\n          <Task\\n            task={task}\\n            onChange={onChangeTask}\\n            onDelete={onDeleteTask}\\n          />\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\\nfunction Task({ task, onChange, onDelete }) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  let taskContent;\\n  if (isEditing) {\\n    taskContent = (\\n      <>\\n        <input\\n          value={task.text}\\n          onChange={e => {\\n            onChange({\\n              ...task,\\n              text: e.target.value\\n            });\\n          }} />\\n        <button onClick={() => setIsEditing(false)}>\\n          Save\\n        </button>\\n      </>\\n    );\\n  } else {\\n    taskContent = (\\n      <>\\n        {task.text}\\n        <button onClick={() => setIsEditing(true)}>\\n          Edit\\n        </button>\\n      </>\\n    );\\n  }\\n  return (\\n    <label>\\n      <input\\n        type=\\\"checkbox\\\"\\n        checked={task.done}\\n        onChange={e => {\\n          onChange({\\n            ...task,\\n            done: e.target.checked\\n          });\\n        }}\\n      />\\n      {taskContent}\\n      <button onClick={() => onDelete(task.id)}>\\n        Delete\\n      </button>\\n    </label>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\nli { list-style-type: none; }\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"writing-concise-update-logic-with-immer\",\"children\":\"使用 Immer 编写简洁的更新逻辑 \"}],[\"$r\",\"p\",null,{\"children\":[\"如果使用复制方法更新数组和对象让你不厌其烦，那么可以使用 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/immerjs/use-immer#useimmerreducer\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Immer\"}],\" 这样的库来减少一些重复的样板代码。Immer 让你可以专注于逻辑，因为它在内部均使用复制方法来完成更新：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useImmerReducer } from 'use-immer';\\nimport AddTask from './AddTask.js';\\nimport TaskList from './TaskList.js';\\n\\nfunction tasksReducer(draft, action) {\\n  switch (action.type) {\\n    case 'added': {\\n      draft.push({\\n        id: action.id,\\n        text: action.text,\\n        done: false\\n      });\\n      break;\\n    }\\n    case 'changed': {\\n      const index = draft.findIndex(t =>\\n        t.id === action.task.id\\n      );\\n      draft[index] = action.task;\\n      break;\\n    }\\n    case 'deleted': {\\n      return draft.filter(t => t.id !== action.id);\\n    }\\n    default: {\\n      throw Error('Unknown action: ' + action.type);\\n    }\\n  }\\n}\\n\\nexport default function TaskApp() {\\n  const [tasks, dispatch] = useImmerReducer(\\n    tasksReducer,\\n    initialTasks\\n  );\\n\\n  function handleAddTask(text) {\\n    dispatch({\\n      type: 'added',\\n      id: nextId++,\\n      text: text,\\n    });\\n  }\\n\\n  function handleChangeTask(task) {\\n    dispatch({\\n      type: 'changed',\\n      task: task\\n    });\\n  }\\n\\n  function handleDeleteTask(taskId) {\\n    dispatch({\\n      type: 'deleted',\\n      id: taskId\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <h1>Prague itinerary</h1>\\n      <AddTask\\n        onAddTask={handleAddTask}\\n      />\\n      <TaskList\\n        tasks={tasks}\\n        onChangeTask={handleChangeTask}\\n        onDeleteTask={handleDeleteTask}\\n      />\\n    </>\\n  );\\n}\\n\\nlet nextId = 3;\\nconst initialTasks = [\\n  { id: 0, text: 'Visit Kafka Museum', done: true },\\n  { id: 1, text: 'Watch a puppet show', done: false },\\n  { id: 2, text: 'Lennon Wall pic', done: false },\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js hidden\",\"children\":\"import { useState } from 'react';\\n\\nexport default function AddTask({ onAddTask }) {\\n  const [text, setText] = useState('');\\n  return (\\n    <>\\n      <input\\n        placeholder=\\\"Add task\\\"\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button onClick={() => {\\n        setText('');\\n        onAddTask(text);\\n      }}>Add</button>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js hidden\",\"children\":\"import { useState } from 'react';\\n\\nexport default function TaskList({\\n  tasks,\\n  onChangeTask,\\n  onDeleteTask\\n}) {\\n  return (\\n    <ul>\\n      {tasks.map(task => (\\n        <li key={task.id}>\\n          <Task\\n            task={task}\\n            onChange={onChangeTask}\\n            onDelete={onDeleteTask}\\n          />\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\\nfunction Task({ task, onChange, onDelete }) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  let taskContent;\\n  if (isEditing) {\\n    taskContent = (\\n      <>\\n        <input\\n          value={task.text}\\n          onChange={e => {\\n            onChange({\\n              ...task,\\n              text: e.target.value\\n            });\\n          }} />\\n        <button onClick={() => setIsEditing(false)}>\\n          Save\\n        </button>\\n      </>\\n    );\\n  } else {\\n    taskContent = (\\n      <>\\n        {task.text}\\n        <button onClick={() => setIsEditing(true)}>\\n          Edit\\n        </button>\\n      </>\\n    );\\n  }\\n  return (\\n    <label>\\n      <input\\n        type=\\\"checkbox\\\"\\n        checked={task.done}\\n        onChange={e => {\\n          onChange({\\n            ...task,\\n            done: e.target.checked\\n          });\\n        }}\\n      />\\n      {taskContent}\\n      <button onClick={() => onDelete(task.id)}>\\n        Delete\\n      </button>\\n    </label>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\nli { list-style-type: none; }\\nul, li { margin: 0; padding: 0; }\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"immer\\\": \\\"1.7.3\\\",\\n    \\\"react\\\": \\\"latest\\\",\\n    \\\"react-dom\\\": \\\"latest\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"118\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"avoiding-recreating-the-initial-state\",\"children\":\"避免重新创建初始值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"React 会保存 state 的初始值并在下一次渲染时忽略它。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function createInitialState(username) {\\n  // ...\\n}\\n\\nfunction TodoList({ username }) {\\n  const [state, dispatch] = useReducer(reducer, createInitialState(username));\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"虽然 \",[\"$r\",\"code\",null,{\"children\":\"createInitialState(username)\"}],\" 的返回值只用于初次渲染，但是在每一次渲染的时候都会被调用。如果它创建了比较大的数组或者执行了昂贵的计算就会浪费性能。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以通过给  \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 的第三个参数传入 \",[\"$r\",\"strong\",null,{\"children\":\"初始化函数\"}],\" 来解决这个问题：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6}\",\"children\":\"function createInitialState(username) {\\n  // ...\\n}\\n\\nfunction TodoList({ username }) {\\n  const [state, dispatch] = useReducer(reducer, username, createInitialState);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"需要注意的是你传入的参数是 \",[\"$r\",\"code\",null,{\"children\":\"createInitialState\"}],\" 这个 \",[\"$r\",\"strong\",null,{\"children\":\"函数自身\"}],\"，而不是执行 \",[\"$r\",\"code\",null,{\"children\":\"createInitialState()\"}],\" 后的返回值。这样传参就可以保证初始化函数不会再次运行。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在上面这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"createInitialState\"}],\" 有一个 \",[\"$r\",\"code\",null,{\"children\":\"username\"}],\" 参数。如果初始化函数不需要参数就可以计算出初始值，可以把 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 的第二个参数改为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"使用初始化函数和直接传入初始值的区别\",\"titleId\":\"examples-initializer\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"passing-the-initializer-function\",\"children\":\"使用初始化函数 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个示例使用了一个初始化函数，所以 \",[\"$r\",\"code\",null,{\"children\":\"createInitialState\"}],\" 函数只会在初次渲染的时候进行调用。即使往输入框中输入内容导致组件重新渲染，初始化函数也不会被再次调用。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import TodoList from './TodoList.js';\\n\\nexport default function App() {\\n  return <TodoList username=\\\"Taylor\\\" />;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TodoList.js active\",\"children\":\"import { useReducer } from 'react';\\n\\nfunction createInitialState(username) {\\n  const initialTodos = [];\\n  for (let i = 0; i < 50; i++) {\\n    initialTodos.push({\\n      id: i,\\n      text: username + \\\"'s task #\\\" + (i + 1)\\n    });\\n  }\\n  return {\\n    draft: '',\\n    todos: initialTodos,\\n  };\\n}\\n\\nfunction reducer(state, action) {\\n  switch (action.type) {\\n    case 'changed_draft': {\\n      return {\\n        draft: action.nextDraft,\\n        todos: state.todos,\\n      };\\n    };\\n    case 'added_todo': {\\n      return {\\n        draft: '',\\n        todos: [{\\n          id: state.todos.length,\\n          text: state.draft\\n        }, ...state.todos]\\n      }\\n    }\\n  }\\n  throw Error('Unknown action: ' + action.type);\\n}\\n\\nexport default function TodoList({ username }) {\\n  const [state, dispatch] = useReducer(\\n    reducer,\\n    username,\\n    createInitialState\\n  );\\n  return (\\n    <>\\n      <input\\n        value={state.draft}\\n        onChange={e => {\\n          dispatch({\\n            type: 'changed_draft',\\n            nextDraft: e.target.value\\n          })\\n        }}\\n      />\\n      <button onClick={() => {\\n        dispatch({ type: 'added_todo' });\\n      }}>Add</button>\\n      <ul>\\n        {state.todos.map(item => (\\n          <li key={item.id}>\\n            {item.text}\\n          </li>\\n        ))}\\n      </ul>\\n    </>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"passing-the-initial-state-directly\",\"children\":\"直接传入初始值 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个示例 \",[\"$r\",\"strong\",null,{\"children\":\"没有使用\"}],\" 初始化函数，所以当你往输入框输入内容导致组件重新渲染的时候，\",[\"$r\",\"code\",null,{\"children\":\"createInitialState\"}],\" 函数就会执行。虽然在渲染结果上看没有什么区别，但是多余的逻辑会导致性能变差。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import TodoList from './TodoList.js';\\n\\nexport default function App() {\\n  return <TodoList username=\\\"Taylor\\\" />;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TodoList.js active\",\"children\":\"import { useReducer } from 'react';\\n\\nfunction createInitialState(username) {\\n  const initialTodos = [];\\n  for (let i = 0; i < 50; i++) {\\n    initialTodos.push({\\n      id: i,\\n      text: username + \\\"'s task #\\\" + (i + 1)\\n    });\\n  }\\n  return {\\n    draft: '',\\n    todos: initialTodos,\\n  };\\n}\\n\\nfunction reducer(state, action) {\\n  switch (action.type) {\\n    case 'changed_draft': {\\n      return {\\n        draft: action.nextDraft,\\n        todos: state.todos,\\n      };\\n    };\\n    case 'added_todo': {\\n      return {\\n        draft: '',\\n        todos: [{\\n          id: state.todos.length,\\n          text: state.draft\\n        }, ...state.todos]\\n      }\\n    }\\n  }\\n  throw Error('Unknown action: ' + action.type);\\n}\\n\\nexport default function TodoList({ username }) {\\n  const [state, dispatch] = useReducer(\\n    reducer,\\n    createInitialState(username)\\n  );\\n  return (\\n    <>\\n      <input\\n        value={state.draft}\\n        onChange={e => {\\n          dispatch({\\n            type: 'changed_draft',\\n            nextDraft: e.target.value\\n          })\\n        }}\\n      />\\n      <button onClick={() => {\\n        dispatch({ type: 'added_todo' });\\n      }}>Add</button>\\n      <ul>\\n        {state.todos.map(item => (\\n          <li key={item.id}>\\n            {item.text}\\n          </li>\\n        ))}\\n      </ul>\\n    </>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"ive-dispatched-an-action-but-logging-gives-me-the-old-state-value\",\"children\":\"我已经 dispatch 了一个 action，但是打印出来仍然还是旧的 state \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数 \",[\"$r\",\"strong\",null,{\"children\":\"不会改变当前渲染的 state\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,5,8}\",\"children\":\"function handleClick() {\\n  console.log(state.age);  // 42\\n\\n  dispatch({ type: 'incremented_age' }); // 用 43 进行重新渲染\\n  console.log(state.age);  // 还是 42！\\n\\n  setTimeout(() => {\\n    console.log(state.age); // 一样是 42！\\n  }, 5000);\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这是因为 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"state 的行为和快照一样\"}],\"。更新 state 会使用新的值来对组件进行重新渲染，但是不会改变当前执行的事件处理函数里面 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 的值。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果你需要获取更新后的 state，可以手动调用 reducer 来得到结果：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const action = { type: 'incremented_age' };\\ndispatch(action);\\n\\nconst nextState = reducer(state, action);\\nconsole.log(state);     // { age: 42 }\\nconsole.log(nextState); // { age: 43 }\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"ive-dispatched-an-action-but-the-screen-doesnt-update\",\"children\":\"我已经 dispatch 了一个 action，但是屏幕并没有更新 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 比较更新前后的 state，如果 \",[\"$r\",\"strong\",null,{\"children\":\"它们相等就会跳过这次更新\"}],\"。这通常是因为你直接修改了对象或数组：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-5,9-10}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'incremented_age': {\\n      // 🚩 错误行为：直接修改对象\\n      state.age++;\\n      return state;\\n    }\\n    case 'changed_name': {\\n      // 🚩 错误行为：直接修改对象\\n      state.name = action.nextName;\\n      return state;\\n    }\\n    // ...\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你直接修改并返回了一个 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 对象，所以 React 会跳过这次更新。为了修复这个错误，你应该确保总是 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-objects-in-state\",\"children\":\"使用正确的方式更新对象\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state\",\"children\":\"使用正确的方式更新数组\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-8,11-15}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'incremented_age': {\\n      // ✅ 修复：创建一个新的对象\\n      return {\\n        ...state,\\n        age: state.age + 1\\n      };\\n    }\\n    case 'changed_name': {\\n      // ✅ 修复：创建一个新的对象\\n      return {\\n        ...state,\\n        name: action.nextName\\n      };\\n    }\\n    // ...\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"a-part-of-my-reducer-state-becomes-undefined-after-dispatching\",\"children\":[\"在 dispatch 后 state 的某些属性变为了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请确保每个 \",[\"$r\",\"code\",null,{\"children\":\"case\"}],\" 语句中所返回的新的 state \",[\"$r\",\"strong\",null,{\"children\":\"都复制了当前的属性\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'incremented_age': {\\n      return {\\n        ...state, // 不要忘记复制之前的属性！\\n        age: state.age + 1\\n      };\\n    }\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果上面的代码没有 \",[\"$r\",\"code\",null,{\"children\":\"...state\"}],\" ，返回的新的 state 就只有 \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 属性。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-entire-reducer-state-becomes-undefined-after-dispatching\",\"children\":[\"在 dispatch 后整个 state 都变为了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你的 state 错误地变成了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"，可能是因为你忘记在某个分支返回 state，或者是你遗漏了某些 \",[\"$r\",\"code\",null,{\"children\":\"case\"}],\" 分支。可以通过在 \",[\"$r\",\"code\",null,{\"children\":\"switch\"}],\" 语句之后抛出一个错误来查找原因：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{10}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'incremented_age': {\\n      // ...\\n    }\\n    case 'edited_name': {\\n      // ...\\n    }\\n  }\\n  throw Error('Unknown action: ' + action.type);\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"也可以通过使用 TypeScript 等静态检查工具来发现这类错误。\"}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"im-getting-an-error-too-many-re-renders\",\"children\":\"我收到了一个报错：“Too many re-renders” \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可能会收到这样一条报错信息：\",[\"$r\",\"code\",null,{\"children\":\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"}],\"。这通常是在 \",[\"$r\",\"strong\",null,{\"children\":\"渲染期间\"}],\"  dispatch 了 action 而导致组件进入了无限循环：dispatch（会导致一次重新渲染）、渲染、dispatch（再次导致重新渲染），然后无限循环。大多数这样的错误是由于事件处理函数中存在错误的逻辑：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1-2}\",\"children\":\"// 🚩 错误：渲染期间调用了处理函数\\nreturn <button onClick={handleClick()}>Click me</button>\\n\\n// ✅ 修复：传递一个处理函数，而不是调用\\nreturn <button onClick={handleClick}>Click me</button>\\n\\n// ✅ 修复：传递一个内联的箭头函数\\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你没有发现上述错误，在控制台点开报错旁边的箭头以查看错误堆栈，从中查找是哪个 \",[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数引发的错误。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-reducer-or-initializer-function-runs-twice\",\"children\":\"我的 reducer 和初始化函数运行了两次 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/StrictMode\",\"children\":\"严格模式\"}],\" 下 React 会调用两次 reducer 和初始化函数，但是这不应该会破坏你的代码逻辑。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个 \",[\"$r\",\"strong\",null,{\"children\":\"仅限于开发模式\"}],\" 的行为可以帮助你 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"保持组件纯粹\"}],\"：React 会使用其中一次调用结果并忽略另一个结果。如果你的组件、初始化函数以及 reducer 函数都是纯函数，这并不会影响你的逻辑。不过一旦它们存在副作用，这个额外的行为就可以帮助你发现它。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"比如下面这个 reducer 函数直接修改了数组类型的 state：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-6}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'added_todo': {\\n      // 🚩 错误：直接修改 state\\n      state.todos.push({ id: nextId++, text: action.text });\\n      return state;\\n    }\\n    // ...\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"因为 React 会调用 reducer 函数两次，导致你看到添加了两条代办事项，于是你就发现了这个错误行为。在这个示例中，你可以通过 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state#adding-to-an-array\",\"children\":\"返回新的数组而不是修改数组\"}],\" 来修复它：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-11}\",\"children\":\"function reducer(state, action) {\\n  switch (action.type) {\\n    case 'added_todo': {\\n      // ✅ 修复：返回一个新的 state 数组\\n      return {\\n        ...state,\\n        todos: [\\n          ...state.todos,\\n          { id: nextId++, text: action.text }\\n        ]\\n      };\\n    }\\n    // ...\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在这个 reducer 是纯函数了，调用两次也不会有不一致的行为。这就是 React 如何通过调用两次函数来帮助你发现错误。\",[\"$r\",\"strong\",null,{\"children\":\"只有组件、初始化函数和 reducer 函数需要是纯函数\"}],\"。事件处理函数不需要实现为纯函数，并且 React 永远不会调用事件函数两次。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"保持组件纯粹\"}],\" 以了解更多相关信息。\"]}]]}]]","meta":{"title":"useReducer"}},"__N_SSG":true}