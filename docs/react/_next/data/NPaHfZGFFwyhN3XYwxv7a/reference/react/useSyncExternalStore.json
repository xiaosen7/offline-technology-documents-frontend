{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#usesyncexternalstore\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"使用 \"},{\"url\":\"#subscribing-to-an-external-store\",\"depth\":3,\"text\":\"订阅外部 store \"},{\"url\":\"#subscribing-to-a-browser-api\",\"depth\":3,\"text\":\"订阅浏览器 API \"},{\"url\":\"#extracting-the-logic-to-a-custom-hook\",\"depth\":3,\"text\":\"把逻辑抽取到自定义 Hook \"},{\"url\":\"#adding-support-for-server-rendering\",\"depth\":3,\"text\":\"添加服务端渲染支持 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#im-getting-an-error-the-result-of-getsnapshot-should-be-cached\",\"depth\":3,\"text\":[\"遇到一个错误：“The result of \",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" should be cached” \"]},{\"url\":\"#my-subscribe-function-gets-called-after-every-re-render\",\"depth\":3,\"text\":[\"我的 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数每次重新渲染都被调用 \"]}]","content":"[[\"$r\",\"MaxWidth\",\"54\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\" 是一个让你订阅外部 store 的 React Hook。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"usesyncexternalstore\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件顶层调用 \",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\" 以从外部 store 读取值。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useSyncExternalStore } from 'react';\\nimport { todosStore } from './todoStore.js';\\n\\nfunction TodosApp() {\\n  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"它返回 store 中数据的快照。你需要传两个函数作为参数：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数应当订阅该 store 并返回一个取消订阅的函数。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 函数应当从该 store 读取数据的快照。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请查看下面更多的例子\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\"：一个函数，接收一个单独的 \",[\"$r\",\"code\",null,{\"children\":\"callback\"}],\" 参数并把它订阅到 store 上。当 store 发生改变，它应当调用被提供的 \",[\"$r\",\"code\",null,{\"children\":\"callback\"}],\"。这会导致组件重新渲染。\",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数会返回清除订阅的函数。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\"：一个函数，返回组件需要的 store 中的数据快照。在 store 不变的情况下，重复调用 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 必须返回同一个值。如果 store 改变，并且返回值也不同了（用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 比较），React 就会重新渲染组件。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"getServerSnapshot\"}],\"：一个函数，返回 store 中数据的初始快照。它只会在服务端渲染时，以及在客户端进行服务端渲染内容的 hydration 时被用到。快照在服务端与客户端之间必须相同，它通常是从服务端序列化并传到客户端的。如果你忽略此参数，在服务端渲染这个组件会抛出一个错误。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"该 store 的当前快照，可以在你的渲染逻辑中使用。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"警告 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 返回的 store 快照必须是不可变的。如果底层 store 有可变数据，要在数据改变时返回一个新的不可变快照。否则，返回上次缓存的快照。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果在重新渲染时传入一个不同的 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数，React 会用新传入的 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数重新订阅该 store。你可以通过在组件外声明 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 来避免。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useTransition\",\"children\":\"非阻塞 transition 更新\"}],\" 过程中更改了 store，React 将会回退并将该更新视为阻塞更新。具体来说，在每次 transition 更新时，React 将在将更改应用到 DOM 之前第二次调用 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\"。如果它返回的值与最初调用时不同，React 将重新从头开始进行更新，这次将其作为阻塞更新应用，以确保屏幕上的每个组件都反映 store 的相同版本。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"不建议根据 \",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\" 返回的 store 值暂停渲染。原因是对外部 store 的变更无法 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useTransition\",\"children\":\"被标记为非阻塞 transition 更新\"}],\"，因此它们会触发最近的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Suspense\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"Suspense\"}],\" 后备方案\"]}],\"，用加载旋转器替换已经呈现在屏幕上的内容，通常会导致较差的用户体验。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"例如，以下操作是不建议的：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));\\n\\nfunction ShoppingApp() {\\n  const selectedProductId = useSyncExternalStore(...);\\n\\n  // ❌ Calling `use` with a Promise dependent on `selectedProductId`\\n  const data = use(fetchItem(selectedProductId))\\n\\n  // ❌ Conditionally rendering a lazy component based on `selectedProductId`\\n  return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;\\n}\\n\"}]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"使用 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"subscribing-to-an-external-store\",\"children\":\"订阅外部 store \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你的多数组件只会从它们的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":\"props\"}],\"，\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"state\"}],\"，以及 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useContext\",\"children\":\"context\"}],\" 读取数据。然而，有时一个组件需要从一些 React 之外的 store 读取一些随时间变化的数据。这包括：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"在 React 之外持有状态的第三方状态管理库\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"暴露出一个可变值及订阅其改变事件的浏览器 API\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件顶层调用 \",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\" 以从外部 store 读取值。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 5, \\\"todosStore.subscribe\\\"], [2, 5, \\\"todosStore.getSnapshot\\\"], [3, 5, \\\"todos\\\", 0]]\",\"children\":\"import { useSyncExternalStore } from 'react';\\nimport { todosStore } from './todoStore.js';\\n\\nfunction TodosApp() {\\n  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"它返回 store 中数据的 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"快照\"}],\"。你需要传两个函数作为参数：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数\"]}],\"应当订阅 store 并返回一个取消订阅函数。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 函数\"]}],\"应当从 store 中读取数据的快照。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"React 会用这些函数来保持你的组件订阅到 store 并在它改变时重新渲染。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如，在下面的沙盒中，\",[\"$r\",\"code\",null,{\"children\":\"todosStore\"}],\" 被实现为一个保存 React 之外数据的外部 store。\",[\"$r\",\"code\",null,{\"children\":\"TodosApp\"}],\" 组件通过 \",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\" Hook 连接到外部 store。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useSyncExternalStore } from 'react';\\nimport { todosStore } from './todoStore.js';\\n\\nexport default function TodosApp() {\\n  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\\n  return (\\n    <>\\n      <button onClick={() => todosStore.addTodo()}>Add todo</button>\\n      <hr />\\n      <ul>\\n        {todos.map(todo => (\\n          <li key={todo.id}>{todo.text}</li>\\n        ))}\\n      </ul>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/todoStore.js\",\"children\":\"// 这是一个第三方 store 的例子，\\n// 你可能需要把它与 React 集成。\\n\\n// 如果你的应用完全由 React 构建，\\n// 我们推荐使用 React state 替代。\\n\\nlet nextId = 0;\\nlet todos = [{ id: nextId++, text: 'Todo #1' }];\\nlet listeners = [];\\n\\nexport const todosStore = {\\n  addTodo() {\\n    todos = [...todos, { id: nextId++, text: 'Todo #' + nextId }]\\n    emitChange();\\n  },\\n  subscribe(listener) {\\n    listeners = [...listeners, listener];\\n    return () => {\\n      listeners = listeners.filter(l => l !== listener);\\n    };\\n  },\\n  getSnapshot() {\\n    return todos;\\n  }\\n};\\n\\nfunction emitChange() {\\n  for (let listener of listeners) {\\n    listener();\\n  }\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"78\",{\"children\":[\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"当可能的时候，我们推荐通过 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useState\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useReducer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useReducer\"}]}],\" 使用内建的 React state 代替。如果你需要去集成已有的非 React 代码，\",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\" API 是很有用的。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"subscribing-to-a-browser-api\",\"children\":\"订阅浏览器 API \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"添加 \",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\" 的另一个场景是当你想订阅一些由浏览器暴露的并随时间变化的值时。例如，假设你想要组件展示网络连接是否正常。浏览器通过一个叫做 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/onLine\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"navigator.onLine\"}]}],\" 的属性暴露出这一信息。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个值可能在 React 不知道的情况下改变，所以你应当通过 \",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\" 来读取它。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useSyncExternalStore } from 'react';\\n\\nfunction ChatIndicator() {\\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"从浏览器 API 读取当前值，来实现 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 函数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function getSnapshot() {\\n  return navigator.onLine;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"接下来，你需要实现 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数。例如，当 \",[\"$r\",\"code\",null,{\"children\":\"navigator.onLine\"}],\" 改变，浏览器触发 \",[\"$r\",\"code\",null,{\"children\":\"window\"}],\" 对象的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/online_event\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"online\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/offline_event\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"offline\"}]}],\" 事件，然后返回一个清除订阅的函数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function subscribe(callback) {\\n  window.addEventListener('online', callback);\\n  window.addEventListener('offline', callback);\\n  return () => {\\n    window.removeEventListener('online', callback);\\n    window.removeEventListener('offline', callback);\\n  };\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在 React 知道如何从外部的 \",[\"$r\",\"code\",null,{\"children\":\"navigator.onLine\"}],\" API 读到这个值，以及如何订阅其改变。断开你的设备的网络，就可以观察到组件重新渲染了：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useSyncExternalStore } from 'react';\\n\\nexport default function ChatIndicator() {\\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\\n  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;\\n}\\n\\nfunction getSnapshot() {\\n  return navigator.onLine;\\n}\\n\\nfunction subscribe(callback) {\\n  window.addEventListener('online', callback);\\n  window.addEventListener('offline', callback);\\n  return () => {\\n    window.removeEventListener('online', callback);\\n    window.removeEventListener('offline', callback);\\n  };\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"92\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"extracting-the-logic-to-a-custom-hook\",\"children\":\"把逻辑抽取到自定义 Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常不会在组件里直接用 \",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\"，而是在自定义 Hook 里调用它。这使得你可以在不同组件里使用相同的外部 store。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如：这里自定义的 \",[\"$r\",\"code\",null,{\"children\":\"useOnlineStatus\"}],\" Hook 追踪网络是否在线：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,6}\",\"children\":\"import { useSyncExternalStore } from 'react';\\n\\nexport function useOnlineStatus() {\\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\\n  return isOnline;\\n}\\n\\nfunction getSnapshot() {\\n  // ...\\n}\\n\\nfunction subscribe(callback) {\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在不同的组件都可以调用 \",[\"$r\",\"code\",null,{\"children\":\"useOnlineStatus\"}],\"，而不必重复底层实现：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useOnlineStatus } from './useOnlineStatus.js';\\n\\nfunction StatusBar() {\\n  const isOnline = useOnlineStatus();\\n  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;\\n}\\n\\nfunction SaveButton() {\\n  const isOnline = useOnlineStatus();\\n\\n  function handleSaveClick() {\\n    console.log('✅ Progress saved');\\n  }\\n\\n  return (\\n    <button disabled={!isOnline} onClick={handleSaveClick}>\\n      {isOnline ? 'Save progress' : 'Reconnecting...'}\\n    </button>\\n  );\\n}\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <SaveButton />\\n      <StatusBar />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/useOnlineStatus.js\",\"children\":\"import { useSyncExternalStore } from 'react';\\n\\nexport function useOnlineStatus() {\\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\\n  return isOnline;\\n}\\n\\nfunction getSnapshot() {\\n  return navigator.onLine;\\n}\\n\\nfunction subscribe(callback) {\\n  window.addEventListener('online', callback);\\n  window.addEventListener('offline', callback);\\n  return () => {\\n    window.removeEventListener('online', callback);\\n    window.removeEventListener('offline', callback);\\n  };\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"adding-support-for-server-rendering\",\"children\":\"添加服务端渲染支持 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你的 React 应用使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/server\",\"children\":\"服务端渲染\"}],\"，你的 React 组件也会运行在浏览器环境之外来生成初始 HTML。这给连接到外部 store 造成了一些挑战：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果你连接到一个浏览器特有的 API，因为它在服务端不存在，所以是不可行的。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果你连接到一个第三方 store，数据要在服务端和客户端之间相匹配。\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了解决这些问题，要传一个 \",[\"$r\",\"code\",null,{\"children\":\"getServerSnapshot\"}],\" 函数作为第三个参数给 \",[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,12-14}\",\"children\":\"import { useSyncExternalStore } from 'react';\\n\\nexport function useOnlineStatus() {\\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\\n  return isOnline;\\n}\\n\\nfunction getSnapshot() {\\n  return navigator.onLine;\\n}\\n\\nfunction getServerSnapshot() {\\n  return true; // 服务端生成的 HTML 总是显示“在线”\\n}\\n\\nfunction subscribe(callback) {\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"getServerSnapshot\"}],\" 函数与 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 相似，但它只在两种情况下才运行：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"在服务端生成 HTML 时。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在客户端 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/hydrateRoot\",\"children\":\"hydration\"}],\" 时，即：当 React 拿到服务端的 HTML 并使其可交互。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content\",\"children\":\"force rendering on the client.\"}]]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"确保客户端初始渲染与服务端渲染时 \",[\"$r\",\"code\",null,{\"children\":\"getServerSnapshot\"}],\" 返回完全相同的数据。例如，如果在服务端 \",[\"$r\",\"code\",null,{\"children\":\"getServerSnapshot\"}],\" 返回一些预先载入的 store 内容，你就需要把这些内容也传给客户端。一种方法是在服务端渲染时，生成 \",[\"$r\",\"code\",null,{\"children\":\"<script>\"}],\" 标签来设置像 \",[\"$r\",\"code\",null,{\"children\":\"window.MY_STORE_DATA\"}],\" 这样的全局变量，并在客户端 \",[\"$r\",\"code\",null,{\"children\":\"getServerSnapshot\"}],\" 内读取此全局变量。你的外部 store 应当提供如何这样做的说明。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"im-getting-an-error-the-result-of-getsnapshot-should-be-cached\",\"children\":[\"遇到一个错误：“The result of \",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" should be cached” \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个错误意味着你的 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 函数每次调用都返回了一个新对象，例如：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-5}\",\"children\":\"function getSnapshot() {\\n  // 🔴 getSnapshot 不要总是返回不同的对象\\n  return {\\n    todos: myStore.todos\\n  };\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 返回值不同于上一次，React 会重新渲染组件。这就是为什么，如果总是返回一个不同的值，会进入到一个无限循环，并产生这个报错。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"只有当确实有东西改变了，\",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 才应该返回一个不同的对象。如果你的 store 包含不可变数据，可以直接返回此数据：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-3}\",\"children\":\"function getSnapshot() {\\n  // ✅ 你可以返回不可变数据\\n  return myStore.todos;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你的 store 数据是可变的，\",[\"$r\",\"code\",null,{\"children\":\"getSnapshot\"}],\" 函数应当返回一个它的不可变快照。这意味着 \",[\"$r\",\"strong\",null,{\"children\":\"确实\"}],\" 需要创建新对象，但不是每次调用都如此。而是应当保存最后一次计算得到的快照，并且在 store 中的数据不变的情况下，返回与上一次相同的快照。如何决定可变数据发生了改变则取决于你的可变 store。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-subscribe-function-gets-called-after-every-re-render\",\"children\":[\"我的 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数每次重新渲染都被调用 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这里的 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数是在组件 \",[\"$r\",\"strong\",null,{\"children\":\"内部\"}],\" 定义的，所以它每次渲染都不同：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-7}\",\"children\":\"function ChatIndicator() {\\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\\n  \\n  // 🚩 总是不同的函数，所以 React 每次重新渲染都会重新订阅\\n  function subscribe() {\\n    // ...\\n  }\\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果重新渲染时你传一个不同的 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数，React 会重新订阅你的 store。如果这造成了性能问题，因而你想避免重新订阅，就把 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 函数移到外面：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6-9}\",\"children\":\"function ChatIndicator() {\\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\\n  // ...\\n}\\n\\n// ✅ 总是相同的函数，所以 React 不需要重新订阅\\nfunction subscribe() {\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"或者，把 \",[\"$r\",\"code\",null,{\"children\":\"subscribe\"}],\" 包在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useCallback\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useCallback\"}]}],\" 里面以便只在某些参数改变时重新订阅：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-8}\",\"children\":\"function ChatIndicator({ userId }) {\\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\\n  \\n  // ✅ 只要 userId 不变，都是同一个函数\\n  const subscribe = useCallback(() => {\\n    // ...\\n  }, [userId]);\\n\\n  // ...\\n}\\n\"}]}]]}]]","meta":{"title":"useSyncExternalStore"}},"__N_SSG":true}