{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#fragment\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#returning-multiple-elements\",\"depth\":3,\"text\":\"返回多个元素 \"},{\"url\":\"#assigning-multiple-elements-to-a-variable\",\"depth\":3,\"text\":\"分配多个元素给一个变量 \"},{\"url\":\"#grouping-elements-with-text\",\"depth\":3,\"text\":\"组合文本与组件 \"},{\"url\":\"#rendering-a-list-of-fragments\",\"depth\":3,\"text\":[\"渲染 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 列表 \"]}]","content":"[[\"$r\",\"MaxWidth\",\"32\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\" 通常使用 \",[\"$r\",\"code\",null,{\"children\":\"<>...</>\"}],\" 代替，它们都允许你在不添加额外节点的情况下将子元素组合。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<>\\n  <OneChild />\\n  <AnotherChild />\\n</>\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"fragment\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你需要单个元素时，你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\" 将其他元素组合起来，使用 \",[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\" 组合后的元素不会对 DOM 产生影响，就像元素没有被组合一样。在大多数情况下，\",[\"$r\",\"code\",null,{\"children\":\"<Fragment></Fragment>\"}],\" 可以简写为空的 JSX 元素 \",[\"$r\",\"code\",null,{\"children\":\"<></>\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"props\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"：列表中 \",[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\" 的可以拥有 \",[\"$r\",\"a\",null,{\"href\":\"/learn/rendering-lists#keeping-list-items-in-order-with-key\",\"children\":\"keys\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你要传递 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 给一个 \",[\"$r\",\"code\",null,{\"children\":\"<Fragment>\"}],\"，你不能使用 \",[\"$r\",\"code\",null,{\"children\":\"<>...</>\"}],\"，你必须从 \",[\"$r\",\"code\",null,{\"children\":\"'react'\"}],\" 中导入 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 且表示为\",[\"$r\",\"code\",null,{\"children\":\"<Fragment key={yourKey}>...</Fragment>\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你要从 \",[\"$r\",\"code\",null,{\"children\":\"<><Child /></>\"}],\" 转换为  \",[\"$r\",\"code\",null,{\"children\":\"[<Child />]\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"<><Child /></>\"}],\" 转换为 \",[\"$r\",\"code\",null,{\"children\":\"<Child />\"}],\"，React 并不会\",[\"$r\",\"a\",null,{\"href\":\"/learn/preserving-and-resetting-state\",\"children\":\"重置 state\"}],\"。这个规则只在一层深度的情况下生效，如果从 \",[\"$r\",\"code\",null,{\"children\":\"<><><Child /></></>\"}],\" 转换为 \",[\"$r\",\"code\",null,{\"children\":\"<Child />\"}],\" 则会重置 state。在\",[\"$r\",\"a\",null,{\"href\":\"https://gist.github.com/clemmy/b3ef00f9507909429d8aa0d3ee4f986b\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"这里\"}],\"查看更详细的介绍。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"returning-multiple-elements\",\"children\":\"返回多个元素 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 或简写语法 \",[\"$r\",\"code\",null,{\"children\":\"<>...</>\"}],\" 将多个元素组合在一起，你可以使用它将多个元素等效于单个元素。例如，一个组件只能返回一个元素，但是可以使用 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 将多个元素组合在一起，并作为一个元素返回：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,6}\",\"children\":\"function Post() {\\n  return (\\n    <>\\n      <PostTitle />\\n      <PostBody />\\n    </>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 作用很大，它与将元素包裹在一个 DOM 容器中不同，使用 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 对元素进行组合后不会影响布局和样式。如果你使用浏览器调试工具查看这个示例，你会发现所有的 \",[\"$r\",\"code\",null,{\"children\":\"<h1>\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"<article>\"}],\" DOM 节点都是没有父元素的兄弟节点：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"export default function Blog() {\\n  return (\\n    <>\\n      <Post title=\\\"An update\\\" body=\\\"It's been a while since I posted...\\\" />\\n      <Post title=\\\"My new blog\\\" body=\\\"I am starting a new blog!\\\" />\\n    </>\\n  )\\n}\\n\\nfunction Post({ title, body }) {\\n  return (\\n    <>\\n      <PostTitle title={title} />\\n      <PostBody body={body} />\\n    </>\\n  );\\n}\\n\\nfunction PostTitle({ title }) {\\n  return <h1>{title}</h1>\\n}\\n\\nfunction PostBody({ body }) {\\n  return (\\n    <article>\\n      <p>{body}</p>\\n    </article>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"62\",{\"children\":[\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"how-to-write-a-fragment-without-the-special-syntax\",\"children\":[\"如何使用完整的语法编写 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\"？ \"]}],[\"$r\",\"p\",null,{\"children\":[\"这个示例从 React 中导入了 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\"：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,5,8}\",\"children\":\"import { Fragment } from 'react';\\n\\nfunction Post() {\\n  return (\\n    <Fragment>\\n      <PostTitle />\\n      <PostBody />\\n    </Fragment>\\n  );\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"通常你不需要这样，除非你需要将 \",[\"$r\",\"a\",null,{\"href\":\"#rendering-a-list-of-fragments\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 传递给 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}]]}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"assigning-multiple-elements-to-a-variable\",\"children\":\"分配多个元素给一个变量 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"和其他元素一样，你可以将 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 元素分配给变量，作为 props 传递等：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function CloseDialog() {\\n  const buttons = (\\n    <>\\n      <OKButton />\\n      <CancelButton />\\n    </>\\n  );\\n  return (\\n    <AlertDialog buttons={buttons}>\\n      Are you sure you want to leave this page?\\n    </AlertDialog>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"grouping-elements-with-text\",\"children\":\"组合文本与组件 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 将文本与组件组合在一起：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function DateRangePicker({ start, end }) {\\n  return (\\n    <>\\n      From\\n      <DatePicker date={start} />\\n      to\\n      <DatePicker date={end} />\\n    </>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-a-list-of-fragments\",\"children\":[\"渲染 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 列表 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这种情况下，你需要显式地表示为 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\"，而不是使用简写语法 \",[\"$r\",\"code\",null,{\"children\":\"<></>\"}],\"。当你在\",[\"$r\",\"a\",null,{\"href\":\"/learn/rendering-lists\",\"children\":\"循环中渲染多个元素\"}],\"时，你需要为每一个元素分配一个 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"。如果这个元素为 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\" 时，则需要使用普通的 JSX 语法来提供 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 属性。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,6}\",\"children\":\"function Blog() {\\n  return posts.map(post =>\\n    <Fragment key={post.id}>\\n      <PostTitle title={post.title} />\\n      <PostBody body={post.body} />\\n    </Fragment>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以查看 DOM 以验证组合后的子元素实际上并没有父元素 \",[\"$r\",\"code\",null,{\"children\":\"Fragment\"}],\"：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Fragment } from 'react';\\n\\nconst posts = [\\n  { id: 1, title: 'An update', body: \\\"It's been a while since I posted...\\\" },\\n  { id: 2, title: 'My new blog', body: 'I am starting a new blog!' }\\n];\\n\\nexport default function Blog() {\\n  return posts.map(post =>\\n    <Fragment key={post.id}>\\n      <PostTitle title={post.title} />\\n      <PostBody body={post.body} />\\n    </Fragment>\\n  );\\n}\\n\\nfunction PostTitle({ title }) {\\n  return <h1>{title}</h1>\\n}\\n\\nfunction PostBody({ body }) {\\n  return (\\n    <article>\\n      <p>{body}</p>\\n    </article>\\n  );\\n}\\n\"}]}]}]]","meta":{"title":"<Fragment> (<>...</>)"}},"__N_SSG":true}