{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#component\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"Component\"}],\" \"]},{\"url\":\"#context\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"context\"}],\" \"]},{\"url\":\"#props\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"props\"}],\" \"]},{\"url\":\"#refs\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"refs\"}],\" \"]},{\"url\":\"#state\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"state\"}],\" \"]},{\"url\":\"#constructor\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"constructor(props)\"}],\" \"]},{\"url\":\"#componentdidcatch\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"componentDidCatch(error, info)\"}],\" \"]},{\"url\":\"#componentdidmount\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"componentDidMount()\"}],\" \"]},{\"url\":\"#componentdidupdate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate(prevProps, prevState, snapshot?)\"}],\" \"]},{\"url\":\"#componentwillmount\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"componentWillMount()\"}],\" \"]},{\"url\":\"#componentwillreceiveprops\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"componentWillReceiveProps(nextProps)\"}],\" \"]},{\"url\":\"#componentwillupdate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"componentWillUpdate(nextProps, nextState)\"}],\" \"]},{\"url\":\"#componentwillunmount\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount()\"}],\" \"]},{\"url\":\"#forceupdate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"forceUpdate(callback?)\"}],\" \"]},{\"url\":\"#getchildcontext\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"getChildContext()\"}],\" \"]},{\"url\":\"#getsnapshotbeforeupdate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate(prevProps, prevState)\"}],\" \"]},{\"url\":\"#render\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"render()\"}],\" \"]},{\"url\":\"#setstate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"setState(nextState, callback?)\"}],\" \"]},{\"url\":\"#shouldcomponentupdate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate(nextProps, nextState, nextContext)\"}],\" \"]},{\"url\":\"#unsafe_componentwillmount\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount()\"}],\" \"]},{\"url\":\"#unsafe_componentwillreceiveprops\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps(nextProps, nextContext)\"}],\" \"]},{\"url\":\"#unsafe_componentwillupdate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate(nextProps, nextState)\"}],\" \"]},{\"url\":\"#static-childcontexttypes\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"static childContextTypes\"}],\" \"]},{\"url\":\"#static-contexttypes\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"static contextTypes\"}],\" \"]},{\"url\":\"#static-contexttype\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"static contextType\"}],\" \"]},{\"url\":\"#static-defaultprops\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"static defaultProps\"}],\" \"]},{\"url\":\"#static-proptypes\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"static propTypes\"}],\" \"]},{\"url\":\"#static-getderivedstatefromerror\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError(error)\"}],\" \"]},{\"url\":\"#static-getderivedstatefromprops\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps(props, state)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#defining-a-class-component\",\"depth\":3,\"text\":\"定义类式组件 \"},{\"url\":\"#adding-state-to-a-class-component\",\"depth\":3,\"text\":\"向类式组件添加 state \"},{\"url\":\"#adding-lifecycle-methods-to-a-class-component\",\"depth\":3,\"text\":\"向类式组件中添加生命周期方法 \"},{\"url\":\"#catching-rendering-errors-with-an-error-boundary\",\"depth\":3,\"text\":\"使用错误边界捕获渲染错误 \"},{\"url\":\"#alternatives\",\"depth\":2,\"text\":\"备选方案 \"},{\"url\":\"#migrating-a-simple-component-from-a-class-to-a-function\",\"depth\":3,\"text\":\"将简单的类式组件迁移为函数式 \"},{\"url\":\"#migrating-a-component-with-state-from-a-class-to-a-function\",\"depth\":3,\"text\":\"将具有 state 的类式组件迁移到函数 \"},{\"url\":\"#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function\",\"depth\":3,\"text\":\"将具有生命周期方法的组件从类迁移到函数 \"},{\"url\":\"#migrating-a-component-with-context-from-a-class-to-a-function\",\"depth\":3,\"text\":\"将具有 context 的组件从类迁移到函数 \"}]","content":"[[\"$r\",\"MaxWidth\",\"542\",{\"children\":[[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"我们建议使用函数式组件，而不是类式组件。\",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"了解如何迁移\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"Component\"}],\" 是一个 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"JavaScript 类\"}],\"，其被定义为 React 组件的基类，类式组件仍然被 React 支持，但我们不建议在新代码中使用它们。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"class Greeting extends Component {\\n  render() {\\n    return <h1>Hello, {this.props.name}!</h1>;\\n  }\\n}\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"component\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"Component\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果想要使用类式组件，需要继承内置的 \",[\"$r\",\"code\",null,{\"children\":\"Component\"}],\" 类并定义 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法\"]}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Component } from 'react';\\n\\nclass Greeting extends Component {\\n  render() {\\n    return <h1>Hello, {this.props.name}!</h1>;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"只有 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法是必要的，其他方法是可选的。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"context\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"context\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"类式组件可以通过使用 \",[\"$r\",\"code\",null,{\"children\":\"this.context\"}],\" 访问 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。只有使用 \",[\"$r\",\"a\",null,{\"href\":\"#static-contexttype\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static contextType\"}]}],\"（最新的）或者 \",[\"$r\",\"a\",null,{\"href\":\"#static-contexttypes\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static contextTypes\"}]}],\"（已废弃）特别指定想要接受 \",[\"$r\",\"strong\",null,{\"children\":\"哪一个\"}],\" context 时才会有效。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"类式组件一次只能读取一个 context。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,5}\",\"children\":\"class Button extends Component {\\n  static contextType = ThemeContext;\\n\\n  render() {\\n    const theme = this.context;\\n    const className = 'button-' + theme;\\n    return (\\n      <button className={className}>\\n        {this.props.children}\\n      </button>\\n    );\\n  }\\n}\\n\\n\"}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"在类式组件中读取 \",[\"$r\",\"code\",null,{\"children\":\"this.context\"}],\" 等同于在函数式组件中使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useContext\"}]}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-context-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"props\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"props\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"this.props\"}],\" 能够访问一个类组件的 props。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3}\",\"children\":\"class Greeting extends Component {\\n  render() {\\n    return <h1>Hello, {this.props.name}!</h1>;\\n  }\\n}\\n\\n<Greeting name=\\\"Taylor\\\" />\\n\"}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"在类式组件中读取 \",[\"$r\",\"code\",null,{\"children\":\"this.props\"}],\" 等同于在函数式组件中使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#step-2-read-props-inside-the-child-component\",\"children\":\"声明式 props\"}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#migrating-a-simple-component-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"refs\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"refs\"}],\" \"]}],\"\\n\",[\"$r\",\"Deprecated\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"这个 API 将在 React 未来的主版本中被移除。\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createRef\",\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"createRef\"}],\" 来代替\"]}],\"。\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"允许你获取此组件 \",[\"$r\",\"a\",null,{\"href\":\"https://reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"过时的字符串 ref\"}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"state\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"state\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\" 来访问一个类式组件的 state。\",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 字段必须是一个对象。请不要直接改变 state 的值。如果你希望改变 state，那么请使用新的 state 来调用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 函数。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-4,7-9,18}\",\"children\":\"class Counter extends Component {\\n  state = {\\n    age: 42,\\n  };\\n\\n  handleAgeChange = () => {\\n    this.setState({\\n      age: this.state.age + 1 \\n    });\\n  };\\n\\n  render() {\\n    return (\\n      <>\\n        <button onClick={this.handleAgeChange}>\\n        增加年龄\\n        </button>\\n        <p>你{this.state.age}岁了。</p>\\n      </>\\n    );\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"在类式组件中定义 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 等同于在函数式组件中调用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useState\"}]}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-state-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"constructor\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"constructor(props)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"constructor\"}],\" 会在你的类式组件 \",[\"$r\",\"strong\",null,{\"children\":\"挂载\"}],\"（添加到屏幕上）之前运行。一般来说，在 React 中 constructor 仅用于两个目的。它可以让你来声明 state 以及将你的类方法 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_objects/Function/bind\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"绑定\"}],\" 到你的类实例上。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-6}\",\"children\":\"class Counter extends Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = { counter: 0 };\\n    this.handleClick = this.handleClick.bind(this);\\n  }\\n\\n  handleClick() {\\n    // ...\\n  }\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你使用较新的 JavaScript 语法的话，那么很少需要使用到 constructors。相反，你可以使用现代浏览器和像 \",[\"$r\",\"a\",null,{\"href\":\"https://babeljs.io/\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Babel\"}],\" 这样的工具都支持的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Public_class_fields\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"公有类字段语法\"}],\" 来重写上面的代码：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,4}\",\"children\":\"class Counter extends Component {\\n  state = { counter: 0 };\\n\\n  handleClick = () => {\\n    // ...\\n  }\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"构造函数不应包含任何存在副作用或者事件监听相关的代码。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"constructor-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"props\"}],\"：组件初始的 props。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"constructor-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"constructor\"}],\" 不应该返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"constructor-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"不要在 constructor 中运行任何副作用或者监听相关的代码。使用 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\" 来应对这种需求。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 constructor 中，你需要在其他的声明之前调用 \",[\"$r\",\"code\",null,{\"children\":\"super(props)\"}],\"。如果你不这样做，\",[\"$r\",\"code\",null,{\"children\":\"this.props\"}],\" 在 constructor 运行时就会为 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"，这可能会造成困惑并且导致错误。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Constructor 中是唯一一个你能直接赋值 \",[\"$r\",\"a\",null,{\"href\":\"#state\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.state\"}]}],\" 的地方。在其余所有方法中，你需要使用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.setState()\"}]}],\" 来代替。不要在 constructor 中使用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/server\",\"children\":\"服务端渲染\"}],\" 时，constructor 也将在服务端运行，然后紧接着会运行 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render\"}]}],\" 方法。然而，像 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 或者 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 这样的生命周期方法将不会在服务端运行。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/StrictMode\",\"children\":\"严格模式\"}],\" 打开时，React 将会在开发过程中调用两次 \",[\"$r\",\"code\",null,{\"children\":\"constructor\"}],\" 然后丢弃其中的一个实例。这有助于你注意到需要从 \",[\"$r\",\"code\",null,{\"children\":\"constructor\"}],\" 中移出的意外的副作用。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"在函数式组件中没有与 \",[\"$r\",\"code\",null,{\"children\":\"constructor\"}],\" 作用完全相同的函数。要在函数式组件中声明 state 请调用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useState\"}]}],\" 来避免重新计算初始的 state，\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#avoiding-recreating-the-initial-state\",\"children\":[\"传递一个函数给 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}]]}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"componentdidcatch\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidCatch(error, info)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}],\"，那么 React 将在某些子组件（包括后代组件）在渲染过程中抛出错误时调用它。这使得你可以在生产中将该错误记录到错误报告服务中。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"一般来说，它与 \",[\"$r\",\"a\",null,{\"href\":\"#static-getderivedstatefromerror\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError\"}]}],\" 一起使用，这样做允许你更新 state 来响应错误并向用户显示错误消息。具有这些方法的组件称为 \",[\"$r\",\"strong\",null,{\"children\":\"错误边界\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#catching-rendering-errors-with-an-error-boundary\",\"children\":\"查看示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidcatch-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"error\"}],\"：被抛出的错误。实际上，它通常会是一个 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Error\"}]}],\" 的实例，但是这并不能保证，因为 JavaScript 允许 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/throw\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"抛出\"}]}],\" 所有值，包括字符串甚至是 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"info\"}],\"：一个包含有关错误的附加信息的对象。它的 \",[\"$r\",\"code\",null,{\"children\":\"componentStack\"}],\" 字段包含一个关于有关组件的堆栈跟踪，以及其所有父组件的名称和源位置。在生产中，组件名称将被简化。如果你设置了生产错误报告服务，则可以使用源映射来解码组件堆栈，就像处理常规 JavaScript 错误堆栈一样。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidcatch-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}],\" 不应该返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidcatch-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在以前经常会在 \",[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}],\" 中使用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 来更新 UI 以及显示后备错误消息。我们反对这种方法，更赞同定义 \",[\"$r\",\"a\",null,{\"href\":\"#static-getderivedstatefromerror\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}],\" 在 React 生产环境和开发环境中处理错误的方式有所不同，在开发环境下，错误将冒泡至 \",[\"$r\",\"code\",null,{\"children\":\"window\"}],\"，这意味着任何 \",[\"$r\",\"code\",null,{\"children\":\"window.onerror\"}],\" 或者 \",[\"$r\",\"code\",null,{\"children\":\"window.addEventListener('error', callback)\"}],\" 事件都将中断被 \",[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}],\" 所捕获到的错误。而在生产环境下则相反，错误并不会冒泡，这意味着任何父级的错误处理器都只会接收到被 \",[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}],\" 捕获的非显式错误。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"在函数式组件中没有与 \",[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}],\" 作用完全相同的函数。如果你想要避免创建类式组件，那么可以单独写一个像上面一样的 \",[\"$r\",\"code\",null,{\"children\":\"错误边界\"}],\" 并在整个应用中使用它。又或者，你可以使用 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/bvaughn/react-error-boundary\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"react-error-boundary\"}]}],\" 包，它可以完成同样的工作。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"componentdidmount\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidMount()\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 方法，React 将会在组件被添加到屏幕上 \",[\"$r\",\"strong\",null,{\"children\":\"（挂载）\"}],\" 后调用它。这里是设置数据获取、订阅监听事件或操作 DOM 节点的常见位置。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你要实现 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\"，你通常需要设置一些其他的生命周期函数来避免出错。例如，如果 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 读取一些 state 或者 props，你还必须要设置 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\" 来处理它们的更新，以及设置 \",[\"$r\",\"a\",null,{\"href\":\"#componentwillunmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}]}],\" 来清理 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 的效果。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6-8}\",\"children\":\"class ChatRoom extends Component {\\n  state = {\\n    serverUrl: 'https://localhost:1234'\\n  };\\n\\n  componentDidMount() {\\n    this.setupConnection();\\n  }\\n\\n  componentDidUpdate(prevProps, prevState) {\\n    if (\\n      this.props.roomId !== prevProps.roomId ||\\n      this.state.serverUrl !== prevState.serverUrl\\n    ) {\\n      this.destroyConnection();\\n      this.setupConnection();\\n    }\\n  }\\n\\n  componentWillUnmount() {\\n    this.destroyConnection();\\n  }\\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#adding-lifecycle-methods-to-a-class-component\",\"children\":\"查看更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidmount-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 不需要任何参数。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidmount-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 不应该返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidmount-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/StrictMode\",\"children\":\"严格模式\"}],\" 开启时，在开发环境中 React 会调用 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\"，然后会立刻调用 \",[\"$r\",\"a\",null,{\"href\":\"#componentwillunmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}]}],\"，接着再次调用 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\"。这将帮助你注意到你是否忘记设置 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 或者它的逻辑是否完全对应到 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 的效果。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"虽然你可以在 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 中立即调用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"setState\"}]}],\"，不过最好避免这样做。因为这将触发一次浏览器更新屏幕之前发生的额外的渲染。在这种情况下即使 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render\"}]}],\" 被调用了两次，用户也无法看到中间的状态。请谨慎使用这种模式因为它可能会造成性能问题。在大多数情况下，你应该能在 \",[\"$r\",\"a\",null,{\"href\":\"#constructor\",\"children\":[\"$r\",\"code\",null,{\"children\":\"constructor\"}]}],\" 中设置初始的 state。但是对于 modal 和 tooltip 等当你的渲染依赖于 DOM 节点的大小或位置情况下，这种方法可能是必要的。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"对于大多数的使用场景来说，在类式组件中一起定义 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 等同于在函数式组件中调用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\"。在一些少数的情况，例如在浏览器绘制前执行代码很重要时，更像是等同于 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useLayoutEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}]}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"componentdidupdate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate(prevProps, prevState, snapshot?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 方法，那么 React 会在你的组件更新了 props 或 state 重新渲染后立即调用它。这个方法不会在首次渲染时调用。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以在一次更新后使用它来操作 DOM。处理网络请求时也可能会使用这个方法，只要你将当前的 props 与以前的 props 进行比较（因为，如果 props 没有更改，则可能不需要网络请求）。这个方法一般会和 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\" 以及 \",[\"$r\",\"a\",null,{\"href\":\"#componentwillunmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}]}],\" 一起使用：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{10-18}\",\"children\":\"class ChatRoom extends Component {\\n  state = {\\n    serverUrl: 'https://localhost:1234'\\n  };\\n\\n  componentDidMount() {\\n    this.setupConnection();\\n  }\\n\\n  componentDidUpdate(prevProps, prevState) {\\n    if (\\n      this.props.roomId !== prevProps.roomId ||\\n      this.state.serverUrl !== prevState.serverUrl\\n    ) {\\n      this.destroyConnection();\\n      this.setupConnection();\\n    }\\n  }\\n\\n  componentWillUnmount() {\\n    this.destroyConnection();\\n  }\\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#adding-lifecycle-methods-to-a-class-component\",\"children\":\"查看更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidupdate-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"prevProps\"}],\"：更新之前的 props。\",[\"$r\",\"code\",null,{\"children\":\"prevProps\"}],\" 将会与 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.props\"}]}],\" 进行比较来确定发生了什么改变。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"prevState\"}],\"：更新之前的 state。\",[\"$r\",\"code\",null,{\"children\":\"prevState\"}],\" 将会与 \",[\"$r\",\"a\",null,{\"href\":\"#state\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.state\"}]}],\" 进行比较来确定发生了什么改变。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"snapshot\"}],\"：如果你实现了 \",[\"$r\",\"a\",null,{\"href\":\"#getsnapshotbeforeupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}]}],\" 方法，那么 \",[\"$r\",\"code\",null,{\"children\":\"snapshot\"}],\" 将包含从该方法返回的值。否则它将是 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidupdate-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 不应该返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentdidupdate-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"a\",null,{\"href\":\"#shouldcomponentupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}]}],\" 并且返回值是 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\" 的话，那么 \",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 将不会被调用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 内部的逻辑通常应该包含在比较 \",[\"$r\",\"code\",null,{\"children\":\"this.props\"}],\" 与 \",[\"$r\",\"code\",null,{\"children\":\"prevProps\"}],\" 以及 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\" 与 \",[\"$r\",\"code\",null,{\"children\":\"prevState\"}],\" 的条件之中。否则就会存在创建无限循环的风险。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"虽然你可以在 \",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 中直接调用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"setState\"}]}],\"，但最好尽可能避免这样做。因为它将触发一次发生在浏览器更新屏幕内容之前的额外渲染，在这种情况下，即使 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render\"}]}],\" 会被调用两次，用户也看不到中间状态。这种模式通常会导致性能问题，但是对于 modal 和 tooltip 等当你的渲染依赖于 DOM 节点的大小或位置情况下，这种方法可能是必要的。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"对于大多数用例来说，在类式组件中一起定义 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 等同于在函数式组件中定义 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\"。在一些少数的情况，例如在浏览器绘制前执行代码很重要时，更像是等同于 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useLayoutEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}]}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"componentwillmount\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentWillMount()\"}],\" \"]}],\"\\n\",[\"$r\",\"Deprecated\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"此 API 已从 \",[\"$r\",\"code\",null,{\"children\":\"componentWillMount\"}],\" 重命名为 \",[\"$r\",\"a\",null,{\"href\":\"#unsafe_componentwillmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount\"}]}],\"。旧名称已被弃用，在 React 未来的主版本中，只有新名称才有效。\"]}],[\"$r\",\"p\",null,{\"children\":[\"运行 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"rename-unsafe-lifecycles\"}],\" codemod\"]}],\" 来自动更新你的组件。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"componentwillreceiveprops\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentWillReceiveProps(nextProps)\"}],\" \"]}],\"\\n\",[\"$r\",\"Deprecated\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"此 API 已从 \",[\"$r\",\"code\",null,{\"children\":\"componentWillReceiveProps\"}],\" 重命名为 \",[\"$r\",\"a\",null,{\"href\":\"#unsafe_componentwillreceiveprops\",\"children\":[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}]}],\"。旧名称已被弃用，在 React 未来的主版本中，只有新名称才有效。\"]}],[\"$r\",\"p\",null,{\"children\":[\"运行 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"rename-unsafe-lifecycles\"}],\" codemod\"]}],\" 来自动更新你的组件。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"componentwillupdate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentWillUpdate(nextProps, nextState)\"}],\" \"]}],\"\\n\",[\"$r\",\"Deprecated\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"此 API 已从 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUpdate\"}],\" 重命名为 \",[\"$r\",\"a\",null,{\"href\":\"#unsafe_componentwillupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}]}],\"。旧名称已被弃用，在 React 未来的主版本中，只有新名称才有效。\"]}],[\"$r\",\"p\",null,{\"children\":[\"运行 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"rename-unsafe-lifecycles\"}],\" 重构器\"]}],\" 来自动更新你的组件。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"componentwillunmount\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount()\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 方法，React 会在你的组件被移除屏幕（\",[\"$r\",\"strong\",null,{\"children\":\"卸载\"}],\"）之前调用它。此方法常常用于取消数据获取或移除监听事件。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 内部的逻辑应该完全“对应”到 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\" 内部的逻辑，例如，如果你在 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 中设置了一个监听事件，那么 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 中就应该清除掉这个监听事件。如果你的 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 的清理逻辑中读取了一些 props 或者 state，那么你通常还需要实现一个 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\" 来清理使用了旧 props 和 state 的资源（例如监听事件）。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{20-22}\",\"children\":\"class ChatRoom extends Component {\\n  state = {\\n    serverUrl: 'https://localhost:1234'\\n  };\\n\\n  componentDidMount() {\\n    this.setupConnection();\\n  }\\n\\n  componentDidUpdate(prevProps, prevState) {\\n    if (\\n      this.props.roomId !== prevProps.roomId ||\\n      this.state.serverUrl !== prevState.serverUrl\\n    ) {\\n      this.destroyConnection();\\n      this.setupConnection();\\n    }\\n  }\\n\\n  componentWillUnmount() {\\n    this.destroyConnection();\\n  }\\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#adding-lifecycle-methods-to-a-class-component\",\"children\":\"查看更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentwillunmount-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 不需要任何参数。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentwillunmount-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 不应该返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"componentwillunmount-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"当 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/StrictMode\",\"children\":\"严格模式\"}],\" 开启时，在开发中 React 会在调用 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\" 后立即调用 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\"，接着再次调用 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\"。这可以帮助你注意到你是否忘记实现 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\"，或者它的逻辑是否没有完全对应到 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 的效果。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"对于许多用例来说，在类式组件中一起定义 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 等同于在函数式组件中使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\"。在一些少数的情况，例如在浏览器绘制前执行代码很重要时，更像是等同于 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useLayoutEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}]}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"forceupdate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"forceUpdate(callback?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"强制组件重新渲染。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常来说，这是没必要的。如果组件的 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render\"}]}],\" 方法仅读取了 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.props\"}]}],\"、\",[\"$r\",\"a\",null,{\"href\":\"#state\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.state\"}]}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"#context\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.context\"}]}],\" 时，当你在组件或其任一父组件内调用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"setState\"}]}],\" 时，它就将自动重新渲染。但是如果组件的 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法是直接读取外部数据源时，则必须告诉 React 在该数据源更改时更新用户界面。这就是 \",[\"$r\",\"code\",null,{\"children\":\"forceUpdate\"}],\" 的作用。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"尽量避免使用 \",[\"$r\",\"code\",null,{\"children\":\"forceUpdate\"}],\" 并且在 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 中尽量只读取 \",[\"$r\",\"code\",null,{\"children\":\"this.props\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"forceupdate-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选的\"}],\" 如果指定了 \",[\"$r\",\"code\",null,{\"children\":\"callback\"}],\"，React 将在提交完更新后调用你提供的 \",[\"$r\",\"code\",null,{\"children\":\"callback\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"forceupdate-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"forceUpdate\"}],\" 不返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"forceupdate-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你调用了 \",[\"$r\",\"code\",null,{\"children\":\"forceUpdate\"}],\"，React 将重新渲染而且不会调用 \",[\"$r\",\"a\",null,{\"href\":\"#shouldComponentupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"读取外部数据源并强制类式组件使用 \",[\"$r\",\"code\",null,{\"children\":\"forceUpdate\"}],\" 来重新渲染更改已被函数式组件中的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useSyncExternalStore\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useSyncExternalStore\"}]}],\" 所取代。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"getchildcontext\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"getChildContext()\"}],\" \"]}],\"\\n\",[\"$r\",\"Deprecated\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"该 API 将在 React 未来的主版本中删除。\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createContext#provider\",\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"Context.Provider\"}],\" 代替\"]}],\"。\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"允许你指定由该组件提供的 \",[\"$r\",\"a\",null,{\"href\":\"https://reactjs.org/docs/legacy-context.html\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"历史用法的 context\"}],\" 的值。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"getsnapshotbeforeupdate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate(prevProps, prevState)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你实现了 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}],\"，React 会在 React 更新 DOM 之前时直接调用它。它使你的组件能够在 DOM 发生更改之前捕获一些信息（例如滚动的位置）。此生命周期方法返回的任何值都将作为参数传递给 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"例如，你可以在像是需要在更新期间保留其滚动位置的聊天消息的 UI 中来使用它。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-15,17}\",\"children\":\"class ScrollingList extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.listRef = React.createRef();\\n  }\\n\\n  getSnapshotBeforeUpdate(prevProps, prevState) {\\n    // 我们是否要向列表中添加新内容？\\n    // 捕获滚动的​​位置，以便我们稍后可以调整滚动。\\n    if (prevProps.list.length < this.props.list.length) {\\n      const list = this.listRef.current;\\n      return list.scrollHeight - list.scrollTop;\\n    }\\n    return null;\\n  }\\n\\n  componentDidUpdate(prevProps, prevState, snapshot) {\\n    // 如果我们有快照值，那么说明我们刚刚添加了新内容。\\n    // 调整滚动，使得这些新内容不会将旧内容推出视野。\\n    //（这里的 snapshot 是 getSnapshotBeforeUpdate 返回的值）\\n    if (snapshot !== null) {\\n      const list = this.listRef.current;\\n      list.scrollTop = list.scrollHeight - snapshot;\\n    }\\n  }\\n\\n  render() {\\n    return (\\n      <div ref={this.listRef}>{/* ...contents... */}</div>\\n    );\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在上面的示例中，能直接在 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}],\" 中读取到 \",[\"$r\",\"code\",null,{\"children\":\"scrollHeight\"}],\" 属性非常重要。在 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render\"}]}],\"、\",[\"$r\",\"a\",null,{\"href\":\"#unsafe_componentwillreceiveprops\",\"children\":[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}]}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"#unsafe_componentwillupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}]}],\" 中读取它是不安全的，因为这些方法的调用与 React 更新 DOM 之间存在潜在的时间间隔。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"getsnapshotbeforeupdate-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"prevProps\"}],\"：更新之前的 Props。\",[\"$r\",\"code\",null,{\"children\":\"prevProps\"}],\" 将会与 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.props\"}]}],\" 进行比较来确定发生了什么改变。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"prevState\"}],\"：更新之前的 State。\",[\"$r\",\"code\",null,{\"children\":\"prevState\"}],\" 将会与 \",[\"$r\",\"a\",null,{\"href\":\"#state\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.state\"}]}],\" 进行比较来确定发生了什么改变。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"getsnapshotbeforeupdate-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你应该返回你想要的任何类型的快照值，或者是 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。你返回的值将作为第三个参数传递给 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"getsnapshotbeforeupdate-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"a\",null,{\"href\":\"#shouldcomponentUpdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}]}],\" 并返回了 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\"，则 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}],\" 不会被调用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"目前，函数式组件中还没有与 \",[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}],\" 等同的方法。这种使用场景非常罕见，但如果你有这种需求，那么你就必须编写一个类式组件。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"render\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"render()\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法是类式组件中唯一必需的方法。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法应该指定你想要在屏幕上显示的内容，例如：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-6}\",\"children\":\"import { Component } from 'react';\\n\\nclass Greeting extends Component {\\n  render() {\\n    return <h1>Hello, {this.props.name}!</h1>;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 可能随时调用 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法，因此你不应该假设它将在某一特定时间运行。一般来说，\",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法应该返回一段 \",[\"$r\",\"a\",null,{\"href\":\"/learn/writing-markup-with-jsx\",\"children\":\"JSX\"}],\"，但它也支持一些 \",[\"$r\",\"a\",null,{\"href\":\"#render-returns\",\"children\":\"其他的返回类型\"}],\"（如字符串）。为了计算返回的 JSX，\",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法可以读取 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.props\"}]}],\"、\",[\"$r\",\"a\",null,{\"href\":\"#state\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.state\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"#context\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.context\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你应该将 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法编写为纯函数，这意味着如果它使用的 props、state 和 context 相同的话，它应该返回相同的结果。它也不应该包含副作用（例如订阅监听事件）或与浏览器 API 交互。副作用应该发生在事件处理程序或 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\" 等方法中。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"render-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 不需要任何参数。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"render-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 可以返回任何有效的 React 节点。其中包括 React 元素，例如 \",[\"$r\",\"code\",null,{\"children\":\"<div />\"}],\"、字符串、数字、\",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/createPortal\",\"children\":\"portals\"}],\"、空节点（\",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"true\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\"）以及 React 节点数组。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"render-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 应该写成关于 props、state 和 context 的纯函数，它不应该包含副作用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果定义了 \",[\"$r\",\"a\",null,{\"href\":\"#shouldcomponentupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}]}],\" 并返回 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\" 的话，则 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 不会被调用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/StrictMode\",\"children\":\"严格模式\"}],\" 开启时，React 将在开发过程中调用两次 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\"，然后丢弃其中一个结果。这可以帮助你注意到需要从 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法中移出的意外的副作用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 的调用和后续的 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 的调用之间没有一一对应的关系。React 可能会在有益的情况下丢弃一些 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 的调用结果。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"setstate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"setState(nextState, callback?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 来更新 React 组件的 state。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{8-10}\",\"children\":\"class Form extends Component {\\n  state = {\\n    name: 'Taylor',\\n  };\\n\\n  handleNameChange = (e) => {\\n    const newName = e.target.value;\\n    this.setState({\\n      name: newName\\n    });\\n  }\\n\\n  render() {\\n    return (\\n      <>\\n        <input value={this.state.name} onChange={this.handleNameChange} />\\n        <p>Hello, {this.state.name}.</p>\\n      </>\\n    );\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 将组件的 state 的更改加入队列。它告诉 React 该组件及其子组件需要使用新的 state 来重新渲染。这是更新用户界面来响应交互的主要方式。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 时 \",[\"$r\",\"strong\",null,{\"children\":\"不会\"}],\" 更改已执行代码中当前的 state：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6}\",\"children\":\"function handleClick() {\\n  console.log(this.state.name); // \\\"Taylor\\\"\\n  this.setState({\\n    name: 'Robin'\\n  });\\n  console.log(this.state.name); // 依然是 \\\"Taylor\\\"!\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"它只影响从 \",[\"$r\",\"strong\",null,{\"children\":\"下一个\"}],\" 渲染开始返回的 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你还可以将函数传递给 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\"。它允许你根据先前的 state 来更新 state：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-6}\",\"children\":\"  handleIncreaseAge = () => {\\n    this.setState(prevState => {\\n      return {\\n        age: prevState.age + 1\\n      };\\n    });\\n  }\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你不必这样做，但如果你想在同一事件期间多次更新状态，这样就会很方便。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"setstate-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\"：一个对象或者函数。\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你传递一个对象作为 \",[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\"，它将浅层合并到 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\" 中。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你传递一个函数作为 \",[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\"，它将被视为 \",[\"$r\",\"strong\",null,{\"children\":\"更新函数\"}],\"。它必须是个纯函数，应该以已加载的 state 和 props 作为参数，并且应该返回要浅层合并到 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\" 中的对象。React 会将你的更新函数放入队列中并重新渲染你的组件。在下一次渲染期间，React 将通过应用队列中的所有的更新函数来计算下一个 state。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选的\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"callback\"}],\"：如果你指定该函数，React 将在提交更新后调用你提供的 \",[\"$r\",\"code\",null,{\"children\":\"callback\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"setstate-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 不会返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"setstate-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"将 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 视为 \",[\"$r\",\"strong\",null,{\"children\":\"请求\"}],\" 而会不是立即更新组件的命令。当多个组件更新它们的 state 来响应事件时，React 将批量更新它们，并在这次事件结束时将它们一并重新渲染。在极少数情况下，你需要强制同步应用特定的 state 更新，这时你可以将其包装在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/flushSync\",\"children\":[\"$r\",\"code\",null,{\"children\":\"flushSync\"}]}],\" 中，但这可能会损害性能。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 不会立即更新 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\"。这让在调用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 之后立即读取 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 成为了一个潜在的陷阱。相反请使用 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\" 或设置 setState的 \",[\"$r\",\"code\",null,{\"children\":\"callback\"}],\" 参数，其中任何一个都保证读取 state 将在 state 的更新后触发。如果需要根据前一个 state 来设置 state，那么可以传递给 \",[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\" 一个函数，如上所述。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"在类式组件中调用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 等同于在函数式组件中调用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#setstate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数\"]}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-state-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"shouldcomponentupdate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate(nextProps, nextState, nextContext)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}],\"，React 将调用它来确定是否可以跳过重新渲染。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你确定你想手动编写它，你可以将 \",[\"$r\",\"code\",null,{\"children\":\"this.props\"}],\" 与 \",[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\" 以及 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\" 与 \",[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\" 进行比较，并返回 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\" 来告诉 React 可以跳过更新。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6-18}\",\"children\":\"class Rectangle extends Component {\\n  state = {\\n    isHovered: false\\n  };\\n\\n  shouldComponentUpdate(nextProps, nextState) {\\n    if (\\n      nextProps.position.x === this.props.position.x &&\\n      nextProps.position.y === this.props.position.y &&\\n      nextProps.size.width === this.props.size.width &&\\n      nextProps.size.height === this.props.size.height &&\\n      nextState.isHovered === this.state.isHovered\\n    ) {\\n      // 没有任何改变，因此不需要重新渲染\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  // ...\\n}\\n\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当收到新的 props 或 state 时，React 会在渲染之前调用 \",[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}],\"，默认值为 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\"。初始渲染或使用 \",[\"$r\",\"a\",null,{\"href\":\"#forceupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"forceUpdate\"}]}],\" 时将不会调用此方法。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"shouldcomponentupdate-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\"：组件即将用来渲染的下一个 props。将 \",[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\" 与 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.props\"}]}],\" 进行比较以确定发生了什么变化。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\"：组件即将渲染的下一个 state。将 \",[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\" 与 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.state\"}]}],\" 进行比较以确定发生了什么变化。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextContext\"}],\"：组件将要渲染的下一个 context。将 \",[\"$r\",\"code\",null,{\"children\":\"nextContext\"}],\" 与 \",[\"$r\",\"a\",null,{\"href\":\"#context\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.context\"}]}],\" 进行比较以确定发生了什么变化。仅当你指定了 \",[\"$r\",\"a\",null,{\"href\":\"#static-contexttype\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static contextType\"}]}],\"（更新的）或 \",[\"$r\",\"a\",null,{\"href\":\"#static-contexttypes\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static contextTypes\"}]}],\"（旧版）时才可用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"shouldcomponentupdate-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你希望组件重新渲染的话就返回 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\"。这是也是默认执行的操作。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"返回 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\" 来告诉 React 可以跳过重新渲染。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"shouldcomponentupdate-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"此方法 \",[\"$r\",\"strong\",null,{\"children\":\"仅仅\"}],\" 作为性能优化而存在。如果你的组件在没有它的情况下损坏，请先修复组件。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"可以考虑使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/PureComponent\",\"children\":[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}]}],\" 而不是手写 \",[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}],\"。\",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 会浅比较 props 和 state 以及减少错过必要更新的概率。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"我们不建议在 \",[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}],\" 中使用深度相等检查或使用 \",[\"$r\",\"code\",null,{\"children\":\"JSON.stringify\"}],\"。因为它使性能变得不可预测并且它与每个 prop 和 state 的数据结构有关。在最好的情况下，你可能会面临给应用程序引入多秒停顿的风险，而在最坏的情况下，你可能会面临使应用程序崩溃的风险。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"返回 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\" 并不会阻止子组件在 \",[\"$r\",\"strong\",null,{\"children\":\"他们的\"}],\" state 发生变化时重新渲染。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"返回 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\" 并不能 \",[\"$r\",\"strong\",null,{\"children\":\"确保\"}],\" 组件不会重新渲染。React 将使用返回值作为提示，但如果是出于其他有意义的原因，它仍然可能选择重新渲染你的组件。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}],\" 来优化类式组件与使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\" 来优化函数式组件类似。函数式组件还使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\" 来提供更精细的优化。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"unsafe_componentwillmount\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount()\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount\"}],\"，React 会在 \",[\"$r\",\"a\",null,{\"href\":\"#constructor\",\"children\":[\"$r\",\"code\",null,{\"children\":\"constructor\"}]}],\" 之后就立即调用它。它仅因历史原因而存在，不应在任何新代码中使用。相反请使用其他替代方案：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"要初始化状态，请将 \",[\"$r\",\"a\",null,{\"href\":\"#state\",\"children\":[\"$r\",\"code\",null,{\"children\":\"state\"}]}],\" 声明为类字段或在 \",[\"$r\",\"a\",null,{\"href\":\"#constructor\",\"children\":[\"$r\",\"code\",null,{\"children\":\"constructor\"}]}],\" 内设置 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你需要运行额外作用或订阅监听事件事件，请将该逻辑移至 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"查看避免不安全生命周期的示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillmount-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount\"}],\" 不需要任何参数。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillmount-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount\"}],\" 不应该返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillmount-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果组件实现了 \",[\"$r\",\"a\",null,{\"href\":\"#static-getdrivenstatefromprops\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps\"}]}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"#getsnapshotbeforeupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}]}],\"，则不会调用 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"尽管它的名字是这样的，但是如果你的应用程序使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Sus%E2%80%8B%E2%80%8Bpense\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Suspense\"}]}],\" 等新式的 React 功能时，\",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount\"}],\" 不保证组件 \",[\"$r\",\"strong\",null,{\"children\":\"将\"}],\" 被挂载。如果渲染尝试被中止（例如，因为某些子组件的代码尚未加载），那么 React 将丢弃正在进行的树，并在下一次尝试期间尝试从头开始构建组件。这就是为什么这种方法是 \",[\"$r\",\"strong\",null,{\"children\":\"不安全\"}],\" 的。依赖于挂载（例如添加监听事件）的代码应放入 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount\"}],\" 是运行 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/server\",\"children\":\"服务器渲染\"}],\" 期间运行的唯一生命周期方法。对于所有实际上的用途来说，它与 \",[\"$r\",\"a\",null,{\"href\":\"#constructor\",\"children\":[\"$r\",\"code\",null,{\"children\":\"constructor\"}]}],\" 相同，因此你应该使用 \",[\"$r\",\"code\",null,{\"children\":\"constructor\"}],\" 来代替这种类型的逻辑。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"在类式组件中的 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillMount\"}],\" 内部调用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"setState\"}]}],\" 来初始化状态等同于函数式组件中用该 state 作为初始 state 传递给 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useState\"}]}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"unsafe_componentwillreceiveprops\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps(nextProps, nextContext)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}],\"，React 会在组件收到新的 props 时调用它。它仅因历史原因而存在，不应在任何新代码中使用。相反请使用以下替代方案：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你需要 \",[\"$r\",\"strong\",null,{\"children\":\"运行副作用\"}],\"（例如，获取数据、运行动画或重新初始化监听）来响应 prop 的更改，那么请将该逻辑移至 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你需要 \",[\"$r\",\"strong\",null,{\"children\":\"避免仅 prop 更改时就重新计算某些数据\"}],\" 时，请使用 \",[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"memoization helper\"}],\" 来代替。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你需要 \",[\"$r\",\"strong\",null,{\"children\":\"在 prop 更改时“重置”某些状态\"}],\" 时，请考虑使组件 \",[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/06/07/you-probously-%E4%B8%8D%E9%9C%80%E8%A6%81%E6%B4%BE%E7%94%9F%E7%8A%B6%E6%80%81%E3%80%82html#recommendation-fully-controlled-component\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"完全控制\"}],\" 或者 \",[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"使用 key 使组件完全不受控\"}],\" 来代替。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你需要 \",[\"$r\",\"strong\",null,{\"children\":\"在 prop 更改时“调整”某些状态\"}],\" 时，请检查你是否可以在渲染期间单独从 props 计算所有必要的信息。如果不能，请使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component#static-getdrivenstatefromprops\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps\"}]}],\" 代替。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"查看避免不安全生命周期的示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillreceiveprops-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\"：组件即将从父组件接收的下一个 props。可以将 \",[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\" 与 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.props\"}]}],\" 进行比较以确定具体是什么地方发生了变化。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextContext\"}],\"：组件即将从最近的 provider 中接收的下一个 context。可以将 \",[\"$r\",\"code\",null,{\"children\":\"nextContext\"}],\" 与 \",[\"$r\",\"a\",null,{\"href\":\"#context\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.context\"}]}],\" 进行比较以确定具体是什么地方发生了变化。仅在指定 \",[\"$r\",\"a\",null,{\"href\":\"#static-contexttype\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static contextType\"}]}],\"）（最新用法）或 \",[\"$r\",\"a\",null,{\"href\":\"#static-contexttypes\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static contextTypes\"}]}],\" 时可用（传统用法）。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillreceiveprops-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}],\" 不应该返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillreceiveprops-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果组件实现了 \",[\"$r\",\"a\",null,{\"href\":\"#static-getdrivenstatefromprops\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps\"}]}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"#getsnapshotbeforeupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}]}],\"，则不会调用 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"尽管它的名字是这样的，但如果你的应用程序使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Sus%E2%80%8B%E2%80%8Bpense\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Suspense\"}]}],\" 等新式的 React 功能时，\",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}],\" 不保证组件 \",[\"$r\",\"strong\",null,{\"children\":\"将会\"}],\" 接收这些 Props。如果渲染尝试被中止（例如，因为某些子组件的代码尚未加载），React 将丢弃正在进行的树，并在下一次尝试期间尝试从头开始构建组件。到下一次渲染尝试时，Props 可能会有所不同。这就是为什么这种方法 \",[\"$r\",\"strong\",null,{\"children\":\"不安全\"}],\"。仅为了提交更新（例如重置监听事件）的代码应放入 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}],\" 并不意味着组件收到了与上次 \",[\"$r\",\"strong\",null,{\"children\":\"不同的\"}],\" props。你需要自己比较 \",[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"this.props\"}],\" 以检查是否发生了变化。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 在挂载期间不会使用初始 props 调用 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}],\"。仅当组件的某些属性要更新时，它才会调用此方法。例如，在同一组件内调用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"setState\"}]}],\" 通常不会触发 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"在类式组件中的 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}],\" 里调用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"setState\"}]}],\" 来“调整”state 等同于在函数式组件在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#storing-information-from-previous-renders\",\"children\":[\"渲染期间调用来自 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数\"]}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"unsafe_componentwillupdate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate(nextProps, nextState)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}],\"，React 会在使用新的 props 或 state 渲染之前调用它。它仅因历史原因而存在，不应在任何新代码中使用。相反请使用下面的替代方案：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你需要运行副作用（例如，获取数据、运行动画或重新初始化监听）来响应 prop 或 state 的更改，请将该逻辑移至 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果需要从 DOM 中读取一些信息（例如，保存当前滚动位置）以便稍后在 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\" 中使用的话，那么请在 \",[\"$r\",\"a\",null,{\"href\":\"#getsnapshotbeforeupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}]}],\" 中读取这些信息。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"查看避免不安全生命周期的示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillupdate-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\"：组件即将用来渲染的下一个 props。将 \",[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\" 与 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.props\"}]}],\" 进行比较以确定发生了什么变化。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\"：组件即将渲染的下一个 state。将 \",[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\" 与 \",[\"$r\",\"a\",null,{\"href\":\"#state\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.state\"}]}],\" 进行比较以确定发生了什么变化。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillupdate-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}],\" 不应该返回任何值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"unsafe_componentwillupdate-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果定义了 \",[\"$r\",\"a\",null,{\"href\":\"#shouldcomponentupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}]}],\" 并返回 \",[\"$r\",\"code\",null,{\"children\":\"false\"}],\"，则 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}],\" 将不会被调用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果组件实现了 \",[\"$r\",\"a\",null,{\"href\":\"#static-getdrivenstatefromprops\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps\"}]}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"#getsnapshotbeforeupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"getSnapshotBeforeUpdate\"}]}],\"，则不会调用 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"不支持在 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUpdate\"}],\" 期间调用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"setState\"}]}],\"（或任何导致调用 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 的方法，例如调度 Redux 操作）。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"尽管它的命名是这样，但如果你的应用程序使用如 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Sus%E2%80%8B%E2%80%8Bpense\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Suspense\"}]}],\" 时等新式的 React 功能时，\",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}],\" 并不能保证组件 \",[\"$r\",\"strong\",null,{\"children\":\"将会\"}],\" 更新。如果渲染尝试被中止（例如，因为某些子组件的代码尚未加载），React 将丢弃正在进行的树，并在下一次尝试期间尝试从头开始构建组件。到下一次渲染尝试时，props 和 state 可能会有所不同。这就是为什么这种方法“不安全”。仅针对提交更新（例如重置监听）而运行的代码应放入 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}],\" 并不意味着组件收到了与上次不同的 props 或 state。你需要自己将 \",[\"$r\",\"code\",null,{\"children\":\"nextProps\"}],\" 与 \",[\"$r\",\"code\",null,{\"children\":\"this.props\"}],\" 以及 \",[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\" 与 \",[\"$r\",\"code\",null,{\"children\":\"this.state\"}],\" 进行比较，以检查是否发生了变化。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 在挂载期间不会使用初始的 props 和 state 调用 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"函数式组件中没有与 \",[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillUpdate\"}],\" 直接等同的方法。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"static-childcontexttypes\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"static childContextTypes\"}],\" \"]}],\"\\n\",[\"$r\",\"Deprecated\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"该 API 将在 React 未来的主版本中删除。\",[\"$r\",\"a\",null,{\"href\":\"#static-contexttype\",\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"static contextType\"}],\" 代替\"]}],\"。\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"允许你指定此组件提供哪个 \",[\"$r\",\"a\",null,{\"href\":\"https://reactjs.org/docs/legacy-context.html\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"历史用法的 context\"}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"static-contexttypes\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"static contextTypes\"}],\" \"]}],\"\\n\",[\"$r\",\"Deprecated\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"该 API 将在 React 的未来主要版本中删除。\",[\"$r\",\"a\",null,{\"href\":\"#static-contexttype\",\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"static contextType\"}],\" 代替\"]}],\"。\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"允许你指定此组件使用哪个 \",[\"$r\",\"a\",null,{\"href\":\"https://reactjs.org/docs/legacy-context.html\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"历史用法的 context\"}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"static-contexttype\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"static contextType\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你想从类式组件中读取 \",[\"$r\",\"a\",null,{\"href\":\"#context-instance-field\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.context\"}]}],\"，则必须指定它需要读取哪个 context。你指定为 \",[\"$r\",\"code\",null,{\"children\":\"static contextType\"}],\" 的 context 必须是之前由 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createContext\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"createContext\"}],\" 创建的值\"]}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2}\",\"children\":\"class Button extends Component {\\n  static contextType = ThemeContext;\\n\\n  render() {\\n    const theme = this.context;\\n    const className = 'button-' + theme;\\n    return (\\n      <button className={className}>\\n        {this.props.children}\\n      </button>\\n    );\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"在类式组件中读取 \",[\"$r\",\"code\",null,{\"children\":\"this.context\"}],\" 等同于在函数式组件中使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useContext\"}]}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-context-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"static-defaultprops\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"static defaultProps\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以定义 \",[\"$r\",\"code\",null,{\"children\":\"static defaultProps\"}],\" 来设置类的默认 props。它们将在 props 为 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 或者缺少时有效，但在 props 为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 时无效。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如，以下是如何定义 \",[\"$r\",\"code\",null,{\"children\":\"color\"}],\" 属性默认为 \",[\"$r\",\"code\",null,{\"children\":\"blue\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-4}\",\"children\":\"class Button extends Component {\\n  static defaultProps = {\\n    color: 'blue'\\n  };\\n\\n  render() {\\n    return <button className={this.props.color}>click me</button>;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"color\"}],\" props 未提供或者为 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 时，它将默认设置为 \",[\"$r\",\"code\",null,{\"children\":\"blue\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<>\\n  {/* this.props.color 为 “blue” */}\\n  <Button />\\n\\n  {/* this.props.color 为 “blue” */}\\n  <Button color={undefined} />\\n\\n  {/* this.props.color 为 null */}\\n  <Button color={null} />\\n\\n  {/* this.props.color 为 “red” */}\\n  <Button color=\\\"red\\\" />\\n</>\\n\"}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"在类式组件中定义 \",[\"$r\",\"code\",null,{\"children\":\"defaultProps\"}],\" 类似于在函数式组件中使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#specifying-a-default-value-for-a-prop\",\"children\":\"默认值\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"static-proptypes\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"static propTypes\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以定义 \",[\"$r\",\"code\",null,{\"children\":\"static propTypes\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"https://www.npmjs.com/package/prop-types\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"prop-types\"}]}],\" 库来声明组件可接受的 props 类型。这些类型仅在渲染和开发过程中进行检查。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import PropTypes from 'prop-types';\\n\\nclass Greeting extends React.Component {\\n  static propTypes = {\\n    name: PropTypes.string\\n  };\\n\\n  render() {\\n    return (\\n      <h1>Hello, {this.props.name}</h1>\\n    );\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"我们建议使用 \",[\"$r\",\"a\",null,{\"href\":\"https://www.typescriptlang.org/\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"TypeScript\"}],\" 而不是在运行时检查 prop 类型。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"static-getderivedstatefromerror\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError(error)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError\"}],\"，那么当子组件（包括远亲组件）在渲染过程中抛出错误时，React 就会调用它。这使你可以显示错误消息而不是直接清理 UI。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常，它与 \",[\"$r\",\"a\",null,{\"href\":\"#componentDidCatch\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}]}],\" 一起使用，它可以让你将错误报告发送到某些分析服务。具有这些方法的组件称为 \",[\"$r\",\"strong\",null,{\"children\":\"错误边界\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#catching-rendering-errors-with-an-error-boundary\",\"children\":\"查看示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"static-getderivedstatefromerror-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"error\"}],\"：被抛出的错误。实际上，它通常是 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Error\"}]}],\" 的实例，但这并不能保证，因为 JavaScript 允许 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/throw\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"抛出\"}]}],\" 任何类型的值，包括字符串甚至是 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"static-getderivedstatefromerror-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError\"}],\" 应该返回告诉组件显示错误消息的 state。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"static-getderivedstatefromerror-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError\"}],\" 应该是一个纯函数。如果你想执行副作用（例如调用分析服务），你还需要实现 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidcatch\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"函数式组件中目前还没有与 \",[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError\"}],\" 直接等同的东西。如果你想避免创建类式组件，请像上面那样编写一个 \",[\"$r\",\"code\",null,{\"children\":\"ErrorBoundary\"}],\" 组件，并在整个应用程序中使用它。或者使用 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/bvaughn/react-error-boundary\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"react-error-boundary\"}]}],\" 包来执行此操作。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"static-getderivedstatefromprops\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps(props, state)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps\"}],\"，React 会在初始挂载和后续更新时调用 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render\"}]}],\" 之前调用它。它应该返回一个对象来更新 state，或者返回 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 就不更新任何内容。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"此方法适用于 \",[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"少数罕见用例\"}],\"，其中 state 取决于 props 随着时间的推移的变化。例如，当 \",[\"$r\",\"code\",null,{\"children\":\"userID\"}],\" 属性更改时，此 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件会重置 \",[\"$r\",\"code\",null,{\"children\":\"email\"}],\" 状态：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-18}\",\"children\":\"class Form extends Component {\\n  state = {\\n    email: this.props.defaultEmail,\\n    prevUserID: this.props.userID\\n  };\\n\\n  static getDerivedStateFromProps(props, state) {\\n    // 每当当前用户发生变化时，\\n    // 重置与该用户关联的任何 state 部分。\\n    // 在这个简单的示例中，只是以 email 为例。\\n    if (props.userID !== state.prevUserID) {\\n      return {\\n        prevUserID: props.userID,\\n        email: props.defaultEmail\\n      };\\n    }\\n    return null;\\n  }\\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，此模式要求你将 prop 的先前值（如 \",[\"$r\",\"code\",null,{\"children\":\"userID\"}],\"）保留在 state（如 \",[\"$r\",\"code\",null,{\"children\":\"prevUserID\"}],\"）中。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"派生 state 会导致代码冗长，并使你的组件难以理解。\",[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/06/07/you-probously-dont-need-driven-state.html\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"确保你熟悉这些更简单的替代方案\"}],\"：\"]}],[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你需要 \",[\"$r\",\"strong\",null,{\"children\":\"执行副作用\"}],\"（例如，数据获取或动画）以响应 props 的更改，请改用 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\" 方法。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你想 \",[\"$r\",\"strong\",null,{\"children\":\"仅在 prop 更改时重新计算一些数据\"}],\"，\",[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"使用 memoization helper 代替\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你想要 \",[\"$r\",\"strong\",null,{\"children\":\"当 prop 改变时“重置”一些 state\"}],\"，请考虑使组件 \",[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"完全控制\"}],\" 或者 \",[\"$r\",\"a\",null,{\"href\":\"https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"使用 key 使组件完全不受控\"}],\"。\"]}],\"\\n\"]}]]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"static-getderivedstatefromprops-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"props\"}],\"：组件即将用来渲染的下一个 props。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"state\"}],\"：组件即将渲染的下一个 state。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"static-getderivedstatefromprops-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps\"}],\" 返回一个对象来更新 state，或返回 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 不更新任何内容。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"static-getderivedstatefromprops-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"无论什么原因，此方法都会在 \",[\"$r\",\"strong\",null,{\"children\":\"每次\"}],\" 渲染时触发。这与 \",[\"$r\",\"a\",null,{\"href\":\"#unsafe_cmoponentwillreceiveprops\",\"children\":[\"$r\",\"code\",null,{\"children\":\"UNSAFE_componentWillReceiveProps\"}]}],\" 不同，后者仅在父组件不是因为调用了本地的 \",[\"$r\",\"code\",null,{\"children\":\"setState\"}],\" 而重新渲染时触发。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"此方法无权访问组件实例。如果你愿意，你可以在 \",[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps\"}],\" 和其他类方法之间重用一些代码，也就是提取类定义之外的组件 props 和 state 的纯函数。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"在类式组件中实现 \",[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromProps\"}],\" 等同于在函数式组件中 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#storing-information-from-previous-renders\",\"children\":\"在渲染期间从 useState 调用 set 函数\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"defining-a-class-component\",\"children\":\"定义类式组件 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"要将 React 组件定义为类，请继承内置的 \",[\"$r\",\"code\",null,{\"children\":\"Component\"}],\" 类并定义 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法\"]}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Component } from 'react';\\n\\nclass Greeting extends Component {\\n  render() {\\n    return <h1>你好, {this.props.name}!</h1>;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"每当 React 需要确定屏幕上显示的内容时，它就会调用你的 \",[\"$r\",\"a\",null,{\"href\":\"#render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render\"}]}],\" 方法。一般来说，你会让它返回一些 \",[\"$r\",\"a\",null,{\"href\":\"/learn/writing-markup-with-jsx\",\"children\":\"JSX\"}],\"。你的 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 方法应该是一个 \",[\"$r\",\"a\",null,{\"href\":\"https://en.wikipedia.org/wiki/Pure_function\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"纯函数\"}],\"：它应该只计算 JSX。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"与 \",[\"$r\",\"a\",null,{\"href\":\"/learn/your-first-component#defining-a-component\",\"children\":\"函数式组件\"}],\" 类似，类式组件可以从它的父组件 \",[\"$r\",\"a\",null,{\"href\":\"/learn/your-first-component#defining-a-component\",\"children\":\"通过 props 接收信息\"}],\"。然而，读取 props 的语法是不同的。例如，如果父组件渲染了 \",[\"$r\",\"code\",null,{\"children\":\"<Greeting name=\\\"Taylor\\\" />\"}],\" 组件，那么你可以从 \",[\"$r\",\"a\",null,{\"href\":\"#props\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.props\"}]}],\" 读取 \",[\"$r\",\"code\",null,{\"children\":\"name\"}],\" 属性，例如 \",[\"$r\",\"code\",null,{\"children\":\"this.props.name\"}],\"：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Component } from 'react';\\n\\nclass Greeting extends Component {\\n  render() {\\n    return <h1>你好, {this.props.name}!</h1>;\\n  }\\n}\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <Greeting name=\\\"Sara\\\" />\\n      <Greeting name=\\\"Cahal\\\" />\\n      <Greeting name=\\\"Edite\\\" />\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"554\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，类式组件内部不支持 Hook 函数（以 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 开头的函数，例如 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useState\"}]}],\"）。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"我们建议使用函数式组件，而不是类式组件。\",[\"$r\",\"a\",null,{\"href\":\"#migrating-a-simple-component-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"adding-state-to-a-class-component\",\"children\":\"向类式组件添加 state \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了向类式组件添加 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"state\"}],\"，请将一个对象分配给一个名为 \",[\"$r\",\"a\",null,{\"href\":\"#state\",\"children\":[\"$r\",\"code\",null,{\"children\":\"state\"}]}],\" 的属性。要更新 state 的话，请调用 \",[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.setState\"}]}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Component } from 'react';\\n\\nexport default class Counter extends Component {\\n  state = {\\n    name: 'Taylor',\\n    age: 42,\\n  };\\n\\n  handleNameChange = (e) => {\\n    this.setState({\\n      name: e.target.value\\n    });\\n  }\\n\\n  handleAgeChange = () => {\\n    this.setState({\\n      age: this.state.age + 1 \\n    });\\n  };\\n\\n  render() {\\n    return (\\n      <>\\n        <input\\n          value={this.state.name}\\n          onChange={this.handleNameChange}\\n        />\\n        <button onClick={this.handleAgeChange}>\\n          Increment age\\n        </button>\\n        <p>Hello, {this.state.name}. You are {this.state.age}.</p>\\n      </>\\n    );\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"570\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"我们建议使用函数式组件，而不是类式组件。\",[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-state-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"adding-lifecycle-methods-to-a-class-component\",\"children\":\"向类式组件中添加生命周期方法 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可以在类中定义一些特殊方法。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你定义了 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\" 方法，当你的组件被添加到屏幕上（\",[\"$r\",\"strong\",null,{\"children\":\"挂载\"}],\"）时，React 将会调用它。当你的组件由于 props 或 state 改变而重新渲染后，React 将调用 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\"。当你的组件从屏幕上被移除（\",[\"$r\",\"strong\",null,{\"children\":\"卸载\"}],\"）后，React 将调用 \",[\"$r\",\"a\",null,{\"href\":\"#componentwillunmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}]}],\" 方法。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你实现了 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 方法，那么通常还需要实现所有三个生命周期以避免错误。例如，如果 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 读取了某些 state 或属性，你就还必须实现 \",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 来处理它们的更改，并且实现 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\" 来清理 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 所执行的所有操作。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如，这个 \",[\"$r\",\"code\",null,{\"children\":\"ChatRoom\"}],\" 组件使聊天连接与 props 和 state 保持同步：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport ChatRoom from './ChatRoom.js';\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [show, setShow] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        选择一个聊天室:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">日常</option>\\n          <option value=\\\"travel\\\">旅行</option>\\n          <option value=\\\"music\\\">音乐</option>\\n        </select>\\n      </label>\\n      <button onClick={() => setShow(!show)}>\\n        {show ? '关闭聊天' : '开启聊天'}\\n      </button>\\n      {show && <hr />}\\n      {show && <ChatRoom roomId={roomId} />}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ChatRoom.js active\",\"children\":\"import { Component } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nexport default class ChatRoom extends Component {\\n  state = {\\n    serverUrl: 'https://localhost:1234'\\n  };\\n\\n  componentDidMount() {\\n    this.setupConnection();\\n  }\\n\\n  componentDidUpdate(prevProps, prevState) {\\n    if (\\n      this.props.roomId !== prevProps.roomId ||\\n      this.state.serverUrl !== prevState.serverUrl\\n    ) {\\n      this.destroyConnection();\\n      this.setupConnection();\\n    }\\n  }\\n\\n  componentWillUnmount() {\\n    this.destroyConnection();\\n  }\\n\\n  setupConnection() {\\n    this.connection = createConnection(\\n      this.state.serverUrl,\\n      this.props.roomId\\n    );\\n    this.connection.connect();    \\n  }\\n\\n  destroyConnection() {\\n    this.connection.disconnect();\\n    this.connection = null;\\n  }\\n\\n  render() {\\n    return (\\n      <>\\n        <label>\\n          Server URL:{' '}\\n          <input\\n            value={this.state.serverUrl}\\n            onChange={e => {\\n              this.setState({\\n                serverUrl: e.target.value\\n              });\\n            }}\\n          />\\n        </label>\\n        <h1>欢迎来到 {this.props.roomId} 聊天室！</h1>\\n      </>\\n    );\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现将实际地连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 成功连接到 \\\"' + roomId + '\\\" 号聊天室，服务端 Url：' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 无法连接到 \\\"' + roomId + '\\\" 号聊天室，服务端 Url：' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"606\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，在开发中，当 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/StrictMode\",\"children\":\"严格模式\"}],\" 开启时，React 将在调用 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 后，立即调用 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\"，然后再次调用 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\"。这可以帮助你注意到你是否忘记实现 \",[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}],\"，或者它的逻辑是否没有完全“对应”到 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 的效果。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"我们建议使用函数式组件，而不是类式组件。\",[\"$r\",\"a\",null,{\"href\":\"#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function\",\"children\":\"了解如何迁移\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"catching-rendering-errors-with-an-error-boundary\",\"children\":\"使用错误边界捕获渲染错误 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"默认情况下，如果你的应用程序在渲染过程中抛出错误，React 将从屏幕上删除其 UI。为了防止这种情况，你可以将 UI 的一部分包装到 \",[\"$r\",\"strong\",null,{\"children\":\"错误边界\"}],\" 中。错误边界是一个特殊的组件，可让你显示一些后备 UI，而不是显示例如错误消息这样崩溃的部分。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"要实现错误边界组件，你需要提供 \",[\"$r\",\"a\",null,{\"href\":\"#static-getderivedstatefromerror\",\"children\":[\"$r\",\"code\",null,{\"children\":\"static getDerivedStateFromError\"}]}],\"，它允许你更新状态以响应错误并向用户显示错误消息。你还可以选择实现 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidcatch\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidCatch\"}]}],\" 来添加一些额外的逻辑，例如将错误添加到分析服务。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-10,12-19}\",\"children\":\"class ErrorBoundary extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = { hasError: false };\\n  }\\n\\n  static getDerivedStateFromError(error) {\\n    // 更新状态，以便下一次渲染将显示后备 UI。\\n    return { hasError: true };\\n  }\\n\\n  componentDidCatch(error, info) {\\n    // 示例“组件堆栈”：\\n    //   在 ComponentThatThrows 中（由 App 创建）\\n    //   在 ErrorBoundary 中（由 APP 创建）\\n    //   在 div 中（由 APP 创建）\\n    //   在 App 中\\n    logErrorToMyService(error, info.componentStack);\\n  }\\n\\n  render() {\\n    if (this.state.hasError) {\\n      // 你可以渲染任何自定义后备 UI\\n      return this.props.fallback;\\n    }\\n\\n    return this.props.children;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"然后你可以用它包装组件树的一部分：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,3}\",\"children\":\"<ErrorBoundary fallback={<p>Something went wrong</p>}>\\n  <Profile />\\n</ErrorBoundary>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"Profile\"}],\" 或其子组件抛出错误，\",[\"$r\",\"code\",null,{\"children\":\"ErrorBoundary\"}],\" 将“捕获”该错误，然后显示带有你提供的错误消息的后备 UI，并向你的错误报告服务发送生产错误报告。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你不需要将每个组件包装到单独的错误边界中。当你考虑 \",[\"$r\",\"a\",null,{\"href\":\"https://aweary.dev/fault-tolerance-react/\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"错误边界的布置\"}],\" 时，请考虑在哪里显示错误消息才有意义。例如，在消息传递应用程序中，在对话列表周围放置错误边界是有意义的。在每条单独的消息周围放置一个也是有意义的。然而，在每个头像周围设置边界是没有意义的。\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"目前还没有办法将错误边界编写为函数式组件。但是你不必自己编写错误边界类。例如，你可以使用 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/bvaughn/react-error-boundary\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"react-error-boundary\"}]}],\" 包来代替。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"alternatives\",\"children\":\"备选方案 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"migrating-a-simple-component-from-a-class-to-a-function\",\"children\":\"将简单的类式组件迁移为函数式 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"一般来说，你应该把 \",[\"$r\",\"a\",null,{\"href\":\"/learn/your-first-component#defining-a-component\",\"children\":\"组件定义为函数\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如，假设你要将 \",[\"$r\",\"code\",null,{\"children\":\"Greeting\"}],\" 从类式组件转换为函数：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Component } from 'react';\\n\\nclass Greeting extends Component {\\n  render() {\\n    return <h1>Hello, {this.props.name}!</h1>;\\n  }\\n}\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <Greeting name=\\\"Sara\\\" />\\n      <Greeting name=\\\"Cahal\\\" />\\n      <Greeting name=\\\"Edite\\\" />\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"618\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"定义一个名为 \",[\"$r\",\"code\",null,{\"children\":\"Greeting\"}],\" 的函数。将 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 函数的主体移动到这里。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Greeting() {\\n  // ... 把 render 方法中的代码移动到这里 ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"定义 \",[\"$r\",\"code\",null,{\"children\":\"name\"}],\" 属性而不是 \",[\"$r\",\"code\",null,{\"children\":\"this.props.name\"}],\"，\",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":\"使用解构语法\"}],\" 来直接读取它：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Greeting({ name }) {\\n  return <h1>Hello, {name}!</h1>;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这里有个完整的例子：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Greeting({ name }) {\\n  return <h1>Hello, {name}!</h1>;\\n}\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <Greeting name=\\\"Sara\\\" />\\n      <Greeting name=\\\"Cahal\\\" />\\n      <Greeting name=\\\"Edite\\\" />\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"626\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"migrating-a-component-with-state-from-a-class-to-a-function\",\"children\":\"将具有 state 的类式组件迁移到函数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"假设你要将这个 \",[\"$r\",\"code\",null,{\"children\":\"Counter\"}],\" 从类式组件转换为函数：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Component } from 'react';\\n\\nexport default class Counter extends Component {\\n  state = {\\n    name: 'Taylor',\\n    age: 42,\\n  };\\n\\n  handleNameChange = (e) => {\\n    this.setState({\\n      name: e.target.value\\n    });\\n  }\\n\\n  handleAgeChange = (e) => {\\n    this.setState({\\n      age: this.state.age + 1 \\n    });\\n  };\\n\\n  render() {\\n    return (\\n      <>\\n        <input\\n          value={this.state.name}\\n          onChange={this.handleNameChange}\\n        />\\n        <button onClick={this.handleAgeChange}>\\n          Increment age\\n        </button>\\n        <p>Hello, {this.state.name}. You are {this.state.age}.</p>\\n      </>\\n    );\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"640\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"首先用必要的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#adding-state-to-a-component\",\"children\":\"state 变量\"}],\" 来创建一个函数。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-5}\",\"children\":\"import { useState } from 'react';\\n\\nfunction Counter() {\\n  const [name, setName] = useState('Taylor');\\n  const [age, setAge] = useState(42);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"接下来，转换事件处理程序：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5-7,9-11}\",\"children\":\"function Counter() {\\n  const [name, setName] = useState('Taylor');\\n  const [age, setAge] = useState(42);\\n\\n  function handleNameChange(e) {\\n    setName(e.target.value);\\n  }\\n\\n  function handleAgeChange() {\\n    setAge(age + 1);\\n  }\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"最后，将所有以 \",[\"$r\",\"code\",null,{\"children\":\"this\"}],\" 开头的引用替换为你在组件中定义的变量和函数。例如，将 \",[\"$r\",\"code\",null,{\"children\":\"this.state.age\"}],\" 替换为 \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\"，将 \",[\"$r\",\"code\",null,{\"children\":\"this.handleNameChange\"}],\" 替换为 \",[\"$r\",\"code\",null,{\"children\":\"handleNameChange\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这是一个完全转换后的组件：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [name, setName] = useState('Taylor');\\n  const [age, setAge] = useState(42);\\n\\n  function handleNameChange(e) {\\n    setName(e.target.value);\\n  }\\n\\n  function handleAgeChange() {\\n    setAge(age + 1);\\n  }\\n\\n  return (\\n    <>\\n      <input\\n        value={name}\\n        onChange={handleNameChange}\\n      />\\n      <button onClick={handleAgeChange}>\\n        Increment age\\n      </button>\\n      <p>Hello, {name}. You are {age}.</p>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"648\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function\",\"children\":\"将具有生命周期方法的组件从类迁移到函数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"假设你要将具有生命周期方法的 \",[\"$r\",\"code\",null,{\"children\":\"ChatRoom\"}],\" 类式组件转换为函数：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport ChatRoom from './ChatRoom.js';\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [show, setShow] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        Choose the chat room:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <button onClick={() => setShow(!show)}>\\n        {show ? 'Close chat' : 'Open chat'}\\n      </button>\\n      {show && <hr />}\\n      {show && <ChatRoom roomId={roomId} />}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ChatRoom.js active\",\"children\":\"import { Component } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nexport default class ChatRoom extends Component {\\n  state = {\\n    serverUrl: 'https://localhost:1234'\\n  };\\n\\n  componentDidMount() {\\n    this.setupConnection();\\n  }\\n\\n  componentDidUpdate(prevProps, prevState) {\\n    if (\\n      this.props.roomId !== prevProps.roomId ||\\n      this.state.serverUrl !== prevState.serverUrl\\n    ) {\\n      this.destroyConnection();\\n      this.setupConnection();\\n    }\\n  }\\n\\n  componentWillUnmount() {\\n    this.destroyConnection();\\n  }\\n\\n  setupConnection() {\\n    this.connection = createConnection(\\n      this.state.serverUrl,\\n      this.props.roomId\\n    );\\n    this.connection.connect();    \\n  }\\n\\n  destroyConnection() {\\n    this.connection.disconnect();\\n    this.connection = null;\\n  }\\n\\n  render() {\\n    return (\\n      <>\\n        <label>\\n          Server URL:{' '}\\n          <input\\n            value={this.state.serverUrl}\\n            onChange={e => {\\n              this.setState({\\n                serverUrl: e.target.value\\n              });\\n            }}\\n          />\\n        </label>\\n        <h1>欢迎俩到 {this.props.roomId} 聊天室！</h1>\\n      </>\\n    );\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现将实际连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 成功连接到 \\\"' + roomId + '\\\" 号聊天室，服务端 Url：' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 无法连接到 \\\"' + roomId + '\\\" 号聊天室，服务端 Url：' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"660\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"首先，验证你的 \",[\"$r\",\"a\",null,{\"href\":\"#componentwillunmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentWillUnmount\"}]}],\" 是否与 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}]}],\" 执行相反的操作。在上面的示例中操作是正确的：它会断开 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 设置的连接。如果缺少这样的逻辑，请先添加它。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"接下来，验证你的 \",[\"$r\",\"a\",null,{\"href\":\"#componentdidupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}]}],\" 方法是否可以处理对 \",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 中使用的任何 props 和 state 的更改。在上面的例子中，\",[\"$r\",\"code\",null,{\"children\":\"componentDidMount\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"setupConnection\"}],\" 来读取 \",[\"$r\",\"code\",null,{\"children\":\"this.state.serverUrl\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"this.props.roomId\"}],\"。这就是为什么 \",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 检查 \",[\"$r\",\"code\",null,{\"children\":\"this.state.serverUrl\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"this.props.roomId\"}],\" 是否已更改，如果更改了则重置连接。如果你的 \",[\"$r\",\"code\",null,{\"children\":\"componentDidUpdate\"}],\" 逻辑丢失或无法处理所有相关 props 和 state 的更改，那么请首先修复该问题。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在上面的示例中，生命周期方法内的逻辑将组件连接到 React 外部的系统（聊天服务器）。要将组件连接到外部系统，\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect#connecting-to-an-external-system\",\"children\":\"请将此逻辑描述为单个 Effect\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6-12}\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => {\\n      connection.disconnect();\\n    };\\n  }, [serverUrl, roomId]);\\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\" 的调用就相当于实现了上面所有生命周期方法中的逻辑。如果你的生命周期方法做了多个互不相关的事，\",[\"$r\",\"a\",null,{\"href\":\"/learn/removing-effect-dependencies#is-your-effect-doing-several-unrelated-things\",\"children\":\"将它们分成多个独立的 Effect\"}],\"。这是一个你可以使用的完整示例：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport ChatRoom from './ChatRoom.js';\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [show, setShow] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        Choose the chat room:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <button onClick={() => setShow(!show)}>\\n        {show ? 'Close chat' : 'Open chat'}\\n      </button>\\n      {show && <hr />}\\n      {show && <ChatRoom roomId={roomId} />}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ChatRoom.js active\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection } from './chat.js';\\n\\nexport default function ChatRoom({ roomId }) {\\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => {\\n      connection.disconnect();\\n    };\\n  }, [roomId, serverUrl]);\\n\\n  return (\\n    <>\\n      <label>\\n        Server URL:{' '}\\n        <input\\n          value={serverUrl}\\n          onChange={e => setServerUrl(e.target.value)}\\n        />\\n      </label>\\n      <h1>Welcome to the {roomId} room!</h1>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // 真正的实现将实际连接到服务器\\n  return {\\n    connect() {\\n      console.log('✅ 成功连接到 \\\"' + roomId + '\\\" 号聊天室，服务端 Url：' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('❌ 无法连接到 \\\"' + roomId + '\\\" 号聊天室，服务端 Url：' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input { display: block; margin-bottom: 20px; }\\nbutton { margin-left: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"670\",{\"children\":[\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"如果你的组件不与任何外部系统同步，\",[\"$r\",\"a\",null,{\"href\":\"/learn/you-might-not-need-an-effect\",\"children\":\"你可能不需要 effect \"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"migrating-a-component-with-context-from-a-class-to-a-function\",\"children\":\"将具有 context 的组件从类迁移到函数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"Panel\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 类式组件从 \",[\"$r\",\"a\",null,{\"href\":\"#context\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this.context\"}]}],\" 读取 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, Component } from 'react';\\n\\nconst ThemeContext = createContext(null);\\n\\nclass Panel extends Component {\\n  static contextType = ThemeContext;\\n\\n  render() {\\n    const theme = this.context;\\n    const className = 'panel-' + theme;\\n    return (\\n      <section className={className}>\\n        <h1>{this.props.title}</h1>\\n        {this.props.children}\\n      </section>\\n    );    \\n  }\\n}\\n\\nclass Button extends Component {\\n  static contextType = ThemeContext;\\n\\n  render() {\\n    const theme = this.context;\\n    const className = 'button-' + theme;\\n    return (\\n      <button className={className}>\\n        {this.props.children}\\n      </button>\\n    );\\n  }\\n}\\n\\nfunction Form() {\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      <Button>注册</Button>\\n      <Button>登录</Button>\\n    </Panel>\\n  );\\n}\\n\\nexport default function MyApp() {\\n  return (\\n    <ThemeContext.Provider value=\\\"dark\\\">\\n      <Form />\\n    </ThemeContext.Provider>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"674\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你将它们转换为函数式组件时，将 \",[\"$r\",\"code\",null,{\"children\":\"this.context\"}],\" 用调用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useContext\"}]}],\" 来替换：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext } from 'react';\\n\\nconst ThemeContext = createContext(null);\\n\\nfunction Panel({ title, children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'panel-' + theme;\\n  return (\\n    <section className={className}>\\n      <h1>{title}</h1>\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'button-' + theme;\\n  return (\\n    <button className={className}>\\n      {children}\\n    </button>\\n  );\\n}\\n\\nfunction Form() {\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      <Button>注册</Button>\\n      <Button>登录</Button>\\n    </Panel>\\n  );\\n}\\n\\nexport default function MyApp() {\\n  return (\\n    <ThemeContext.Provider value=\\\"dark\\\">\\n      <Form />\\n    </ThemeContext.Provider>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}]]}]]","meta":{"title":"Component"}},"__N_SSG":true}