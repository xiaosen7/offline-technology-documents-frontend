{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#useimperativehandle\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle(ref, createHandle, dependencies?)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"使用方法 \"},{\"url\":\"#exposing-a-custom-ref-handle-to-the-parent-component\",\"depth\":3,\"text\":\"向父组件暴露一个自定义的 ref 句柄 \"},{\"url\":\"#exposing-your-own-imperative-methods\",\"depth\":3,\"text\":\"暴露你自己的命令式方法 \"}]","content":"[[\"$r\",\"MaxWidth\",\"46\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}],\" 是 React 中的一个 Hook，它能让你自定义由 \",[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs\",\"children\":\"ref\"}],\" 暴露出来的句柄。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"useImperativeHandle(ref, createHandle, dependencies?)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"useimperativehandle\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle(ref, createHandle, dependencies?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件顶层通过调用 \",[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}],\" 来自定义 ref 暴露出来的句柄：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { forwardRef, useImperativeHandle } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  useImperativeHandle(ref, () => {\\n    return {\\n      // ... 你的方法 ...\\n    };\\n  }, []);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请看下面的更多例子\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"ref\"}],\"：该 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 是你从 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/forwardRef#render-function\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\" 渲染函数\"]}],\" 中获得的第二个参数。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"createHandle\"}],\"：该函数无需参数，它返回你想要暴露的 ref 的句柄。该句柄可以包含任何类型。通常，你会返回一个包含你想暴露的方法的对象。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选的\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"dependencies\"}],\"：函数 \",[\"$r\",\"code\",null,{\"children\":\"createHandle\"}],\" 代码中所用到的所有反应式的值的列表。反应式的值包含 props、状态和其他所有直接在你组件体内声明的变量和函数。倘若你的代码检查器已 \",[\"$r\",\"a\",null,{\"href\":\"/learn/editor-setup#linting\",\"children\":\"为 React 配置好\"}],\"，它会验证每一个反应式的值是否被正确指定为依赖项。该列表的长度必须是一个常数项，并且必须按照 \",[\"$r\",\"code\",null,{\"children\":\"[dep1, dep2, dep3]\"}],\" 的形式罗列各依赖项。React 会使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 来比较每一个依赖项与其对应的之前值。如果一次重新渲染导致某些依赖项发生了改变，或你没有提供这个参数列表，你的函数 \",[\"$r\",\"code\",null,{\"children\":\"createHandle\"}],\" 将会被重新执行，而新生成的句柄则会被分配给 ref。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}],\" 返回 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"使用方法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"exposing-a-custom-ref-handle-to-the-parent-component\",\"children\":\"向父组件暴露一个自定义的 ref 句柄 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"默认情况下，组件不会将它们的 DOM 节点暴露给父组件。举例来说，如果你想要 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 的父组件 \",[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs\",\"children\":\"能访问到\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" DOM 节点，你必须选择使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/forwardRef\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}],\":\"]}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4}\",\"children\":\"import { forwardRef } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  return <input {...props} ref={ref} />;\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在上方的代码中，\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/forwardRef#exposing-a-dom-node-to-the-parent-component\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 的 ref 会接收到 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" DOM 节点\"]}],\"。然而，你可以选择暴露一个自定义的值。为了修改被暴露的句柄，在你的顶层组件调用 \",[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-8}\",\"children\":\"import { forwardRef, useImperativeHandle } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  useImperativeHandle(ref, () => {\\n    return {\\n      // ... 你的方法 ...\\n    };\\n  }, []);\\n\\n  return <input {...props} />;\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"注意在上述代码中，该 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 已不再被转发到 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" 中。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"举例来说，假设你不想暴露出整个 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" DOM 节点，但你想要它其中两个方法：\",[\"$r\",\"code\",null,{\"children\":\"focus\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"scrollIntoView\"}],\"。为此，用单独额外的 ref 来指向真实的浏览器 DOM。然后使用 \",[\"$r\",\"code\",null,{\"children\":\"useImperativeHandle\"}],\" 来暴露一个句柄，它只返回你想要父组件去调用的方法：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-14}\",\"children\":\"import { forwardRef, useRef, useImperativeHandle } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  const inputRef = useRef(null);\\n\\n  useImperativeHandle(ref, () => {\\n    return {\\n      focus() {\\n        inputRef.current.focus();\\n      },\\n      scrollIntoView() {\\n        inputRef.current.scrollIntoView();\\n      },\\n    };\\n  }, []);\\n\\n  return <input {...props} ref={inputRef} />;\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在，如果你的父组件获得了 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 的 ref，就能通过该 ref 来调用 \",[\"$r\",\"code\",null,{\"children\":\"focus\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"scrollIntoView\"}],\" 方法。然而，它的访问是受限的，无法读取或调用下方 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" DOM 节点的其他所有属性和方法。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\nimport MyInput from './MyInput.js';\\n\\nexport default function Form() {\\n  const ref = useRef(null);\\n\\n  function handleClick() {\\n    ref.current.focus();\\n    // 下方代码不起作用，因为 DOM 节点并未被暴露出来：\\n    // ref.current.style.opacity = 0.5;\\n  }\\n\\n  return (\\n    <form>\\n      <MyInput placeholder=\\\"Enter your name\\\" ref={ref} />\\n      <button type=\\\"button\\\" onClick={handleClick}>\\n        Edit\\n      </button>\\n    </form>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/MyInput.js\",\"children\":\"import { forwardRef, useRef, useImperativeHandle } from 'react';\\n\\nconst MyInput = forwardRef(function MyInput(props, ref) {\\n  const inputRef = useRef(null);\\n\\n  useImperativeHandle(ref, () => {\\n    return {\\n      focus() {\\n        inputRef.current.focus();\\n      },\\n      scrollIntoView() {\\n        inputRef.current.scrollIntoView();\\n      },\\n    };\\n  }, []);\\n\\n  return <input {...props} ref={inputRef} />;\\n});\\n\\nexport default MyInput;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input {\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"54\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"exposing-your-own-imperative-methods\",\"children\":\"暴露你自己的命令式方法 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你通过命令式句柄暴露出来的方法不一定需要完全匹配 DOM 节点的方法。例如，这个 \",[\"$r\",\"code\",null,{\"children\":\"Post\"}],\" 组件暴露了一个 \",[\"$r\",\"code\",null,{\"children\":\"scrollAndFocusAddComment\"}],\" 方法。它可以让你在点击按钮后，使父组件 \",[\"$r\",\"code\",null,{\"children\":\"Page\"}],\" 滚动到评论列表的底部 \",[\"$r\",\"em\",null,{\"children\":\"并\"}],\" 聚焦到输入框：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\nimport Post from './Post.js';\\n\\nexport default function Page() {\\n  const postRef = useRef(null);\\n\\n  function handleClick() {\\n    postRef.current.scrollAndFocusAddComment();\\n  }\\n\\n  return (\\n    <>\\n      <button onClick={handleClick}>\\n        Write a comment\\n      </button>\\n      <Post ref={postRef} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Post.js\",\"children\":\"import { forwardRef, useRef, useImperativeHandle } from 'react';\\nimport CommentList from './CommentList.js';\\nimport AddComment from './AddComment.js';\\n\\nconst Post = forwardRef((props, ref) => {\\n  const commentsRef = useRef(null);\\n  const addCommentRef = useRef(null);\\n\\n  useImperativeHandle(ref, () => {\\n    return {\\n      scrollAndFocusAddComment() {\\n        commentsRef.current.scrollToBottom();\\n        addCommentRef.current.focus();\\n      }\\n    };\\n  }, []);\\n\\n  return (\\n    <>\\n      <article>\\n        <p>Welcome to my blog!</p>\\n      </article>\\n      <CommentList ref={commentsRef} />\\n      <AddComment ref={addCommentRef} />\\n    </>\\n  );\\n});\\n\\nexport default Post;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/CommentList.js\",\"children\":\"import { forwardRef, useRef, useImperativeHandle } from 'react';\\n\\nconst CommentList = forwardRef(function CommentList(props, ref) {\\n  const divRef = useRef(null);\\n\\n  useImperativeHandle(ref, () => {\\n    return {\\n      scrollToBottom() {\\n        const node = divRef.current;\\n        node.scrollTop = node.scrollHeight;\\n      }\\n    };\\n  }, []);\\n\\n  let comments = [];\\n  for (let i = 0; i < 50; i++) {\\n    comments.push(<p key={i}>Comment #{i}</p>);\\n  }\\n\\n  return (\\n    <div className=\\\"CommentList\\\" ref={divRef}>\\n      {comments}\\n    </div>\\n  );\\n});\\n\\nexport default CommentList;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddComment.js\",\"children\":\"import { forwardRef, useRef, useImperativeHandle } from 'react';\\n\\nconst AddComment = forwardRef(function AddComment(props, ref) {\\n  return <input placeholder=\\\"Add comment...\\\" ref={ref} />;\\n});\\n\\nexport default AddComment;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".CommentList {\\n  height: 100px;\\n  overflow: scroll;\\n  border: 1px solid black;\\n  margin-top: 20px;\\n  margin-bottom: 20px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"不要滥用 ref。\"}],\" 你应当仅在你没法通过 prop 来表达 \",[\"$r\",\"em\",null,{\"children\":\"命令式\"}],\" 行为的时候才使用 ref：例如，滚动到指定节点、聚焦某个节点、触发一次动画，以及选择文本等等。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"如果可以通过 prop 实现，那就不应该使用 ref\"}],\"。例如，你不应该从一个 \",[\"$r\",\"code\",null,{\"children\":\"Model\"}],\" 组件暴露出 \",[\"$r\",\"code\",null,{\"children\":\"{open, close}\"}],\" 这样的命令式句柄，最好是像 \",[\"$r\",\"code\",null,{\"children\":\"<Modal isOpen={isOpen} />\"}],\" 这样，将 \",[\"$r\",\"code\",null,{\"children\":\"isOpen\"}],\" 作为一个 prop。\",[\"$r\",\"a\",null,{\"href\":\"/learn/synchronizing-with-effects\",\"children\":\"副作用\"}],\" 可以帮你通过 prop 来暴露一些命令式的行为。\"]}]]}]]}]]","meta":{"title":"useImperativeHandle"}},"__N_SSG":true}