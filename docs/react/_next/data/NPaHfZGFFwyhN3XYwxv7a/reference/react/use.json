{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#use\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"use(resource)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#reading-context-with-use\",\"depth\":3,\"text\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 读取 context \"]},{\"url\":\"#streaming-data-from-server-to-client\",\"depth\":3,\"text\":\"将数据从服务器流式传递给客户端 \"},{\"url\":\"#dealing-with-rejected-promises\",\"depth\":3,\"text\":\"处理 rejected Promise \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#suspense-exception-error\",\"depth\":3,\"text\":\"“Suspense Exception: This is not a real error!” \"}]","content":"[[\"$r\",\"MaxWidth\",\"60\",{\"children\":[[\"$r\",\"Canary\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"use\"}],\" Hook 仅在 Canary 与 experimental 渠道中可用。参阅 \",[\"$r\",\"a\",null,{\"href\":\"/community/versioning-policy#all-release-channels\",\"children\":\"React 发布渠道\"}],\" 以了解更多信息。\"]}]}],\"\\n\",[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 是一个 React Hook，它可以让你读取类似于 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Promise\"}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\" 的资源的值。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const value = use(resource);\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"use\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"use(resource)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件中调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 以读取类似于 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Promise\"}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\" 的资源的值。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"import { use } from 'react';\\n\\nfunction MessageComponent({ messagePromise }) {\\n  const message = use(messagePromise);\\n  const theme = use(ThemeContext);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"与其他 React Hook 不同的是，可以在循环和条件语句（如 \",[\"$r\",\"code\",null,{\"children\":\"if\"}],\"）中调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\"。但需要注意的是，调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的函数仍然必须是一个组件或 Hook。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当使用 Promise 调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" Hook 时，它会与 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Suspense\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Suspense\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component#catching-rendering-errors-with-an-error-boundary\",\"children\":\"错误边界\"}],\" 集成。当传递给 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的 Promise 处于 pending 时，调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的组件也会 \",[\"$r\",\"strong\",null,{\"children\":\"挂起\"}],\"。如果调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的组件被包装在 Suspense 边界内，将显示后备 UI。一旦 Promise 被解决，Suspense 后备方案将被使用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" Hook 返回的数据替换。如果传递给 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的 Promise 被拒绝，将显示最近错误边界的后备 UI。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"[参见下方更多示例)(#usage)。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"resource\"}],\"：想要从中读取值的数据源。资源可以是 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Promise\"}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"use\"}],\" Hook 返回从资源中读取的值，类似于 fullfilled \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Promise\"}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"use\"}],\" Hook 必须在组件或 Hook 内部调用。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/use-server\",\"children\":\"服务器组件\"}],\" 中获取数据时，应优先使用 \",[\"$r\",\"code\",null,{\"children\":\"async\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"await\"}],\" 而不是 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\"。\",[\"$r\",\"code\",null,{\"children\":\"async\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"await\"}],\" 会从调用 \",[\"$r\",\"code\",null,{\"children\":\"await\"}],\" 的点开始渲染，而 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 会在数据获取到后重新渲染组件。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/use-server\",\"children\":\"服务器组件\"}],\" 中创建 Promise 并将其传递给 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/use-client\",\"children\":\"客户端组件\"}],\" 优于在客户端组件中创建 Promise。在客户端组件中创建的 Promise 每次渲染都会重新创建。从服务器组件传递到客户端组件的 Promise 在重新渲染时保持稳定。\",[\"$r\",\"a\",null,{\"href\":\"#streaming-data-from-server-to-client\",\"children\":\"请参阅此示例\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"reading-context-with-use\",\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 读取 context \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\" 被传递给 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 时，它的工作方式类似于\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useContext\"}]}],\"。而 \",[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 必须在组件的顶层调用，\",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 可以在条件语句如 \",[\"$r\",\"code\",null,{\"children\":\"if\"}],\" 和循环如 \",[\"$r\",\"code\",null,{\"children\":\"for\"}],\" 内调用。相比之下，\",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 比 \",[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\"更加灵活。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 4, \\\"theme\\\"], [1, 4, \\\"ThemeContext\\\"]]\",\"children\":\"import { use } from 'react';\\n\\nfunction Button() {\\n  const theme = use(ThemeContext);\\n  // ... \\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 返回传递的 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"context\"}],\" 的 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"context 值\"}],\"。React 会搜索组件树并找到 \",[\"$r\",\"strong\",null,{\"children\":\"最接近的 context provider\"}],\" 以确定需要返回的 context 值。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果要将上下文传递给 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\"，请将其或其父组件之一包装在相应的 context provdier 内。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 3, \\\"ThemeContext\\\"], [2, 3, \\\"\\\\\\\"dark\\\\\\\"\\\"], [1, 5, \\\"ThemeContext\\\"]]\",\"children\":\"function MyPage() {\\n  return (\\n    <ThemeContext.Provider value=\\\"dark\\\">\\n      <Form />\\n    </ThemeContext.Provider>\\n  );\\n}\\n\\nfunction Form() {\\n  // ……在这里面渲染按钮……\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"无论在 provider 和 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 之间有多少层组件，都不会有影响。当 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 内的任何位置的 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"use(ThemeContext)\"}],\" 时，它将接收到值为 \",[\"$r\",\"code\",null,{\"children\":\"\\\"dark\\\"\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"不同于 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useContext\"}]}],\"，\",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"use\"}]}],\" 可以在条件语句和循环中调用，比如 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"if\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 2, \\\"if\\\"], [2, 3, \\\"use\\\"]]\",\"children\":\"function HorizontalRule({ show }) {\\n  if (show) {\\n    const theme = use(ThemeContext);\\n    return <hr className={theme} />;\\n  }\\n  return false;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"if\"}]}],\" 语句内部调用了 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"use\"}]}],\"，允许有条件地从 context 中读取值。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"与 \",[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 类似，\",[\"$r\",\"code\",null,{\"children\":\"use(context)\"}],\" 始终查找调用它的组件上方最近的 context provider。它向上搜索并忽略调用 \",[\"$r\",\"code\",null,{\"children\":\"use(context)\"}],\" 的组件中的 context provider。\"]}]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, use } from 'react';\\n\\nconst ThemeContext = createContext(null);\\n\\nexport default function MyApp() {\\n  return (\\n    <ThemeContext.Provider value=\\\"dark\\\">\\n      <Form />\\n    </ThemeContext.Provider>\\n  )\\n}\\n\\nfunction Form() {\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      <Button show={true}>Sign up</Button>\\n      <Button show={false}>Log in</Button>\\n    </Panel>\\n  );\\n}\\n\\nfunction Panel({ title, children }) {\\n  const theme = use(ThemeContext);\\n  const className = 'panel-' + theme;\\n  return (\\n    <section className={className}>\\n      <h1>{title}</h1>\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ show, children }) {\\n  if (show) {\\n    const theme = use(ThemeContext);\\n    const className = 'button-' + theme;\\n    return (\\n      <button className={className}>\\n        {children}\\n      </button>\\n    );\\n  }\\n  return false\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"18.3.0-canary-9377e1010-20230712\\\",\\n    \\\"react-dom\\\": \\\"18.3.0-canary-9377e1010-20230712\\\",\\n    \\\"react-scripts\\\": \\\"^5.0.0\\\"\\n  },\\n  \\\"main\\\": \\\"/index.js\\\"\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"74\",{\"children\":[\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"streaming-data-from-server-to-client\",\"children\":\"将数据从服务器流式传递给客户端 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"数据可以通过将 Promise 作为 prop 从 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"服务器组件\"}],\" 传递到 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"客户端组件\"}],\" 以从服务器流式传输到客户端。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 4, \\\"App\\\"], [2, 2, \\\"Message\\\"], [3, 7, \\\"Suspense\\\"], [4, 8, \\\"messagePromise\\\", 30], [4, 5, \\\"messagePromise\\\"]]\",\"children\":\"import { fetchMessage } from './lib.js';\\nimport { Message } from './message.js';\\n\\nexport default function App() {\\n  const messagePromise = fetchMessage();\\n  return (\\n    <Suspense fallback={<p>waiting for message...</p>}>\\n      <Message messagePromise={messagePromise} />\\n    </Suspense>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"客户端组件\"}],\"将\",[\"$r\",\"CodeStep\",null,{\"step\":4,\"children\":\" 从 prop 中接收到的 Promise \"}],\" 传递给 \",[\"$r\",\"CodeStep\",null,{\"step\":5,\"children\":[\"$r\",\"code\",null,{\"children\":\"use\"}]}],\" Hook。这允许 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"客户端组件\"}],\" 从最初由服务器组件创建的 \",[\"$r\",\"CodeStep\",null,{\"step\":4,\"children\":\"Promise\"}],\" 中读取值。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 6, \\\"Message\\\"], [4, 6, \\\"messagePromise\\\"], [4, 7, \\\"messagePromise\\\"], [5, 7, \\\"use\\\"]]\",\"children\":\"// message.js\\n'use client';\\n\\nimport { use } from 'react';\\n\\nexport function Message({ messagePromise }) {\\n  const messageContent = use(messagePromise);\\n  return <p>Here is the message: {messageContent}</p>;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"由于 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"Message\"}]}],\" 被包裹在 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":[\"$r\",\"a\",null,{\"href\":\"/reference/react/Suspense\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Suspense\"}]}]}],\" 中，所以在 Promise 解决之前将显示后备方案。当 Promise 被解决后，\",[\"$r\",\"CodeStep\",null,{\"step\":5,\"children\":[\"$r\",\"code\",null,{\"children\":\"use\"}]}],\" Hook 将读取值，然后 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"Message\"}]}],\" 组件将替换 Suspense 后备方案。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/message.js active\",\"children\":\"\\\"use client\\\";\\n\\nimport { use, Suspense } from \\\"react\\\";\\n\\nfunction Message({ messagePromise }) {\\n  const messageContent = use(messagePromise);\\n  return <p>Here is the message: {messageContent}</p>;\\n}\\n\\nexport function MessageContainer({ messagePromise }) {\\n  return (\\n    <Suspense fallback={<p>⌛Downloading message...</p>}>\\n      <Message messagePromise={messagePromise} />\\n    </Suspense>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import { useState } from \\\"react\\\";\\nimport { MessageContainer } from \\\"./message.js\\\";\\n\\nfunction fetchMessage() {\\n  return new Promise((resolve) => setTimeout(resolve, 1000, \\\"⚛️\\\"));\\n}\\n\\nexport default function App() {\\n  const [messagePromise, setMessagePromise] = useState(null);\\n  const [show, setShow] = useState(false);\\n  function download() {\\n    setMessagePromise(fetchMessage());\\n    setShow(true);\\n  }\\n\\n  if (show) {\\n    return <MessageContainer messagePromise={messagePromise} />;\\n  } else {\\n    return <button onClick={download}>Download message</button>;\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js hidden\",\"children\":\"// TODO: 在稳定版本中更新 import\\n// 以替代此处 canary 版本中的导入方式，一旦 `use`\\n// Hook 在 React 稳定版本中发布\\nimport React, { StrictMode } from 'react';\\nimport { createRoot } from 'react-dom/client';\\nimport './styles.css';\\n\\n// TODO: 更新此处示例\\n// 以使用 Codesandbox 服务器组件\\n// demo 环境，一旦其被创建\\nimport App from './App';\\n\\nconst root = createRoot(document.getElementById('root'));\\nroot.render(\\n  <StrictMode>\\n    <App />\\n  </StrictMode>\\n);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"18.3.0-canary-9377e1010-20230712\\\",\\n    \\\"react-dom\\\": \\\"18.3.0-canary-9377e1010-20230712\\\",\\n    \\\"react-scripts\\\": \\\"^5.0.0\\\"\\n  },\\n  \\\"main\\\": \\\"/index.js\\\"\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"92\",{\"children\":[\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"将来自服务器组件的 Promise 传递至客户端组件时，其解析值必须可序列化以在服务器和客户端之间传递。像函数这样的数据类型不可序列化，不能成为这种 Promise 的解析值。\"}]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"resolve-promise-in-server-or-client-component\",\"children\":\"应该在服务器组件还是客户端组件解析 Promise？ \"}],[\"$r\",\"p\",null,{\"children\":[\"Promise 可以从服务器组件传递至客户端组件，并且可以在客户端组件中使用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" Hook 解析它。也可以在服务器组件中使用 \",[\"$r\",\"code\",null,{\"children\":\"await\"}],\" 解析 Promise，并将所需的数据作为 prop 传递给客户端组件。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"export default async function App() {\\n  const messageContent = await fetchMessage();\\n  return <Message messageContent={messageContent} />\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"但是在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/components#server-components\",\"children\":\"服务器组件\"}],\" 中使用 \",[\"$r\",\"code\",null,{\"children\":\"await\"}],\" 会在 \",[\"$r\",\"code\",null,{\"children\":\"await\"}],\" 执行完成前阻塞渲染。而将 Promise 从服务器组件传递到客户端组件可以防止 Promise 阻塞服务器组件渲染。\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"dealing-with-rejected-promises\",\"children\":\"处理 rejected Promise \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在某些情况下，传递给 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的 Promise 可能会被拒绝（rejected）。可以通过以下方式处理 rejected Promise：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#displaying-an-error-to-users-with-error-boundary\",\"children\":\"使用错误边界向用户显示错误信息\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#providing-an-alternative-value-with-promise-catch\",\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"Promise.catch\"}],\" 提供替代值\"]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"不能在 try-catch 块中调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\"。可以选择将组件 \",[\"$r\",\"a\",null,{\"href\":\"#displaying-an-error-to-users-with-error-boundary\",\"children\":\"包装在错误边界中\"}],\"，或者 \",[\"$r\",\"a\",null,{\"href\":\"#providing-an-alternative-value-with-promise-catch\",\"children\":[\"使用 Promise \",[\"$r\",\"code\",null,{\"children\":\".catch\"}],\" 方法提供替代值给 \",[\"$r\",\"code\",null,{\"children\":\"use\"}]]}],\"。\"]}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"displaying-an-error-to-users-with-error-boundary\",\"children\":\"使用错误边界将错误展示给用户 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果希望在 Promise 被拒绝（rejected）时向用户显示错误信息，可以使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component#catching-rendering-errors-with-an-error-boundary\",\"children\":\"错误边界\"}],\"。如果需要使用错误边界，请将调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" Hook 的组件包装在错误边界中。如果传递给 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的 Promise 被拒绝（rejected），将显示错误边界的后备方案。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/message.js active\",\"children\":\"\\\"use client\\\";\\n\\nimport { use, Suspense } from \\\"react\\\";\\nimport { ErrorBoundary } from \\\"react-error-boundary\\\";\\n\\nexport function MessageContainer({ messagePromise }) {\\n  return (\\n    <ErrorBoundary fallback={<p>⚠️Something went wrong</p>}>\\n      <Suspense fallback={<p>⌛Downloading message...</p>}>\\n        <Message messagePromise={messagePromise} />\\n      </Suspense>\\n    </ErrorBoundary>\\n  );\\n}\\n\\nfunction Message({ messagePromise }) {\\n  const content = use(messagePromise);\\n  return <p>Here is the message: {content}</p>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import { useState } from \\\"react\\\";\\nimport { MessageContainer } from \\\"./message.js\\\";\\n\\nfunction fetchMessage() {\\n  return new Promise((resolve, reject) => setTimeout(reject, 1000));\\n}\\n\\nexport default function App() {\\n  const [messagePromise, setMessagePromise] = useState(null);\\n  const [show, setShow] = useState(false);\\n  function download() {\\n    setMessagePromise(fetchMessage());\\n    setShow(true);\\n  }\\n\\n  if (show) {\\n    return <MessageContainer messagePromise={messagePromise} />;\\n  } else {\\n    return <button onClick={download}>Download message</button>;\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js hidden\",\"children\":\"// TODO: 在稳定版本中更新 import\\n// 以替代此处 canary 版本中的导入方式，一旦 `use`\\n// Hook 在 React 稳定版本中发布\\nimport React, { StrictMode } from 'react';\\nimport { createRoot } from 'react-dom/client';\\nimport './styles.css';\\n\\n// TODO: 更新此处示例\\n// 以使用 Codesandbox 服务器组件\\n// demo 环境，一旦其被创建\\nimport App from './App';\\n\\nconst root = createRoot(document.getElementById('root'));\\nroot.render(\\n  <StrictMode>\\n    <App />\\n  </StrictMode>\\n);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"18.3.0-canary-9377e1010-20230712\\\",\\n    \\\"react-dom\\\": \\\"18.3.0-canary-9377e1010-20230712\\\",\\n    \\\"react-scripts\\\": \\\"^5.0.0\\\",\\n    \\\"react-error-boundary\\\": \\\"4.0.3\\\"\\n  },\\n  \\\"main\\\": \\\"/index.js\\\"\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"providing-an-alternative-value-with-promise-catch\",\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"Promise.catch\"}],\" 提供替代值 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果希望在传递给 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的 Promise 被拒绝（rejected）时提供替代值，可以使用 Promise 的 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"catch\"}]}]}],\" 方法。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 6, \\\"catch\\\"],[2, 7, \\\"return\\\"]]\",\"children\":\"import { Message } from './message.js';\\n\\nexport default function App() {\\n  const messagePromise = new Promise((resolve, reject) => {\\n    reject();\\n  }).catch(() => {\\n    return \\\"no new message found.\\\";\\n  });\\n\\n  return (\\n    <Suspense fallback={<p>waiting for message...</p>}>\\n      <Message messagePromise={messagePromise} />\\n    </Suspense>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"要使用 Promise 的 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"catch\"}]}],\" 方法，请在 Promise 对象上调用 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"catch\"}]}],\"。\",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"catch\"}]}],\" 接受一个参数：一个接受错误消息作为参数的函数。由传递给 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"catch\"}]}],\" 的函数 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"返回\"}],\" 的任何内容都将视为 Promise 的解决值。\",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"返回\"}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"suspense-exception-error\",\"children\":\"“Suspense Exception: This is not a real error!” \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"要么在 React 组件或 Hook 函数之外调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\"，或者在 try-catch 块中调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\"。如果你在 try-catch 块中调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\"，请将组件包裹在错误边界中，或者使用 Promise 的 \",[\"$r\",\"code\",null,{\"children\":\"catch\"}],\" 方法来捕获错误并提供给替代值。\",[\"$r\",\"a\",null,{\"href\":\"#dealing-with-rejected-promises\",\"children\":\"参见这些示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果在 React 组件或 Hook 函数之外调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\"，请将 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 调用移至 React 组件或 Hook 函数中。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"function MessageComponent({messagePromise}) {\\n  function download() {\\n    // ❌ 调用 `use` 的函数不是组件或者 Hook\\n    const message = use(messagePromise);\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"相反，请在任何组件封闭区域之外调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\"，而调用 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 的函数本身应为组件或 Hook。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"children\":\"function MessageComponent({messagePromise}) {\\n  // ✅ `use` 正在组件内被调用\\n  const message = use(messagePromise);\\n  // ...\\n\"}]}]]}]]","meta":{"title":"use","canary":true}},"__N_SSG":true}