{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#profiler\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" \"]},{\"url\":\"#onrender-callback\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" 回调函数 \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#measuring-rendering-performance-programmatically\",\"depth\":3,\"text\":\"编程式测量渲染性能 \"},{\"url\":\"#measuring-different-parts-of-the-application\",\"depth\":3,\"text\":\"测量应用的不同部分 \"}]","content":"[[\"$r\",\"MaxWidth\",\"last\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 允许你编程式测量 React 树的渲染性能。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<Profiler id=\\\"App\\\" onRender={onRender}>\\n  <App />\\n</Profiler>\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"profiler\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 包裹组件树，以测量其渲染性能。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<Profiler id=\\\"App\\\" onRender={onRender}>\\n  <App />\\n</Profiler>\\n\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"props\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"id\"}],\"：字符串，用于标识正在测量的 UI 部分。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\"：\",[\"$r\",\"a\",null,{\"href\":\"#onrender-callback\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" 回调函数\"]}],\"，当包裹的组件树更新时，React 都会调用它。它接收有关渲染内容和所花费时间的信息。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"进行性能分析会增加一些额外的开销，因此 \",[\"$r\",\"strong\",null,{\"children\":\"在默认情况下，它在生产环境中是被禁用的\"}],\"。如果要启用生产环境下的性能分析，你需要启用一个 \",[\"$r\",\"a\",null,{\"href\":\"https://fb.me/react-profiling\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"特殊的带有性能分析功能的生产构建\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"onrender-callback\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" 回调函数 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当调用 \",[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" 回调函数时，React 会告诉你相关信息。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {\\n  // 对渲染时间进行汇总或记录...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"onrender-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"id\"}],\"：字符串，为 \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 树的 \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\" 属性，用于标识刚刚提交的部分。如果使用多个 profiler，可以通过此属性识别提交的是树中的哪一部分。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"phase\"}],\"：为 \",[\"$r\",\"code\",null,{\"children\":\"\\\"mount\\\"\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"\\\"update\\\"\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"\\\"nested-update\\\"\"}],\" 中之一。这可以让你知道组件树是首次挂载还是由于 props、state 或 hook 的更改而重新渲染。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"actualDuration\"}],\"：在此次更新中，渲染 \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 组件树的毫秒数。这可以显示子树在使用记忆化（例如 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\"）后的效果如何。理想情况下，此值在挂载后应显著减少，因为许多后代组件只会在特定的 props 变化时重新渲染。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"baseDuration\"}],\"：估算在没有任何优化的情况下重新渲染整棵 \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 子树所需的毫秒数。它通过累加树中每个组件的最近一次渲染持续时间来计算。此值估计了渲染的最差情况成本（例如初始挂载或没有使用记忆化的树）。将其与 \",[\"$r\",\"code\",null,{\"children\":\"actualDuration\"}],\" 进行比较，以确定记忆化是否起作用。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"startTime\"}],\"：当 React 开始渲染此次更新时的时间戳。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"commitTime\"}],\"：当 React 提交此次更新时的时间戳。此值在提交的所有 profiler 中共享，如果需要，可以对它们进行分组。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"measuring-rendering-performance-programmatically\",\"children\":\"编程式测量渲染性能 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 组件包裹 React 树以测量其渲染性能。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,4}\",\"children\":\"<App>\\n  <Profiler id=\\\"Sidebar\\\" onRender={onRender}>\\n    <Sidebar />\\n  </Profiler>\\n  <PageContent />\\n</App>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这需要两个属性：\",[\"$r\",\"code\",null,{\"children\":\"id\"}],\"（字符串）和 \",[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" 回调函数（函数），每当 React 树中的任何组件“提交”更新时都将调用该函数。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"进行性能分析会增加一些额外的开销，因此 \",[\"$r\",\"strong\",null,{\"children\":\"在默认情况下，它在生产环境中是被禁用的\"}],\"。如果要启用生产环境下的性能分析，你需要启用 \",[\"$r\",\"a\",null,{\"href\":\"https://fb.me/react-profiling\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"特殊的带有性能分析功能的生产构建\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 允许你编程式收集性能测量数据。如果你正在寻找一个交互式的性能分析工具，可以尝试使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/react-developer-tools\",\"children\":\"React 开发者工具\"}],\" 中的 Profiler 标签页。它提供了类似浏览器扩展程序的功能。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"measuring-different-parts-of-the-application\",\"children\":\"测量应用的不同部分 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以使用多个 \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 组件来测量应用的不同部分：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5,7}\",\"children\":\"<App>\\n  <Profiler id=\\\"Sidebar\\\" onRender={onRender}>\\n    <Sidebar />\\n  </Profiler>\\n  <Profiler id=\\\"Content\\\" onRender={onRender}>\\n    <Content />\\n  </Profiler>\\n</App>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"还可以嵌套 \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 组件：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5,7,9,12}\",\"children\":\"<App>\\n  <Profiler id=\\\"Sidebar\\\" onRender={onRender}>\\n    <Sidebar />\\n  </Profiler>\\n  <Profiler id=\\\"Content\\\" onRender={onRender}>\\n    <Content>\\n      <Profiler id=\\\"Editor\\\" onRender={onRender}>\\n        <Editor />\\n      </Profiler>\\n      <Preview />\\n    </Content>\\n  </Profiler>\\n</App>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"虽然 \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" 是一个轻量级组件，但它应该仅在必要时使用。每次使用都会给应用增加一些额外的 CPU 和内存开销。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}]]}]]","meta":{"title":"<Profiler>"}},"__N_SSG":true}