{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#children-count\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"Children.count(children)\"}],\" \"]},{\"url\":\"#children-foreach\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"Children.forEach(children, fn, thisArg?)\"}],\" \"]},{\"url\":\"#children-map\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"Children.map(children, fn, thisArg?)\"}],\" \"]},{\"url\":\"#children-only\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"Children.only(children)\"}],\" \"]},{\"url\":\"#children-toarray\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"Children.toArray(children)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#transforming-children\",\"depth\":3,\"text\":\"转化 children \"},{\"url\":\"#running-some-code-for-each-child\",\"depth\":3,\"text\":\"为每一个子元素执行一段代码 \"},{\"url\":\"#counting-children\",\"depth\":3,\"text\":\"统计子节点 \"},{\"url\":\"#converting-children-to-an-array\",\"depth\":3,\"text\":\"将 children 转化为数组 \"},{\"url\":\"#alternatives\",\"depth\":2,\"text\":\"替代方案 \"},{\"url\":\"#exposing-multiple-components\",\"depth\":3,\"text\":\"暴露多个组件 \"},{\"url\":\"#accepting-an-array-of-objects-as-a-prop\",\"depth\":3,\"text\":\"接收对象数组作为参数 \"},{\"url\":\"#calling-a-render-prop-to-customize-rendering\",\"depth\":3,\"text\":\"调用渲染属性以自定义渲染 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"错误排查 \"},{\"url\":\"#i-pass-a-custom-component-but-the-children-methods-dont-show-its-render-result\",\"depth\":3,\"text\":[\"我传递入了一个自定义组件，但是 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 方法没有显示渲染的内容 \"]}]","content":"[[\"$r\",\"MaxWidth\",\"138\",{\"children\":[[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 的场景并不常见，使用它可能会削弱代码的健壮性。\",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"查看常见的替代方案\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 允许你处理和转化作为 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#passing-jsx-as-children\",\"children\":[\"$r\",\"code\",null,{\"children\":\"children\"}]}],\" 的 JSX。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const mappedChildren = Children.map(children, child =>\\n  <div className=\\\"Row\\\">\\n    {child}\\n  </div>\\n);\\n\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"children-count\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"Children.count(children)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"Children.count(children)\"}],\" 可以获取 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 中的节点数量。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js active\",\"children\":\"import { Children } from 'react';\\n\\nfunction RowList({ children }) {\\n  return (\\n    <>\\n      <h1>行数: {Children.count(children)}</h1>\\n      ...\\n    </>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#counting-children\",\"children\":\"请参阅下面的更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-count-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\"：组件接收到的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#passing-jsx-as-children\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 参数\"]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-count-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 中的节点数量。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-count-caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"空节点（\",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 以及布尔值），字符串，数字和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createElement\",\"children\":\"React 元素\"}],\" 都会被统计为一个节点。\",[\"$r\",\"strong\",null,{\"children\":\"在遍历统计的过程中，React 元素不会被渲染，所以其子节点不会被统计\"}],\"。 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Fragment\",\"children\":\"Fragment\"}],\" 也不会被统计。对于数组，它本身也不会被统计，但其中的元素遵循上述规则。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"children-foreach\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"Children.forEach(children, fn, thisArg?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"Children.forEach(children, fn, thisArg?)\"}],\" 可以为每个 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 中的每个子节点执行一段代码。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js active\",\"children\":\"import { Children } from 'react';\\n\\nfunction SeparatorList({ children }) {\\n  const result = [];\\n  Children.forEach(children, (child, index) => {\\n    result.push(child);\\n    result.push(<hr key={index} />);\\n  });\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#running-some-code-for-each-child\",\"children\":\"请参阅下面的更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-foreach-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\"：组件接收到的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#passing-jsx-as-children\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 属性\"]}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"fn\"}],\"：和 \",[\"$r\",\"a\",null,{\"href\":\"(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\",\"children\":[\"数组的 \",[\"$r\",\"code\",null,{\"children\":\"forEach\"}],\" 方法\"]}],\" 中的回调类似，是你希望为每个子节点执行的函数。当这个函数执行时，对应的子节点和其下标将分别作为函数的第一、第二个参数，下标从 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" 开始自增。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"thisArg\"}],\"：为 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\" 函数绑定 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this\"}]}],\"。默认值为 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-foreach-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"Children.forEach\"}],\" 返回值是 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-foreach-caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"空节点（\",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 以及布尔值），字符串，数字和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createElement\",\"children\":\"React 元素\"}],\" 都会被统计为单个节点。\",[\"$r\",\"strong\",null,{\"children\":\"在遍历统计的过程中，React 元素不会被渲染，所以其子节点不会被统计\"}],\"。\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Fragment\",\"children\":\"Fragment\"}],\" 也不会被统计。对于数组，它本身也不会被统计，但其中的元素遵循上述规则。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"children-map\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"Children.map(children, fn, thisArg?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"Children.map(children, fn, thisArg?)\"}],\" 可以对 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 中的每个子节点进行映射或转换。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js active\",\"children\":\"import { Children } from 'react';\\n\\nfunction RowList({ children }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      {Children.map(children, child =>\\n        <div className=\\\"Row\\\">\\n          {child}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#transforming-children\",\"children\":\"请参阅下面的更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-map-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\"：组件接收到的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#passing-jsx-as-children\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 属性\"]}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"fn\"}],\"：和 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"数组的 \",[\"$r\",\"code\",null,{\"children\":\"map\"}],\" 方法\"]}],\" 中的回调类似，是一个映射函数。当这个函数执行时，对应的子节点和其下标将分别作为函数的第一、第二个参数，下标从 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" 开始自增。你需要使这个映射函数返回一个 React 节点，它可以是一个空节点（\",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"）。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"thisArg\"}],\"：为 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\" 函数绑定 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"this\"}]}],\"。默认值为 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-map-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 是 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 或者 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"，那么就返回这个值。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"否则就返回一个由 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\" 函数返回节点组成的一维数组。这个数组将包含除 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 以外的所有节点。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-map-caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"空节点（\",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 以及布尔值），字符串，数字和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createElement\",\"children\":\"React 元素\"}],\" 都会被统计为单个节点。\",[\"$r\",\"strong\",null,{\"children\":\"在遍历统计的过程中，React 元素不会被渲染，所以其子节点不会被统计\"}],\"。\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Fragment\",\"children\":\"Fragment\"}],\" 也不会被统计。对于数组，它本身也不会被统计，但其中的元素遵循上述规则。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你在 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\" 中返回了一个具有 key 的元素或者元素数组，\",[\"$r\",\"strong\",null,{\"children\":[\"各个元素的 key 将自动与其在 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 中对应的原始项的 key 绑定\"]}],\"。当你在 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\" 中返回了一个包含了多个元素的数组时，其中的每个元素的 key 都需要保证在这个数组中是独一无二的。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"children-only\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"Children.only(children)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"Children.only(children)\"}],\" 能够断言 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 代表一个 React 元素。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Box({ children }) {\\n  const element = Children.only(children);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-only-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\"：组件接收到的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#passing-jsx-as-children\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 属性\"]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-only-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/isValidElement\",\"children\":\"是一个合法的元素\"}],\"，那么就会返回这个元素。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"否则会抛出一个异常。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-only-caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果传入一个数组（比如 \",[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\" 的返回值）作为 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\"，那么这个方法会抛出异常。也就是说，这个方法强制要求 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 是一个 React 元素，而不是一个元素数组。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"children-toarray\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"Children.toArray(children)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"Children.toArray(children)\"}],\" 能够通过 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 创建一个数组。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ReversedList.js active\",\"children\":\"import { Children } from 'react';\\n\\nexport default function ReversedList({ children }) {\\n  const result = Children.toArray(children);\\n  result.reverse();\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-toarray-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\"：组件接收到的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#passing-jsx-as-children\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 属性\"]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-toarray-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"返回一个由 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 中的元素构成的一维数组。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"children-toarray-caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"空节点（\",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 以及 布尔值）将在返回的数组中被忽略掉。\",[\"$r\",\"strong\",null,{\"children\":\"返回的元素的 key 将根据原始元素的 key 和其嵌套层级与位置进行计算得到\"}],\"。这保证了扁平化数组时不会更改原本的行为。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"transforming-children\",\"children\":\"转化 children \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果想修改组件 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#passing-jsx-as-children\",\"children\":[\"接收到的 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 属性\"]}],\"，那么可以使用 \",[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6,10}\",\"children\":\"import { Children } from 'react';\\n\\nfunction RowList({ children }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      {Children.map(children, child =>\\n        <div className=\\\"Row\\\">\\n          {child}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在上述例子中，\",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 用 \",[\"$r\",\"code\",null,{\"children\":\"<div className=\\\"Row\\\">\"}],\" 包裹了接收到的每一个子元素。举个例子，假设父组件将三个 \",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\" 作为 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 属性传递给 \",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<RowList>\\n  <p>这是第一项。</p>\\n  <p>这是第二项。</p>\\n  <p>这是第三项。</p>\\n</RowList>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然后，使用实现上面的 \",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\"，最终的渲染结果将是像下面这样：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<div className=\\\"RowList\\\">\\n  <div className=\\\"Row\\\">\\n    <p>这是第一项。</p>\\n  </div>\\n  <div className=\\\"Row\\\">\\n    <p>这是第二项。</p>\\n  </div>\\n  <div className=\\\"Row\\\">\\n    <p>这是第三项。</p>\\n  </div>\\n</div>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/rendering-lists\",\"children\":[\"用来转化数组的 \",[\"$r\",\"code\",null,{\"children\":\"map()\"}],\" 类似\"]}],\"。区别在于 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 被视为 \",[\"$r\",\"strong\",null,{\"children\":\"不透明的\"}],\"。这意味着即使有时它真的是一个数组，你也不应该假设它是一个数组或者其他数据类型。这就是为什么如果你要转换\",[\"$r\",\"code\",null,{\"children\":\"children\"}],\", 应该使用 \",[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import RowList from './RowList.js';\\n\\nexport default function App() {\\n  return (\\n    <RowList>\\n      <p>这是第一项。</p>\\n      <p>这是第二项。</p>\\n      <p>这是第三项。</p>\\n    </RowList>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js active\",\"children\":\"import { Children } from 'react';\\n\\nexport default function RowList({ children }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      {Children.map(children, child =>\\n        <div className=\\\"Row\\\">\\n          {child}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".RowList {\\n  display: flex;\\n  flex-direction: column;\\n  border: 2px solid grey;\\n  padding: 5px;\\n}\\n\\n.Row {\\n  border: 2px dashed black;\\n  padding: 5px;\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"150\",{\"children\":[\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"why-is-the-children-prop-not-always-an-array\",\"children\":\"为什么 children 属性并不总是一个数组？ \"}],[\"$r\",\"p\",null,{\"children\":[\"在 React 中，\",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 属性是被视为 \",[\"$r\",\"strong\",null,{\"children\":\"不透明的\"}],\" 数据结构。这意味着你不应该依赖它的结构。如果要转换，过滤，或者统计子节点，你应该使用 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 方法。\"]}],[\"$r\",\"p\",null,{\"children\":[\"实际操作过程中，\",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 在底层常常被表示为数组。但是如果这里只有一个子节点，那么 React 将不会创建数组，因为这将导致不必要的内存开销。只要你使用 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 方法而不是直接操作 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 底层结构，即使 React 改变了 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 数据结构的实际实现方式，你的代码也不会被中断。\"]}],[\"$r\",\"p\",null,{\"children\":[\"当 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 是一个数组时，\",[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\" 会有许多有用的特性。比如，\",[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\" 将被返回元素上的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/rendering-lists#keeping-list-items-in-order-with-key\",\"children\":\"key\"}],\" 和 你传递给它的 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 上的 key 绑定。这保证了原本的 JSX 子元素不会“丢失” key，即使它们上面的例子中那样被包裹。\"]}]]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 的数据结构中 \",[\"$r\",\"strong\",null,{\"children\":\"不会包括你传递的 JSX 组件的渲染输出结果\"}],\"。在下面的例子中，\",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 接收到的 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 仅包含两个子项而不是三个：\"]}],[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"<p>这是第一项。</p>\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"code\",null,{\"children\":\"<MoreRows />\"}]}],\"\\n\"]}],[\"$r\",\"p\",null,{\"children\":\"这就是为什么在这个例子中仅产生了两个行级元素容器。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import RowList from './RowList.js';\\n\\nexport default function App() {\\n  return (\\n    <RowList>\\n      <p>这是第一项。</p>\\n      <MoreRows />\\n    </RowList>\\n  );\\n}\\n\\nfunction MoreRows() {\\n  return (\\n    <>\\n      <p>这是第二项。</p>\\n      <p>这是第三项。</p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js\",\"children\":\"import { Children } from 'react';\\n\\nexport default function RowList({ children }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      {Children.map(children, child =>\\n        <div className=\\\"Row\\\">\\n          {child}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".RowList {\\n  display: flex;\\n  flex-direction: column;\\n  border: 2px solid grey;\\n  padding: 5px;\\n}\\n\\n.Row {\\n  border: 2px dashed black;\\n  padding: 5px;\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"当操作 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 时，我们没办法获取到像 \",[\"$r\",\"code\",null,{\"children\":\"<MoreRows />\"}],\" 这样的内部组件的渲染输出结果，这就是为什么 \",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"我们更推荐使用替代方案之一\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"running-some-code-for-each-child\",\"children\":\"为每一个子元素执行一段代码 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"Children.forEach\"}],\" 能够迭代 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 数据结构中的每一个子节点。它并不会返回任何值，这和 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"数组的 \",[\"$r\",\"code\",null,{\"children\":\"forEach\"}],\" 方法\"]}],\" 类似。你可以使用它来运行自定义逻辑，例如构造自己的数组。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import SeparatorList from './SeparatorList.js';\\n\\nexport default function App() {\\n  return (\\n    <SeparatorList>\\n      <p>这是第一项。</p>\\n      <p>这是第二项。</p>\\n      <p>这是第三项。</p>\\n    </SeparatorList>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/SeparatorList.js active\",\"children\":\"import { Children } from 'react';\\n\\nexport default function SeparatorList({ children }) {\\n  const result = [];\\n  Children.forEach(children, (child, index) => {\\n    result.push(child);\\n    result.push(<hr key={index} />);\\n  });\\n  result.pop(); // Remove the last separator\\n  return result;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"160\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"就像之前提到过的一样，当操作 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 时，我们没办法获取到内部组件的渲染输出结果。这就是为什么 \",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"我们更推荐使用替代方案之一\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"counting-children\",\"children\":\"统计子节点 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"Children.count(children)\"}],\" 能够计算子节点的数量。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import RowList from './RowList.js';\\n\\nexport default function App() {\\n  return (\\n    <RowList>\\n      <p>这是第一项。</p>\\n      <p>这是第二项。</p>\\n      <p>这是第三项。</p>\\n    </RowList>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js active\",\"children\":\"import { Children } from 'react';\\n\\nexport default function RowList({ children }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      <h1 className=\\\"RowListHeader\\\">\\n        Total rows: {Children.count(children)}\\n      </h1>\\n      {Children.map(children, child =>\\n        <div className=\\\"Row\\\">\\n          {child}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".RowList {\\n  display: flex;\\n  flex-direction: column;\\n  border: 2px solid grey;\\n  padding: 5px;\\n}\\n\\n.RowListHeader {\\n  padding-top: 5px;\\n  font-size: 25px;\\n  font-weight: bold;\\n  text-align: center;\\n}\\n\\n.Row {\\n  border: 2px dashed black;\\n  padding: 5px;\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"170\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"就像之前提到过的一样，当操作 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\"时，我们没办法获取到内部组件的渲染输出结果。这就是为什么 \",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"我们更推荐使用替代方案之一\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"converting-children-to-an-array\",\"children\":\"将 children 转化为数组 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通过调用 \",[\"$r\",\"code\",null,{\"children\":\"Children.toArray(children)\"}],\" 将 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 变为一个常规的 JavaScript 数组。这使得你能够使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"filter\"}]}],\"， \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"sort\"}]}],\"， 或者 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"reverse\"}]}],\"  等数组内置方法来操作这个数组。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import ReversedList from './ReversedList.js';\\n\\nexport default function App() {\\n  return (\\n    <ReversedList>\\n      <p>这是第一项。</p>\\n      <p>这是第二项。</p>\\n      <p>这是第三项。</p>\\n    </ReversedList>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ReversedList.js active\",\"children\":\"import { Children } from 'react';\\n\\nexport default function ReversedList({ children }) {\\n  const result = Children.toArray(children);\\n  result.reverse();\\n  return result;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"186\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"就像之前提到过的一样，当操作 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\"时，我们没办法获取到内部组件的渲染输出结果。这就是为什么 \",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"我们更推荐使用替代方案之一\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"alternatives\",\"children\":\"替代方案 \"}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"像下面这样导入的就是（大写字母 \",[\"$r\",\"code\",null,{\"children\":\"C\"}],\" 开头的）\",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" API，本章节将会介绍它的一些替代方案：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { Children } from 'react';\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"不要将它和 (小写字母 \",[\"$r\",\"code\",null,{\"children\":\"c\"}],\" 开头的) \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component#passing-jsx-as-children\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 属性\"]}],\" 混淆，后者是我们推荐使用的。\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"exposing-multiple-components\",\"children\":\"暴露多个组件 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 方法操作子节点通常会削弱代码的健壮性。在 JSX 中将子节点传递给组件时，通常不希望操作或转换子节点。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果能够的话，尽量避免使用 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 方法。例如，如果你希望 \",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 的每一个子节点都被 \",[\"$r\",\"code\",null,{\"children\":\"<div className=\\\"Row\\\">\"}],\" 包裹，那么可以导出一个 \",[\"$r\",\"code\",null,{\"children\":\"Row\"}],\" 组件，然后像下面这样手动把包裹每一行：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { RowList, Row } from './RowList.js';\\n\\nexport default function App() {\\n  return (\\n    <RowList>\\n      <Row>\\n        <p>这是第一项。</p>\\n      </Row>\\n      <Row>\\n        <p>这是第二项。</p>\\n      </Row>\\n      <Row>\\n        <p>这是第三项。</p>\\n      </Row>\\n    </RowList>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js\",\"children\":\"export function RowList({ children }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      {children}\\n    </div>\\n  );\\n}\\n\\nexport function Row({ children }) {\\n  return (\\n    <div className=\\\"Row\\\">\\n      {children}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".RowList {\\n  display: flex;\\n  flex-direction: column;\\n  border: 2px solid grey;\\n  padding: 5px;\\n}\\n\\n.Row {\\n  border: 2px dashed black;\\n  padding: 5px;\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"190\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"和使用 \",[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\" 不同，这种方式不会自动包裹每个子节点。但是，和 \",[\"$r\",\"a\",null,{\"href\":\"#transforming-children\",\"children\":[\"上文中关于 \",[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\" 例子\"]}],\" 相比，这种方式具有明显的优势，因为即使你继续抽离更多的组件，它也仍然有效。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { RowList, Row } from './RowList.js';\\n\\nexport default function App() {\\n  return (\\n    <RowList>\\n      <Row>\\n        <p>这是第一项。</p>\\n      </Row>\\n      <MoreRows />\\n    </RowList>\\n  );\\n}\\n\\nfunction MoreRows() {\\n  return (\\n    <>\\n      <Row>\\n        <p>这是第二项。</p>\\n      </Row>\\n      <Row>\\n        <p>这是第三项。</p>\\n      </Row>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js\",\"children\":\"export function RowList({ children }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      {children}\\n    </div>\\n  );\\n}\\n\\nexport function Row({ children }) {\\n  return (\\n    <div className=\\\"Row\\\">\\n      {children}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".RowList {\\n  display: flex;\\n  flex-direction: column;\\n  border: 2px solid grey;\\n  padding: 5px;\\n}\\n\\n.Row {\\n  border: 2px dashed black;\\n  padding: 5px;\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"200\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这里使用 \",[\"$r\",\"code\",null,{\"children\":\"Children.map\"}],\" 得不到一样的结果，因为它会“认为” \",[\"$r\",\"code\",null,{\"children\":\"<MoreRows>\"}],\" 只是一个单独的子节点（并且只占据了一行）。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"accepting-an-array-of-objects-as-a-prop\",\"children\":\"接收对象数组作为参数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你也可以显示地传递一个数组作为组件的参数。例如，下面的 \",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 接收了一个 \",[\"$r\",\"code\",null,{\"children\":\"rows\"}],\" 数组作为组件的参数：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { RowList, Row } from './RowList.js';\\n\\nexport default function App() {\\n  return (\\n    <RowList rows={[\\n      { id: 'first', content: <p>这是第一项。</p> },\\n      { id: 'second', content: <p>这是第二项。</p> },\\n      { id: 'third', content: <p>这是第三项。</p> }\\n    ]} />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js\",\"children\":\"export function RowList({ rows }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      {rows.map(row => (\\n        <div className=\\\"Row\\\" key={row.id}>\\n          {row.content}\\n        </div>\\n      ))}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".RowList {\\n  display: flex;\\n  flex-direction: column;\\n  border: 2px solid grey;\\n  padding: 5px;\\n}\\n\\n.Row {\\n  border: 2px dashed black;\\n  padding: 5px;\\n  margin: 5px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"206\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"因为 \",[\"$r\",\"code\",null,{\"children\":\"rows\"}],\" 是一个常规的 JavaScript 数组，\",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 组件可以对其使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"map\"}]}],\" 等数组内置方法。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你希望能够将更多信息作为结构化数据，与子节点一起传递时，这个方案将会非常有用。在下面的示例中，\",[\"$r\",\"code\",null,{\"children\":\"TabSwitcher\"}],\" 接收了一个对象数组作为 \",[\"$r\",\"code\",null,{\"children\":\"tabs\"}],\" 的属性：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import TabSwitcher from './TabSwitcher.js';\\n\\nexport default function App() {\\n  return (\\n    <TabSwitcher tabs={[\\n      {\\n        id: 'first',\\n        header: 'First',\\n        content: <p>这是第一项。</p>\\n      },\\n      {\\n        id: 'second',\\n        header: 'Second',\\n        content: <p>这是第二项。</p>\\n      },\\n      {\\n        id: 'third',\\n        header: 'Third',\\n        content: <p>这是第三项。</p>\\n      }\\n    ]} />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TabSwitcher.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function TabSwitcher({ tabs }) {\\n  const [selectedId, setSelectedId] = useState(tabs[0].id);\\n  const selectedTab = tabs.find(tab => tab.id === selectedId);\\n  return (\\n    <>\\n      {tabs.map(tab => (\\n        <button\\n          key={tab.id}\\n          onClick={() => setSelectedId(tab.id)}\\n        >\\n          {tab.header}\\n        </button>\\n      ))}\\n      <hr />\\n      <div key={selectedId}>\\n        <h3>{selectedTab.header}</h3>\\n        {selectedTab.content}\\n      </div>\\n    </>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"216\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"和将子节点作为 JSX 传递不同，这个方法允许你将一些额外的数据，比如 \",[\"$r\",\"code\",null,{\"children\":\"header\"}],\"，与每个子项关联。因为你直接使用 \",[\"$r\",\"code\",null,{\"children\":\"tabs\"}],\"，并且它是一个数组，所以你并不需要 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 方法。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"calling-a-render-prop-to-customize-rendering\",\"children\":\"调用渲染属性以自定义渲染 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"除了为每一个子项生成 JSX，你还可以传递一个返回值类型是 JSX 的函数，并且在必要的时候调用这个函数。在这个示例中，\",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 组件向 \",[\"$r\",\"code\",null,{\"children\":\"TabSwitcher\"}],\" 组件传递了一个 \",[\"$r\",\"code\",null,{\"children\":\"renderContent\"}],\" 函数。\",[\"$r\",\"code\",null,{\"children\":\"TabSwitcher\"}],\" 组件仅对被选中的 tab 调用 \",[\"$r\",\"code\",null,{\"children\":\"renderContent\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import TabSwitcher from './TabSwitcher.js';\\n\\nexport default function App() {\\n  return (\\n    <TabSwitcher\\n      tabIds={['first', 'second', 'third']}\\n      getHeader={tabId => {\\n        return tabId[0].toUpperCase() + tabId.slice(1);\\n      }}\\n      renderContent={tabId => {\\n        return <p>This is the {tabId} item.</p>;\\n      }}\\n    />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TabSwitcher.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function TabSwitcher({ tabIds, getHeader, renderContent }) {\\n  const [selectedId, setSelectedId] = useState(tabIds[0]);\\n  return (\\n    <>\\n      {tabIds.map((tabId) => (\\n        <button\\n          key={tabId}\\n          onClick={() => setSelectedId(tabId)}\\n        >\\n          {getHeader(tabId)}\\n        </button>\\n      ))}\\n      <hr />\\n      <div key={selectedId}>\\n        <h3>{getHeader(selectedId)}</h3>\\n        {renderContent(selectedId)}\\n      </div>\\n    </>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"222\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"像 \",[\"$r\",\"code\",null,{\"children\":\"renderContent\"}],\" 这样的参数会被称为渲染属性，因为它指定了如何渲染一部分用户交互界面。但是，它也并没有什么特别之处，只是一个普通的属性同时恰好又是一个函数。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"渲染属性是函数，所以你可以向它们传递参数。比如，这里的 \",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 组件向 \",[\"$r\",\"code\",null,{\"children\":\"renderRow\"}],\" 传递了一个 \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\" 和每一行的 \",[\"$r\",\"code\",null,{\"children\":\"index\"}],\"，该属性用 \",[\"$r\",\"code\",null,{\"children\":\"index\"}],\" 来选择偶数行：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { RowList, Row } from './RowList.js';\\n\\nexport default function App() {\\n  return (\\n    <RowList\\n      rowIds={['first', 'second', 'third']}\\n      renderRow={(id, index) => {\\n        return (\\n          <Row isHighlighted={index % 2 === 0}>\\n            <p>This is the {id} item.</p>\\n          </Row> \\n        );\\n      }}\\n    />\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/RowList.js\",\"children\":\"import { Fragment } from 'react';\\n\\nexport function RowList({ rowIds, renderRow }) {\\n  return (\\n    <div className=\\\"RowList\\\">\\n      <h1 className=\\\"RowListHeader\\\">\\n        Total rows: {rowIds.length}\\n      </h1>\\n      {rowIds.map((rowId, index) =>\\n        <Fragment key={rowId}>\\n          {renderRow(rowId, index)}\\n        </Fragment>\\n      )}\\n    </div>\\n  );\\n}\\n\\nexport function Row({ children, isHighlighted }) {\\n  return (\\n    <div className={[\\n      'Row',\\n      isHighlighted ? 'RowHighlighted' : ''\\n    ].join(' ')}>\\n      {children}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".RowList {\\n  display: flex;\\n  flex-direction: column;\\n  border: 2px solid grey;\\n  padding: 5px;\\n}\\n\\n.RowListHeader {\\n  padding-top: 5px;\\n  font-size: 25px;\\n  font-weight: bold;\\n  text-align: center;\\n}\\n\\n.Row {\\n  border: 2px dashed black;\\n  padding: 5px;\\n  margin: 5px;\\n}\\n\\n.RowHighlighted {\\n  background: #ffa;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这是如何在不操纵子组件的情况下，父组件和子组件进行协作的另一个示例。\"}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"错误排查 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"i-pass-a-custom-component-but-the-children-methods-dont-show-its-render-result\",\"children\":[\"我传递入了一个自定义组件，但是 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\" 方法没有显示渲染的内容 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"假设你向 \",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 传入了两个子节点，像下面这样：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<RowList>\\n  <p>第一项</p>\\n  <MoreRows />\\n</RowList>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你在 \",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 中执行 \",[\"$r\",\"code\",null,{\"children\":\"Children.count(children)\"}],\"，其返回值将为 \",[\"$r\",\"code\",null,{\"children\":\"2\"}],\"。即使 \",[\"$r\",\"code\",null,{\"children\":\"MoreRows\"}],\" 渲染了 10 个不同的子项，或者返回了 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"Children.count(children)\"}],\" 的返回值仍然是 \",[\"$r\",\"code\",null,{\"children\":\"2\"}],\"。从 \",[\"$r\",\"code\",null,{\"children\":\"RowList\"}],\" 的角度上看，它只能感知到它直接接收到的 JSX，并不能感知到 \",[\"$r\",\"code\",null,{\"children\":\"MoreRows\"}],\" 组件的内部。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这导致抽离一个组件变得较为困难，这也是为什么我们更推荐使用 \",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"替代方案\"}],\" 而不是使用 \",[\"$r\",\"code\",null,{\"children\":\"Children\"}],\"。\"]}]]}]]","meta":{"title":"Children"}},"__N_SSG":true}