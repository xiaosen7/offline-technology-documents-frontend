{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#purecomponent\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#skipping-unnecessary-re-renders-for-class-components\",\"depth\":3,\"text\":\"跳过类式组件不必要的重新渲染 \"},{\"url\":\"#alternatives\",\"depth\":2,\"text\":\"替代方案 \"},{\"url\":\"#migrating-from-a-purecomponent-class-component-to-a-function\",\"depth\":3,\"text\":[\"从 \",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 类式组件迁移到函数式组件 \"]}]","content":"[[\"$r\",\"MaxWidth\",\"34\",{\"children\":[[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"我们建议使用函数式组件而非类式组件。\",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"查看如何迁移\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 类似于 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Component\"}]}],\"，但是当 props 和 state 与之前保持一致时会跳过重新渲染。React 仍然支持类式组件，但我们不建议在新代码中使用。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"class Greeting extends PureComponent {\\n  render() {\\n    return <h1>Hello, {this.props.name}!</h1>;\\n  }\\n}\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"purecomponent\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了在 props 和 state 相同时跳过重新渲染，类式组件应该继承 \",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 而不是 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Component\"}]}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { PureComponent } from 'react';\\n\\nclass Greeting extends PureComponent {\\n  render() {\\n    return <h1>Hello, {this.props.name}!</h1>;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 是 \",[\"$r\",\"code\",null,{\"children\":\"Component\"}],\" 的子类，并且支持 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component#reference\",\"children\":[\"所有 \",[\"$r\",\"code\",null,{\"children\":\"Component\"}],\" 的 API\"]}],\"。继承 \",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 的子类相当与定义了一个自定义的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component#shouldcomponentupdate\",\"children\":[\"$r\",\"code\",null,{\"children\":\"shouldComponentUpdate\"}]}],\" 方法，该方法将浅比较 props 和 state。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请参阅以下更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"skipping-unnecessary-re-renders-for-class-components\",\"children\":\"跳过类式组件不必要的重新渲染 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当父组件重新渲染时，React 通常会重新渲染子组件。为了优化性能，你可以创建一个组件，在父组件重新渲染时不会重新渲染，前提是新的 props 和 state 与旧的 props 和 state 相同。\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component\",\"children\":\"类式组件\"}],\" 可以通过继承 \",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 来选择此行为。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1}\",\"children\":\"class Greeting extends PureComponent {\\n  render() {\\n    return <h1>Hello, {this.props.name}!</h1>;\\n  }\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 组件应该始终具有 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"纯粹的渲染逻辑\"}],\"。这意味着如果 props、state 和 context 没有发生变化，它必须返回相同的输出。使用 \",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 便是在告诉 React 你的组件符合这个要求，因此只要 props 和 state 没有改变，React 就不需要重新渲染组件。然而，如果你的组件正在使用的 context 发生变化，它仍会重新渲染。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"注意，在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"Greeting\"}],\" 组件会在 \",[\"$r\",\"code\",null,{\"children\":\"name\"}],\" 改变时重新渲染（因为这是它的 props），但在 \",[\"$r\",\"code\",null,{\"children\":\"address\"}],\" 改变时不会（因为它没有作为 props 传递给 \",[\"$r\",\"code\",null,{\"children\":\"Greeting\"}],\"）：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { PureComponent, useState } from 'react';\\n\\nclass Greeting extends PureComponent {\\n  render() {\\n    console.log(\\\"Greeting was rendered at\\\", new Date().toLocaleTimeString());\\n    return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;\\n  }\\n}\\n\\nexport default function MyApp() {\\n  const [name, setName] = useState('');\\n  const [address, setAddress] = useState('');\\n  return (\\n    <>\\n      <label>\\n        Name{': '}\\n        <input value={name} onChange={e => setName(e.target.value)} />\\n      </label>\\n      <label>\\n        Address{': '}\\n        <input value={address} onChange={e => setAddress(e.target.value)} />\\n      </label>\\n      <Greeting name={name} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\n  display: block;\\n  margin-bottom: 16px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"46\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"我们建议使用函数式组件而非类式组件。\",[\"$r\",\"a\",null,{\"href\":\"#alternatives\",\"children\":\"查看如何迁移\"}],\"。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"alternatives\",\"children\":\"替代方案 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"migrating-from-a-purecomponent-class-component-to-a-function\",\"children\":[\"从 \",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 类式组件迁移到函数式组件 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"我们建议在新代码中使用函数式组件，而不是 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component\",\"children\":\"类式组件\"}],\"。如果你有一些使用 \",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 的现有组件，以下是如何进行转换。这是原始代码：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { PureComponent, useState } from 'react';\\n\\nclass Greeting extends PureComponent {\\n  render() {\\n    console.log(\\\"Greeting was rendered at\\\", new Date().toLocaleTimeString());\\n    return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;\\n  }\\n}\\n\\nexport default function MyApp() {\\n  const [name, setName] = useState('');\\n  const [address, setAddress] = useState('');\\n  return (\\n    <>\\n      <label>\\n        Name{': '}\\n        <input value={name} onChange={e => setName(e.target.value)} />\\n      </label>\\n      <label>\\n        Address{': '}\\n        <input value={address} onChange={e => setAddress(e.target.value)} />\\n      </label>\\n      <Greeting name={name} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\n  display: block;\\n  margin-bottom: 16px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"50\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当你 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Component#alternatives\",\"children\":\"将这个组件从类式组件转换为函数式组件\"}],\" 时，将其包装在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\"：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { memo, useState } from 'react';\\n\\nconst Greeting = memo(function Greeting({ name }) {\\n  console.log(\\\"Greeting was rendered at\\\", new Date().toLocaleTimeString());\\n  return <h3>Hello{name && ', '}{name}!</h3>;\\n});\\n\\nexport default function MyApp() {\\n  const [name, setName] = useState('');\\n  const [address, setAddress] = useState('');\\n  return (\\n    <>\\n      <label>\\n        Name{': '}\\n        <input value={name} onChange={e => setName(e.target.value)} />\\n      </label>\\n      <label>\\n        Address{': '}\\n        <input value={address} onChange={e => setAddress(e.target.value)} />\\n      </label>\\n      <Greeting name={name} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\n  display: block;\\n  margin-bottom: 16px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"与 \",[\"$r\",\"code\",null,{\"children\":\"PureComponent\"}],\" 不同，\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\" 不会比较新旧 state。在函数组件中，即使没有 \",[\"$r\",\"code\",null,{\"children\":\"memo\"}],\"，调用具有相同 state 的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#setstate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数\"]}],\"，\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo#updating-a-memoized-component-using-state\",\"children\":\"默认已经阻止了重新渲染\"}],\"。\"]}]}]]}]]","meta":{"title":"PureComponent"}},"__N_SSG":true}