{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#usestate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useState(initialState)\"}],\" \"]},{\"url\":\"#setstate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数，例如 \",[\"$r\",\"code\",null,{\"children\":\"setSomething(nextState)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#adding-state-to-a-component\",\"depth\":3,\"text\":\"为组件添加状态 \"},{\"url\":\"#updating-state-based-on-the-previous-state\",\"depth\":3,\"text\":\"根据先前的 state 更新 state \"},{\"url\":\"#updating-objects-and-arrays-in-state\",\"depth\":3,\"text\":\"更新状态中的对象和数组 \"},{\"url\":\"#avoiding-recreating-the-initial-state\",\"depth\":3,\"text\":\"避免重复创建初始状态 \"},{\"url\":\"#resetting-state-with-a-key\",\"depth\":3,\"text\":\"使用 key 重置状态 \"},{\"url\":\"#storing-information-from-previous-renders\",\"depth\":3,\"text\":\"存储前一次渲染的信息 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#ive-updated-the-state-but-logging-gives-me-the-old-value\",\"depth\":3,\"text\":\"我已经更新了状态，但日志仍显示旧值 \"},{\"url\":\"#ive-updated-the-state-but-the-screen-doesnt-update\",\"depth\":3,\"text\":\"我已经更新了状态，但是屏幕没有更新 \"},{\"url\":\"#im-getting-an-error-too-many-re-renders\",\"depth\":3,\"text\":\"出现错误：“Too many re-renders” \"},{\"url\":\"#my-initializer-or-updater-function-runs-twice\",\"depth\":3,\"text\":\"初始化函数或更新函数运行了两次 \"},{\"url\":\"#im-trying-to-set-state-to-a-function-but-it-gets-called-instead\",\"depth\":3,\"text\":\"我尝试将 state 设置为一个函数，但它却被调用了 \"}]","content":"[[\"$r\",\"MaxWidth\",\"76\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 是一个 React Hook，它允许你向组件添加一个 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"状态变量\"}],\"。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [state, setState] = useState(initialState)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"usestate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState(initialState)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的顶层调用 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 来声明一个 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"状态变量\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nfunction MyComponent() {\\n  const [age, setAge] = useState(28);\\n  const [name, setName] = useState('Taylor');\\n  const [todos, setTodos] = useState(() => createTodos());\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"按照惯例使用 \",[\"$r\",\"a\",null,{\"href\":\"https://javascript.info/destructuring-assignment\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"数组解构\"}],\" 来命名状态变量，例如 \",[\"$r\",\"code\",null,{\"children\":\"[something, setSomething]\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下面更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"initialState\"}],\"：你希望 state 初始化的值。它可以是任何类型的值，但对于函数有特殊的行为。在初始渲染后，此参数将被忽略。\",\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果传递函数作为 \",[\"$r\",\"code\",null,{\"children\":\"initialState\"}],\"，则它将被视为 \",[\"$r\",\"strong\",null,{\"children\":\"初始化函数\"}],\"。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。\",[\"$r\",\"a\",null,{\"href\":\"#avoiding-recreating-the-initial-state\",\"children\":\"请参见下面的示例\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 返回一个由两个值组成的数组：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"当前的 state。在首次渲染时，它将与你传递的 \",[\"$r\",\"code\",null,{\"children\":\"initialState\"}],\" 相匹配。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#setstate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数\"]}],\"，它可以让你将 state 更新为不同的值并触发重新渲染。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 是一个 Hook，因此你只能在 \",[\"$r\",\"strong\",null,{\"children\":\"组件的顶层\"}],\" 或自己的 Hook 中调用它。你不能在循环或条件语句中调用它。如果你需要这样做，请提取一个新组件并将状态移入其中。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在严格模式中，React 将 \",[\"$r\",\"strong\",null,{\"children\":\"两次调用初始化函数\"}],\"，以 \",[\"$r\",\"a\",null,{\"href\":\"#my-initializer-or-updater-function-runs-twice\",\"children\":\"帮你找到意外的不纯性\"}],\"。这只是开发时的行为，不影响生产。如果你的初始化函数是纯函数（本该是这样），就不应影响该行为。其中一个调用的结果将被忽略。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"setstate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数，例如 \",[\"$r\",\"code\",null,{\"children\":\"setSomething(nextState)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 返回的 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数允许你将 state 更新为不同的值并触发重新渲染。你可以直接传递新状态，也可以传递一个根据先前状态来计算新状态的函数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [name, setName] = useState('Edward');\\n\\nfunction handleClick() {\\n  setName('Taylor');\\n  setAge(a => a + 1);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"setstate-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\"：你想要 state 更新为的值。它可以是任何类型的值，但对于函数有特殊的行为。\",\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你将函数作为 \",[\"$r\",\"code\",null,{\"children\":\"nextState\"}],\" 传递，它将被视为 \",[\"$r\",\"strong\",null,{\"children\":\"更新函数\"}],\"。它必须是纯函数，只接受待定的 state 作为其唯一参数，并应返回下一个状态。React 将把你的更新函数放入队列中并重新渲染组件。在下一次渲染期间，React 将通过把队列中所有更新函数应用于先前的状态来计算下一个状态。\",[\"$r\",\"a\",null,{\"href\":\"#updating-state-based-on-the-previous-state\",\"children\":\"请参见下面的示例\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"setstate-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数没有返回值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"setstate-caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数 \",[\"$r\",\"strong\",null,{\"children\":[\"仅更新 \",[\"$r\",\"em\",null,{\"children\":\"下一次\"}],\" 渲染的状态变量\"]}],\"。如果在调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数后读取状态变量，则 \",[\"$r\",\"a\",null,{\"href\":\"#ive-updated-the-state-but-logging-gives-me-the-old-value\",\"children\":\"仍会得到在调用之前显示在屏幕上的旧值\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你提供的新值与当前 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 相同（由 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 比较确定），React 将 \",[\"$r\",\"strong\",null,{\"children\":\"跳过重新渲染该组件及其子组件\"}],\"。这是一种优化。虽然在某些情况下 React 仍然需要在跳过子组件之前调用你的组件，但这不应影响你的代码。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 会 \",[\"$r\",\"a\",null,{\"href\":\"/learn/queueing-a-series-of-state-updates\",\"children\":\"批量处理状态更新\"}],\"。它会在所有 \",[\"$r\",\"strong\",null,{\"children\":\"事件处理函数运行\"}],\" 并调用其 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。在某些罕见情况下，你需要强制 React 更早地更新屏幕，例如访问 DOM，你可以使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/flushSync\",\"children\":[\"$r\",\"code\",null,{\"children\":\"flushSync\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在渲染期间，只允许在当前渲染组件内部调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数。React 将丢弃其输出并立即尝试使用新状态重新渲染。这种方式很少需要，但你可以使用它来存储 \",[\"$r\",\"strong\",null,{\"children\":\"先前渲染中的信息\"}],\"。\",[\"$r\",\"a\",null,{\"href\":\"#storing-information-from-previous-renders\",\"children\":\"请参见下面的示例\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在严格模式中，React 将 \",[\"$r\",\"strong\",null,{\"children\":\"两次调用你的更新函数\"}],\"，以帮助你找到 \",[\"$r\",\"a\",null,{\"href\":\"#my-initializer-or-updater-function-runs-twice\",\"children\":\"意外的不纯性\"}],\"。这只是开发时的行为，不影响生产。如果你的更新函数是纯函数（本该是这样），就不应影响该行为。其中一次调用的结果将被忽略。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"adding-state-to-a-component\",\"children\":\"为组件添加状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的顶层调用 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 来声明一个或多个 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"状态变量\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 4, \\\"age\\\"], [2, 4, \\\"setAge\\\"], [3, 4, \\\"42\\\"], [1, 5, \\\"name\\\"], [2, 5, \\\"setName\\\"], [3, 5, \\\"'Taylor'\\\"]]\",\"children\":\"import { useState } from 'react';\\n\\nfunction MyComponent() {\\n  const [age, setAge] = useState(42);\\n  const [name, setName] = useState('Taylor');\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"按照惯例使用 \",[\"$r\",\"a\",null,{\"href\":\"https://javascript.info/destructuring-assignment\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"数组解构\"}],\" 来命名状态变量，例如 \",[\"$r\",\"code\",null,{\"children\":\"[something, setSomething]\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 返回一个只包含两个项的数组：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"该状态变量 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"当前的 state\"}],\"，最初设置为你提供的 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"初始化 state\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数\"]}],\"，它允许你在响应交互时将 state 更改为任何其他值。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"要更新屏幕上的内容，请使用新状态调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 2, \\\"setName\\\"]]\",\"children\":\"function handleClick() {\\n  setName('Robin');\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"React 会存储新状态，使用新值重新渲染组件，并更新 UI。\"}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数 \",[\"$r\",\"a\",null,{\"href\":\"#ive-updated-the-state-but-logging-gives-me-the-old-value\",\"children\":[[\"$r\",\"strong\",null,{\"children\":\"不会\"}],\" 改变已经执行的代码中当前的 state\"]}],\"：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3}\",\"children\":\"function handleClick() {\\n  setName('Robin');\\n  console.log(name); // Still \\\"Taylor\\\"!\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"它只影响 \",[\"$r\",\"strong\",null,{\"children\":\"下一次\"}],\" 渲染中 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 返回的内容。\"]}]]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"基本的 useState 示例\",\"titleId\":\"examples-basic\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"counter-number\",\"children\":\"计数器（数字） \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" 状态变量保存一个数字。点击按钮会将其加一。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [count, setCount] = useState(0);\\n\\n  function handleClick() {\\n    setCount(count + 1);\\n  }\\n\\n  return (\\n    <button onClick={handleClick}>\\n      You pressed me {count} times\\n    </button>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"text-field-string\",\"children\":\"文本字段（字符串） \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"text\"}],\" 状态变量保存一个字符串。当你输入时，\",[\"$r\",\"code\",null,{\"children\":\"handleChange\"}],\" 从浏览器 input DOM 元素中读取最新的输入值，并调用 \",[\"$r\",\"code\",null,{\"children\":\"setText\"}],\" 来更新状态。这允许你在下面展示当前的 \",[\"$r\",\"code\",null,{\"children\":\"text\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function MyInput() {\\n  const [text, setText] = useState('hello');\\n\\n  function handleChange(e) {\\n    setText(e.target.value);\\n  }\\n\\n  return (\\n    <>\\n      <input value={text} onChange={handleChange} />\\n      <p>You typed: {text}</p>\\n      <button onClick={() => setText('hello')}>\\n        Reset\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"checkbox-boolean\",\"children\":\"复选框（布尔值） \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"liked\"}],\" 状态变量保存一个布尔值。当你点击 input 时，\",[\"$r\",\"code\",null,{\"children\":\"setLiked\"}],\" 会根据浏览器复选框是否选中来更新 \",[\"$r\",\"code\",null,{\"children\":\"liked\"}],\" 状态变量。\",[\"$r\",\"code\",null,{\"children\":\"liked\"}],\" 变量用于渲染复选框下面的文本。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function MyCheckbox() {\\n  const [liked, setLiked] = useState(true);\\n\\n  function handleChange(e) {\\n    setLiked(e.target.checked);\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={liked}\\n          onChange={handleChange}\\n        />\\n        I liked this\\n      </label>\\n      <p>You {liked ? 'liked' : 'did not like'} this.</p>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"form-two-variables\",\"children\":\"表单（两个变量） \"}],[\"$r\",\"p\",null,{\"children\":\"你可以在同一个组件中声明多个状态变量。每个状态变量都是完全独立的。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [name, setName] = useState('Taylor');\\n  const [age, setAge] = useState(42);\\n\\n  return (\\n    <>\\n      <input\\n        value={name}\\n        onChange={e => setName(e.target.value)}\\n      />\\n      <button onClick={() => setAge(age + 1)}>\\n        Increment age\\n      </button>\\n      <p>Hello, {name}. You are {age}.</p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"106\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"updating-state-based-on-the-previous-state\",\"children\":\"根据先前的 state 更新 state \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"假设 \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"42\"}],\"，这个处理函数三次调用 \",[\"$r\",\"code\",null,{\"children\":\"setAge(age + 1)\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function handleClick() {\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然而，点击一次后，\",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 将只会变为 \",[\"$r\",\"code\",null,{\"children\":\"43\"}],\" 而不是 \",[\"$r\",\"code\",null,{\"children\":\"45\"}],\"！这是因为调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"不会更新\"}],\" 已经运行代码中的 \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 状态变量。因此，每个 \",[\"$r\",\"code\",null,{\"children\":\"setAge(age + 1)\"}],\" 调用变成了 \",[\"$r\",\"code\",null,{\"children\":\"setAge(43)\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了解决这个问题，\",[\"$r\",\"strong\",null,{\"children\":[\"你可以向 \",[\"$r\",\"code\",null,{\"children\":\"setAge\"}],\" 传递一个 \",[\"$r\",\"em\",null,{\"children\":\"更新函数\"}]]}],\"，而不是下一个状态：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 2, \\\"a\\\", 0], [2, 2, \\\"a + 1\\\"], [1, 3, \\\"a\\\", 0], [2, 3, \\\"a + 1\\\"], [1, 4, \\\"a\\\", 0], [2, 4, \\\"a + 1\\\"]]\",\"children\":\"function handleClick() {\\n  setAge(a => a + 1); // setAge(42 => 43)\\n  setAge(a => a + 1); // setAge(43 => 44)\\n  setAge(a => a + 1); // setAge(44 => 45)\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这里，\",[\"$r\",\"code\",null,{\"children\":\"a => a + 1\"}],\" 是更新函数。它获取 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"待定状态\"}],\" 并从中计算 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"下一个状态\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 将更新函数放入 \",[\"$r\",\"a\",null,{\"href\":\"/learn/queueing-a-series-of-state-updates\",\"children\":\"队列\"}],\" 中。然后，在下一次渲染期间，它将按照相同的顺序调用它们：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"a => a + 1\"}],\" 将接收 \",[\"$r\",\"code\",null,{\"children\":\"42\"}],\" 作为待定状态，并返回 \",[\"$r\",\"code\",null,{\"children\":\"43\"}],\" 作为下一个状态。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"a => a + 1\"}],\" 将接收 \",[\"$r\",\"code\",null,{\"children\":\"43\"}],\" 作为待定状态，并返回 \",[\"$r\",\"code\",null,{\"children\":\"44\"}],\" 作为下一个状态。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"a => a + 1\"}],\" 将接收 \",[\"$r\",\"code\",null,{\"children\":\"44\"}],\" 作为待定状态，并返回 \",[\"$r\",\"code\",null,{\"children\":\"45\"}],\" 作为下一个状态。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在没有其他排队的更新，因此 React 最终将存储 \",[\"$r\",\"code\",null,{\"children\":\"45\"}],\" 作为当前状态。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"按照惯例，通常将待定状态参数命名为状态变量名称的第一个字母，如 \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"a\"}],\"。然而，你也可以把它命名为 \",[\"$r\",\"code\",null,{\"children\":\"prevAge\"}],\" 或者其他你觉得更清楚的名称。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 在开发环境中可能会 \",[\"$r\",\"a\",null,{\"href\":\"#my-initializer-or-updater-function-runs-twice\",\"children\":\"两次调用你的更新函数\"}],\" 来验证其是否为 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"纯函数\"}],\"。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"is-using-an-updater-always-preferred\",\"children\":\"是否总是优先使用更新函数？ \"}],[\"$r\",\"p\",null,{\"children\":[\"你可能会听到这样的建议，如果要设置的状态是根据先前的状态计算得出的，则应始终编写类似于 \",[\"$r\",\"code\",null,{\"children\":\"setAge(a => a + 1)\"}],\" 的代码。这样做没有害处，但也不总是必要的。\"]}],[\"$r\",\"p\",null,{\"children\":[\"在大多数情况下，这两种方法没有区别。React 始终确保对于有意的用户操作，如单击，\",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 状态变量将在下一次单击之前被更新。这意味着单击事件处理函数在事件处理开始没有得到“过时” \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 的风险。\"]}],[\"$r\",\"p\",null,{\"children\":\"但是，如果在同一事件中进行多个更新，则更新函数可能会有帮助。如果访问状态变量本身不方便（在优化重新渲染时可能会遇到这种情况），它们也很有用。\"}],[\"$r\",\"p\",null,{\"children\":[\"如果比起轻微的冗余你更喜欢语法的一致性，你正设置的状态又是根据先前的状态计算出来的，那么总是编写一个更新函数是合理的。如果它是从某个其他状态变量的先前状态计算出的，则你可能希望将它们结合成一个对象然后 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"使用 reducer\"}],\"。\"]}]]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"传递更新函数和直接传递下一个状态之间的区别\",\"titleId\":\"examples-updater\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"passing-the-updater-function\",\"children\":\"传递更新函数 \"}],[\"$r\",\"p\",null,{\"children\":\"这个例子传递了更新函数，因此“+3”按钮可以正常工作。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [age, setAge] = useState(42);\\n\\n  function increment() {\\n    setAge(a => a + 1);\\n  }\\n\\n  return (\\n    <>\\n      <h1>Your age: {age}</h1>\\n      <button onClick={() => {\\n        increment();\\n        increment();\\n        increment();\\n      }}>+3</button>\\n      <button onClick={() => {\\n        increment();\\n      }}>+1</button>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin: 10px; font-size: 20px; }\\nh1 { display: block; margin: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"passing-the-next-state-directly\",\"children\":\"直接传递下一个状态 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个示例 \",[\"$r\",\"strong\",null,{\"children\":\"没有\"}],\" 传递更新函数，所以“+3”按钮 \",[\"$r\",\"strong\",null,{\"children\":\"不能按预期的方式工作\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Counter() {\\n  const [age, setAge] = useState(42);\\n\\n  function increment() {\\n    setAge(age + 1);\\n  }\\n\\n  return (\\n    <>\\n      <h1>Your age: {age}</h1>\\n      <button onClick={() => {\\n        increment();\\n        increment();\\n        increment();\\n      }}>+3</button>\\n      <button onClick={() => {\\n        increment();\\n      }}>+1</button>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin: 10px; font-size: 20px; }\\nh1 { display: block; margin: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"122\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"updating-objects-and-arrays-in-state\",\"children\":\"更新状态中的对象和数组 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以将对象和数组放入状态中。在 React 中，状态被认为是只读的，因此 \",[\"$r\",\"strong\",null,{\"children\":\"你应该替换它而不是改变现有对象\"}],\"。例如，如果你在状态中保存了一个 \",[\"$r\",\"code\",null,{\"children\":\"form\"}],\" 对象，请不要改变它：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"// 🚩 不要像下面这样改变一个对象：\\nform.firstName = 'Taylor';\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"相反，可以通过创建一个新对象来替换整个对象：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"// ✅ 使用新对象替换 state\\nsetForm({\\n  ...form,\\n  firstName: 'Taylor'\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读有关 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-objects-in-state\",\"children\":\"更新状态中的对象\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state\",\"children\":\"更新状态中的数组\"}],\" 来了解更多。\"]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"状态中的对象和数组的示例\",\"titleId\":\"examples-objects\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"form-object\",\"children\":\"表单（对象）\"}],[\"$r\",\"p\",null,{\"children\":[\"在此示例中，\",[\"$r\",\"code\",null,{\"children\":\"form\"}],\" 状态变量保存一个对象。每个输入框都有一个变更处理函数，用整个表单的下一个状态调用 \",[\"$r\",\"code\",null,{\"children\":\"setForm\"}],\"。\",[\"$r\",\"code\",null,{\"children\":\"{ ...form }\"}],\" 展开语法确保替换状态对象而不是改变它。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [form, setForm] = useState({\\n    firstName: 'Barbara',\\n    lastName: 'Hepworth',\\n    email: 'bhepworth@sculpture.com',\\n  });\\n\\n  return (\\n    <>\\n      <label>\\n        First name:\\n        <input\\n          value={form.firstName}\\n          onChange={e => {\\n            setForm({\\n              ...form,\\n              firstName: e.target.value\\n            });\\n          }}\\n        />\\n      </label>\\n      <label>\\n        Last name:\\n        <input\\n          value={form.lastName}\\n          onChange={e => {\\n            setForm({\\n              ...form,\\n              lastName: e.target.value\\n            });\\n          }}\\n        />\\n      </label>\\n      <label>\\n        Email:\\n        <input\\n          value={form.email}\\n          onChange={e => {\\n            setForm({\\n              ...form,\\n              email: e.target.value\\n            });\\n          }}\\n        />\\n      </label>\\n      <p>\\n        {form.firstName}{' '}\\n        {form.lastName}{' '}\\n        ({form.email})\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\ninput { margin-left: 5px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"form-nested-object\",\"children\":\"表单（嵌套对象）\"}],[\"$r\",\"p\",null,{\"children\":[\"在此示例中，状态更为嵌套。当你更新嵌套状态时，你需要复制一份正在更新的对象，以及向上“包含”它的所有对象。阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-objects-in-state#updating-a-nested-object\",\"children\":\"更新嵌套对象\"}],\" 以了解更多。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function Form() {\\n  const [person, setPerson] = useState({\\n    name: 'Niki de Saint Phalle',\\n    artwork: {\\n      title: 'Blue Nana',\\n      city: 'Hamburg',\\n      image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\n    }\\n  });\\n\\n  function handleNameChange(e) {\\n    setPerson({\\n      ...person,\\n      name: e.target.value\\n    });\\n  }\\n\\n  function handleTitleChange(e) {\\n    setPerson({\\n      ...person,\\n      artwork: {\\n        ...person.artwork,\\n        title: e.target.value\\n      }\\n    });\\n  }\\n\\n  function handleCityChange(e) {\\n    setPerson({\\n      ...person,\\n      artwork: {\\n        ...person.artwork,\\n        city: e.target.value\\n      }\\n    });\\n  }\\n\\n  function handleImageChange(e) {\\n    setPerson({\\n      ...person,\\n      artwork: {\\n        ...person.artwork,\\n        image: e.target.value\\n      }\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <label>\\n        Name:\\n        <input\\n          value={person.name}\\n          onChange={handleNameChange}\\n        />\\n      </label>\\n      <label>\\n        Title:\\n        <input\\n          value={person.artwork.title}\\n          onChange={handleTitleChange}\\n        />\\n      </label>\\n      <label>\\n        City:\\n        <input\\n          value={person.artwork.city}\\n          onChange={handleCityChange}\\n        />\\n      </label>\\n      <label>\\n        Image:\\n        <input\\n          value={person.artwork.image}\\n          onChange={handleImageChange}\\n        />\\n      </label>\\n      <p>\\n        <i>{person.artwork.title}</i>\\n        {' by '}\\n        {person.name}\\n        <br />\\n        (located in {person.artwork.city})\\n      </p>\\n      <img \\n        src={person.artwork.image} \\n        alt={person.artwork.title}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\ninput { margin-left: 5px; margin-bottom: 5px; }\\nimg { width: 200px; height: 200px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"list-array\",\"children\":\"列表（数组） \"}],[\"$r\",\"p\",null,{\"children\":[\"在本例中，\",[\"$r\",\"code\",null,{\"children\":\"todos\"}],\" 状态变量保存一个数组。每个按钮的处理函数使用该数组的下一个版本调用 \",[\"$r\",\"code\",null,{\"children\":\"setTodos\"}],\"。\",[\"$r\",\"code\",null,{\"children\":\"[...todos]\"}],\" 展开语法，\",[\"$r\",\"code\",null,{\"children\":\"todos.map()\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"todos.filter()\"}],\" 确保状态数组被替换而不是改变。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport AddTodo from './AddTodo.js';\\nimport TaskList from './TaskList.js';\\n\\nlet nextId = 3;\\nconst initialTodos = [\\n  { id: 0, title: 'Buy milk', done: true },\\n  { id: 1, title: 'Eat tacos', done: false },\\n  { id: 2, title: 'Brew tea', done: false },\\n];\\n\\nexport default function TaskApp() {\\n  const [todos, setTodos] = useState(initialTodos);\\n\\n  function handleAddTodo(title) {\\n    setTodos([\\n      ...todos,\\n      {\\n        id: nextId++,\\n        title: title,\\n        done: false\\n      }\\n    ]);\\n  }\\n\\n  function handleChangeTodo(nextTodo) {\\n    setTodos(todos.map(t => {\\n      if (t.id === nextTodo.id) {\\n        return nextTodo;\\n      } else {\\n        return t;\\n      }\\n    }));\\n  }\\n\\n  function handleDeleteTodo(todoId) {\\n    setTodos(\\n      todos.filter(t => t.id !== todoId)\\n    );\\n  }\\n\\n  return (\\n    <>\\n      <AddTodo\\n        onAddTodo={handleAddTodo}\\n      />\\n      <TaskList\\n        todos={todos}\\n        onChangeTodo={handleChangeTodo}\\n        onDeleteTodo={handleDeleteTodo}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTodo.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function AddTodo({ onAddTodo }) {\\n  const [title, setTitle] = useState('');\\n  return (\\n    <>\\n      <input\\n        placeholder=\\\"Add todo\\\"\\n        value={title}\\n        onChange={e => setTitle(e.target.value)}\\n      />\\n      <button onClick={() => {\\n        setTitle('');\\n        onAddTodo(title);\\n      }}>Add</button>\\n    </>\\n  )\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function TaskList({\\n  todos,\\n  onChangeTodo,\\n  onDeleteTodo\\n}) {\\n  return (\\n    <ul>\\n      {todos.map(todo => (\\n        <li key={todo.id}>\\n          <Task\\n            todo={todo}\\n            onChange={onChangeTodo}\\n            onDelete={onDeleteTodo}\\n          />\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\\nfunction Task({ todo, onChange, onDelete }) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  let todoContent;\\n  if (isEditing) {\\n    todoContent = (\\n      <>\\n        <input\\n          value={todo.title}\\n          onChange={e => {\\n            onChange({\\n              ...todo,\\n              title: e.target.value\\n            });\\n          }} />\\n        <button onClick={() => setIsEditing(false)}>\\n          Save\\n        </button>\\n      </>\\n    );\\n  } else {\\n    todoContent = (\\n      <>\\n        {todo.title}\\n        <button onClick={() => setIsEditing(true)}>\\n          Edit\\n        </button>\\n      </>\\n    );\\n  }\\n  return (\\n    <label>\\n      <input\\n        type=\\\"checkbox\\\"\\n        checked={todo.done}\\n        onChange={e => {\\n          onChange({\\n            ...todo,\\n            done: e.target.checked\\n          });\\n        }}\\n      />\\n      {todoContent}\\n      <button onClick={() => onDelete(todo.id)}>\\n        Delete\\n      </button>\\n    </label>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\nli { list-style-type: none; }\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"writing-concise-update-logic-with-immer\",\"children\":\"用 Immer 编写简洁的更新逻辑 \"}],[\"$r\",\"p\",null,{\"children\":[\"如果不能直接改变数组和对象来进行更新感觉很烦琐，你可以使用像 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/immerjs/use-immer\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Immer\"}],\" 这样的库来减少重复的代码。Immer 可以让你编写简洁的代码，就像你可以直接改变对象一样，但在底层它执行的是不改变的更新：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\nimport { useImmer } from 'use-immer';\\n\\nlet nextId = 3;\\nconst initialList = [\\n  { id: 0, title: 'Big Bellies', seen: false },\\n  { id: 1, title: 'Lunar Landscape', seen: false },\\n  { id: 2, title: 'Terracotta Army', seen: true },\\n];\\n\\nexport default function BucketList() {\\n  const [list, updateList] = useImmer(initialList);\\n\\n  function handleToggle(artworkId, nextSeen) {\\n    updateList(draft => {\\n      const artwork = draft.find(a =>\\n        a.id === artworkId\\n      );\\n      artwork.seen = nextSeen;\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <h1>Art Bucket List</h1>\\n      <h2>My list of art to see:</h2>\\n      <ItemList\\n        artworks={list}\\n        onToggle={handleToggle} />\\n    </>\\n  );\\n}\\n\\nfunction ItemList({ artworks, onToggle }) {\\n  return (\\n    <ul>\\n      {artworks.map(artwork => (\\n        <li key={artwork.id}>\\n          <label>\\n            <input\\n              type=\\\"checkbox\\\"\\n              checked={artwork.seen}\\n              onChange={e => {\\n                onToggle(\\n                  artwork.id,\\n                  e.target.checked\\n                );\\n              }}\\n            />\\n            {artwork.title}\\n          </label>\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"immer\\\": \\\"1.7.3\\\",\\n    \\\"react\\\": \\\"latest\\\",\\n    \\\"react-dom\\\": \\\"latest\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"142\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"avoiding-recreating-the-initial-state\",\"children\":\"避免重复创建初始状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"React 只在初次渲染时保存初始状态，后续渲染时将其忽略。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function TodoList() {\\n  const [todos, setTodos] = useState(createInitialTodos());\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"尽管 \",[\"$r\",\"code\",null,{\"children\":\"createInitialTodos()\"}],\" 的结果仅用于初始渲染，但你仍然在每次渲染时调用此函数。如果它创建大数组或执行昂贵的计算，这可能会浪费资源。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了解决这个问题，你可以将它 \",[\"$r\",\"strong\",null,{\"children\":\"作为初始化函数传递给\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function TodoList() {\\n  const [todos, setTodos] = useState(createInitialTodos);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，你传递的是 \",[\"$r\",\"code\",null,{\"children\":\"createInitialTodos\"}],\" \",[\"$r\",\"strong\",null,{\"children\":\"函数本身\"}],\"，而不是 \",[\"$r\",\"code\",null,{\"children\":\"createInitialTodos()\"}],\" 调用该函数的结果。如果将函数传递给 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\"，React 仅在初始化期间调用它。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 在开发模式下可能会调用你的 \",[\"$r\",\"a\",null,{\"href\":\"#my-initializer-or-updater-function-runs-twice\",\"children\":\"初始化函数\"}],\" 两次，以验证它们是否是 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"纯函数\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"传递初始化函数和直接传递初始状态之间的区别\",\"titleId\":\"examples-initializer\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"passing-the-initializer-function\",\"children\":\"传递初始化函数 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个例子传递了初始化函数，因此 \",[\"$r\",\"code\",null,{\"children\":\"createInitialTodos\"}],\" 函数仅在初始化期间运行。当组件重新渲染，例如你在输入框中键入内容时，它不会再次运行。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nfunction createInitialTodos() {\\n  const initialTodos = [];\\n  for (let i = 0; i < 50; i++) {\\n    initialTodos.push({\\n      id: i,\\n      text: 'Item ' + (i + 1)\\n    });\\n  }\\n  return initialTodos;\\n}\\n\\nexport default function TodoList() {\\n  const [todos, setTodos] = useState(createInitialTodos);\\n  const [text, setText] = useState('');\\n\\n  return (\\n    <>\\n      <input\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button onClick={() => {\\n        setText('');\\n        setTodos([{\\n          id: todos.length,\\n          text: text\\n        }, ...todos]);\\n      }}>Add</button>\\n      <ul>\\n        {todos.map(item => (\\n          <li key={item.id}>\\n            {item.text}\\n          </li>\\n        ))}\\n      </ul>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"passing-the-initial-state-directly\",\"children\":\"直接传递初始状态 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个例子 \",[\"$r\",\"strong\",null,{\"children\":\"没有\"}],\" 传递初始化函数，因此 \",[\"$r\",\"code\",null,{\"children\":\"createInitialTodos\"}],\" 函数会在每次渲染时运行，比如当你在输入框中输入时。这种行为没有什么明显的差异，但这种代码是不那么高效的。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\n\\nfunction createInitialTodos() {\\n  const initialTodos = [];\\n  for (let i = 0; i < 50; i++) {\\n    initialTodos.push({\\n      id: i,\\n      text: 'Item ' + (i + 1)\\n    });\\n  }\\n  return initialTodos;\\n}\\n\\nexport default function TodoList() {\\n  const [todos, setTodos] = useState(createInitialTodos());\\n  const [text, setText] = useState('');\\n\\n  return (\\n    <>\\n      <input\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button onClick={() => {\\n        setText('');\\n        setTodos([{\\n          id: todos.length,\\n          text: text\\n        }, ...todos]);\\n      }}>Add</button>\\n      <ul>\\n        {todos.map(item => (\\n          <li key={item.id}>\\n            {item.text}\\n          </li>\\n        ))}\\n      </ul>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"154\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"resetting-state-with-a-key\",\"children\":\"使用 key 重置状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 \",[\"$r\",\"a\",null,{\"href\":\"/learn/rendering-lists\",\"children\":\"渲染列表\"}],\" 时，你经常会遇到 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 属性。然而，它还有另外一个用途。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以 \",[\"$r\",\"strong\",null,{\"children\":[\"通过向组件传递不同的 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 来重置组件的状态\"]}],\"。在这个例子中，重置按钮改变 \",[\"$r\",\"code\",null,{\"children\":\"version\"}],\" 状态变量，我们将它作为一个 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 传递给 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件。当 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\" 改变时，React 会从头开始重新创建 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 组件（以及它的所有子组件），所以它的状态被重置了。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/preserving-and-resetting-state\",\"children\":\"保留和重置状态\"}],\" 以了解更多。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function App() {\\n  const [version, setVersion] = useState(0);\\n\\n  function handleReset() {\\n    setVersion(version + 1);\\n  }\\n\\n  return (\\n    <>\\n      <button onClick={handleReset}>Reset</button>\\n      <Form key={version} />\\n    </>\\n  );\\n}\\n\\nfunction Form() {\\n  const [name, setName] = useState('Taylor');\\n\\n  return (\\n    <>\\n      <input\\n        value={name}\\n        onChange={e => setName(e.target.value)}\\n      />\\n      <p>Hello, {name}.</p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 20px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"174\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"storing-information-from-previous-renders\",\"children\":\"存储前一次渲染的信息 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通常情况下，你会在事件处理函数中更新状态。然而，在极少数情况下，你可能希望在响应渲染时调整状态——例如，当 props 改变时，你可能希望改变状态变量。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在大多数情况下，你不需要这样做：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"如果你需要的值可以完全从当前 props 或其他 state 中计算出来，那么 \",[\"$r\",\"a\",null,{\"href\":\"/learn/choosing-the-state-structure#avoid-redundant-state\",\"children\":\"完全可以移除那些多余的状态\"}]]}],\"。如果你担心重新计算的频率过高，可以使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" Hook\"]}],\" 来帮助优化。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你想重置整个组件树的状态，\",[\"$r\",\"a\",null,{\"href\":\"#resetting-state-with-a-key\",\"children\":[\"可以向组件传递一个不同的 \",[\"$r\",\"code\",null,{\"children\":\"key\"}]]}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果可以的话，在事件处理函数中更新所有相关状态。\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在极为罕见的情况下，如果上述方法都不适用，你还可以使用一种方式，在组件渲染时调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数来基于已经渲染的值更新状态。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这里是一个例子。这个 \",[\"$r\",\"code\",null,{\"children\":\"CountLabel\"}],\" 组件显示传递给它的 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" props：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/CountLabel.js\",\"children\":\"export default function CountLabel({ count }) {\\n  return <h1>{count}</h1>\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"假设你想显示计数器是否自上次更改以来 \",[\"$r\",\"strong\",null,{\"children\":\"增加或减少\"}],\"。\",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" props 无法告诉你这一点——你需要跟踪它的先前值。添加 \",[\"$r\",\"code\",null,{\"children\":\"prevCount\"}],\" 状态变量来跟踪它，再添加另一个状态变量 \",[\"$r\",\"code\",null,{\"children\":\"trend\"}],\" 来保存计数是否增加或减少。比较 \",[\"$r\",\"code\",null,{\"children\":\"prevCount\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\"，如果它们不相等，则更新 \",[\"$r\",\"code\",null,{\"children\":\"prevCount\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"trend\"}],\"。现在你既可以显示当前的 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" props，也可以显示 \",[\"$r\",\"strong\",null,{\"children\":\"自上次渲染以来它如何改变\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\nimport CountLabel from './CountLabel.js';\\n\\nexport default function App() {\\n  const [count, setCount] = useState(0);\\n  return (\\n    <>\\n      <button onClick={() => setCount(count + 1)}>\\n        Increment\\n      </button>\\n      <button onClick={() => setCount(count - 1)}>\\n        Decrement\\n      </button>\\n      <CountLabel count={count} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/CountLabel.js active\",\"children\":\"import { useState } from 'react';\\n\\nexport default function CountLabel({ count }) {\\n  const [prevCount, setPrevCount] = useState(count);\\n  const [trend, setTrend] = useState(null);\\n  if (prevCount !== count) {\\n    setPrevCount(count);\\n    setTrend(count > prevCount ? 'increasing' : 'decreasing');\\n  }\\n  return (\\n    <>\\n      <h1>{count}</h1>\\n      {trend && <p>The count is {trend}</p>}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin-bottom: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，在渲染时调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数时，它必须位于条件语句中，例如 \",[\"$r\",\"code\",null,{\"children\":\"prevCount !== count\"}],\"，并且必须在该条件语句中调用 \",[\"$r\",\"code\",null,{\"children\":\"setPrevCount(count)\"}],\"。否则，你的组件将在循环中重新渲染，直到崩溃。此外，你只能像这样更新 \",[\"$r\",\"strong\",null,{\"children\":\"当前渲染\"}],\" 组件的状态。在渲染过程中调用 \",[\"$r\",\"strong\",null,{\"children\":\"另一个\"}],\" 组件的 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数是错误的。最后，你的 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 调用仍应 \",[\"$r\",\"a\",null,{\"href\":\"#updating-objects-and-arrays-in-state\",\"children\":\"不直接改变 state 来更新\"}],\" 状态——这并不意味着你可以违反其他 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"纯函数\"}],\" 的规则。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这种方式可能很难理解，通常最好避免使用。但是，它比在 effect 中更新状态要好。当你在渲染期间调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数时，React 将在你的组件使用 \",[\"$r\",\"code\",null,{\"children\":\"return\"}],\" 语句退出后立即重新渲染该组件，并在渲染子组件前进行。这样，子组件就不需要进行两次渲染。你的组件函数的其余部分仍会执行（然后结果将被丢弃）。如果你的条件判断在所有 Hook 调用的下方，可以提前添加一个 \",[\"$r\",\"code\",null,{\"children\":\"return;\"}],\" 以便更早地重新开始渲染。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"ive-updated-the-state-but-logging-gives-me-the-old-value\",\"children\":\"我已经更新了状态，但日志仍显示旧值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数 \",[\"$r\",\"strong\",null,{\"children\":\"不能改变运行中代码的状态\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,5,8}\",\"children\":\"function handleClick() {\\n  console.log(count);  // 0\\n\\n  setCount(count + 1); // 请求使用 1 重新渲染\\n  console.log(count);  // 仍然是 0!\\n\\n  setTimeout(() => {\\n    console.log(count); // 还是 0!\\n  }, 5000);\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这是因为 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"状态表现为就像一个快照\"}],\"。更新状态会使用新的状态值请求另一个渲染，但并不影响在你已经运行的事件处理函数中的 \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" JavaScript 变量。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你需要使用下一个状态，你可以在将其传递给 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数之前将其保存在一个变量中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const nextCount = count + 1;\\nsetCount(nextCount);\\n\\nconsole.log(count);     // 0\\nconsole.log(nextCount); // 1\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"ive-updated-the-state-but-the-screen-doesnt-update\",\"children\":\"我已经更新了状态，但是屏幕没有更新 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"如果下一个状态等于先前的状态，React 将忽略你的更新\"}],\"，这是由 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 比较确定的。这通常发生在你直接更改状态中的对象或数组时：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"obj.x = 10;  // 🚩 错误：直接修改现有的对象\\nsetObj(obj); // 🚩 不会发生任何事情\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你修改了一个现有的 \",[\"$r\",\"code\",null,{\"children\":\"obj\"}],\" 对象并将其传递回 \",[\"$r\",\"code\",null,{\"children\":\"setObj\"}],\"，因此 React 忽略了更新。为了解决这个问题，你需要确保始终\",[\"$r\",\"a\",null,{\"href\":\"#updating-objects-and-arrays-in-state\",\"children\":[\"在状态中 \",[\"$r\",\"strong\",null,{\"children\":\"替换\"}],\" 对象和数组，而不是对它们进行 \",[\"$r\",\"strong\",null,{\"children\":\"更改\"}]]}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"// ✅ 正确：创建一个新对象\\nsetObj({\\n  ...obj,\\n  x: 10\\n});\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"im-getting-an-error-too-many-re-renders\",\"children\":\"出现错误：“Too many re-renders” \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"有时可能会出现错误：“Too many re-renders”。React 会限制渲染次数，以防止进入无限循环。通常，这意味着 \",[\"$r\",\"strong\",null,{\"children\":\"在渲染期间\"}],\" 无条件地设置状态，因此组件进入循环：渲染、设置状态（导致重新渲染）、渲染、设置状态（导致重新渲染）等等。通常，这是由错误地指定事件处理函数时引起的：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1-2}\",\"children\":\"// 🚩 错误：在渲染过程中调用事件处理函数\\nreturn <button onClick={handleClick()}>Click me</button>\\n\\n// ✅ 正确：将事件处理函数传递下去\\nreturn <button onClick={handleClick}>Click me</button>\\n\\n// ✅ 正确：传递一个内联函数\\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果找不到这个错误的原因，请单击控制台中错误旁边的箭头，查看 JavaScript 堆栈以找到导致错误的具体 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数调用。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-initializer-or-updater-function-runs-twice\",\"children\":\"初始化函数或更新函数运行了两次 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/StrictMode\",\"children\":\"严格模式\"}],\" 下，React 会调用你的某些函数两次而不是一次：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,5-6,11-12}\",\"children\":\"function TodoList() {\\n  // 该函数组件会在每次渲染运行两次。\\n\\n  const [todos, setTodos] = useState(() => {\\n    // 该初始化函数在初始化期间会运行两次。\\n    return createTodos();\\n  });\\n\\n  function handleClick() {\\n    setTodos(prevTodos => {\\n      // 该更新函数在每次点击中都会运行两次\\n      return [...prevTodos, createTodo()];\\n    });\\n  }\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这是所期望的，且不应该破坏你的代码。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这种 \",[\"$r\",\"strong\",null,{\"children\":\"仅在开发环境下生效\"}],\" 的行为有助于 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"保持组件的纯粹性\"}],\"。React 使用其中一个调用的结果，而忽略另一个调用的结果。只要你的组件、初始化函数和更新函数是纯粹的，就不会影响你的逻辑。但是，如果它们意外地不纯粹，这将帮助你注意到错误。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"例如，这个不纯的更新函数改变了 state 中的一个数组：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,3}\",\"children\":\"setTodos(prevTodos => {\\n  // 🚩 错误：改变 state\\n  prevTodos.push(createTodo());\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"因为 React 调用了两次更新函数，所以你将看到 todo 被添加了两次，所以你将知道出现了错误。在这个例子中，你可以通过 \",[\"$r\",\"a\",null,{\"href\":\"#updating-objects-and-arrays-in-state\",\"children\":\"替换数组而不是更改数组\"}],\" 来修复这个错误：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,3}\",\"children\":\"setTodos(prevTodos => {\\n  // ✅ 正确：使用新状态替换\\n  return [...prevTodos, createTodo()];\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在，这个更新函数是纯粹的，所以多调用一次不会对行为产生影响。这就是为什么 React 调用它两次可以帮助你找到错误的原因。\",[\"$r\",\"strong\",null,{\"children\":\"只有组件、初始化函数和更新函数需要是纯粹的\"}],\"。事件处理函数不需要是纯粹的，所以 React 不会两次调用你的事件处理函数。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"保持组件纯粹\"}],\" 以了解更多信息。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"im-trying-to-set-state-to-a-function-but-it-gets-called-instead\",\"children\":\"我尝试将 state 设置为一个函数，但它却被调用了 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你不能像这样把函数放入状态：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [fn, setFn] = useState(someFunction);\\n\\nfunction handleClick() {\\n  setFn(someOtherFunction);\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"因为你传递了一个函数，React 认为 \",[\"$r\",\"code\",null,{\"children\":\"someFunction\"}],\" 是一个 \",[\"$r\",\"a\",null,{\"href\":\"#avoiding-recreating-the-initial-state\",\"children\":\"初始化函数\"}],\"，而 \",[\"$r\",\"code\",null,{\"children\":\"someOtherFunction\"}],\" 是一个 \",[\"$r\",\"a\",null,{\"href\":\"#updating-state-based-on-the-previous-state\",\"children\":\"更新函数\"}],\"，于是它尝试调用它们并存储结果。要实际 \",[\"$r\",\"strong\",null,{\"children\":\"存储\"}],\" 一个函数，你必须在两种情况下在它们之前加上 \",[\"$r\",\"code\",null,{\"children\":\"() =>\"}],\"。然后 React 将存储你传递的函数。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,4}\",\"children\":\"const [fn, setFn] = useState(() => someFunction);\\n\\nfunction handleClick() {\\n  setFn(() => someOtherFunction);\\n}\\n\"}]}]]}]]","meta":{"title":"useState"}},"__N_SSG":true}