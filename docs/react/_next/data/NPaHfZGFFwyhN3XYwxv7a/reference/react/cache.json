{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#cache\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"cache(fn)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#cache-expensive-computation\",\"depth\":3,\"text\":\"缓存代价昂贵的计算 \"},{\"url\":\"#take-and-share-snapshot-of-data\",\"depth\":3,\"text\":\"共享数据快照 \"},{\"url\":\"#preload-data\",\"depth\":3,\"text\":\"预加载数据 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#memoized-function-still-runs\",\"depth\":3,\"text\":\"尽管传递的是相同参数，我的记忆化函数仍在重新运行 \"}]","content":"[[\"$r\",\"MaxWidth\",\"last\",{\"children\":[[\"$r\",\"Canary\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 仅供与 \",[\"$r\",\"a\",null,{\"href\":\"/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components\",\"children\":\"React 服务器组件\"}],\" 一起使用。请参阅支持 React 服务器组件的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/start-a-new-react-project#bleeding-edge-react-frameworks\",\"children\":\"框架\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 仅在 React 的 \",[\"$r\",\"a\",null,{\"href\":\"/community/versioning-policy#canary-channel\",\"children\":\"Canary\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/community/versioning-policy#experimental-channel\",\"children\":\"experimental\"}],\" 渠道中可用。在将 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 用于生产环境之前，请确保了解其限制。查看此处了解有关 \",[\"$r\",\"a\",null,{\"href\":\"/community/versioning-policy#all-release-channels\",\"children\":\"React 发布渠道的更多信息\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 允许缓存数据获取或计算的结果。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const cachedFn = cache(fn);\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"cache\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"cache(fn)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在任何组件之外调用 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 以创建带有缓存的函数版本。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,7}\",\"children\":\"import {cache} from 'react';\\nimport calculateMetrics from 'lib/metrics';\\n\\nconst getMetrics = cache(calculateMetrics);\\n\\nfunction Chart({data}) {\\n  const report = getMetrics(data);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当首次使用 \",[\"$r\",\"code\",null,{\"children\":\"data\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"getMetrics\"}],\" 时，\",[\"$r\",\"code\",null,{\"children\":\"getMetrics\"}],\" 将调用 \",[\"$r\",\"code\",null,{\"children\":\"calculateMetrics(data)\"}],\" 并将结果存储在缓存中。如果再次使用相同的 \",[\"$r\",\"code\",null,{\"children\":\"data\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"getMetrics\"}],\"，它将返回缓存的结果，而不会再次调用 \",[\"$r\",\"code\",null,{\"children\":\"calculateMetrics(data)\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"fn\"}],\"：要对其结果进行缓存的函数。\",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\" 可以接受任何参数并返回任何值。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 返回一个与 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\" 具有相同类型签名的已缓存版本。在此过程中，它不会调用 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在使用给定的参数调用 \",[\"$r\",\"code\",null,{\"children\":\"cachedFn\"}],\" 时，它首先检查缓存中是否存在缓存的结果。如果存在缓存的结果，它将返回该结果。如果没有，它将使用参数调用 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\"，将结果存储在缓存中，并返回该结果。只有在缓存未命中时才会调用 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\"。\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"基于输入进行返回值缓存的优化称为 \",[\"$r\",\"a\",null,{\"href\":\"https://en.wikipedia.org/wiki/Memoization\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"记忆化\"}],\"。我们将从 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 返回的函数称为一个记忆化函数。\"]}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"React 将在每次服务器请求时使所有记忆化函数的缓存失效。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"每次调用 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 都会创建一个新函数。这意味着多次使用相同的函数调用 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 将返回不共享相同缓存的不同记忆化函数。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"cachedFn\"}],\" 还会缓存错误。如果对于某些参数 \",[\"$r\",\"code\",null,{\"children\":\"fn\"}],\" 抛出错误，错误将被缓存，当使用相同参数调用 \",[\"$r\",\"code\",null,{\"children\":\"cachedFn\"}],\" 时，相同的错误将被重新抛出。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 仅供在 \",[\"$r\",\"a\",null,{\"href\":\"/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components\",\"children\":\"服务器组件\"}],\" 中使用。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"cache-expensive-computation\",\"children\":\"缓存代价昂贵的计算 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 跳过重复工作。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 7, \\\"getUserMetrics(user)\\\"],[2, 13, \\\"getUserMetrics(user)\\\"]]\",\"children\":\"import {cache} from 'react';\\nimport calculateUserMetrics from 'lib/user';\\n\\nconst getUserMetrics = cache(calculateUserMetrics);\\n\\nfunction Profile({user}) {\\n  const metrics = getUserMetrics(user);\\n  // ...\\n}\\n\\nfunction TeamReport({users}) {\\n  for (let user in users) {\\n    const metrics = getUserMetrics(user);\\n    // ...\\n  }\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果相同的 \",[\"$r\",\"code\",null,{\"children\":\"user\"}],\" 对象在 \",[\"$r\",\"code\",null,{\"children\":\"Profile\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"TeamReport\"}],\" 中都被渲染，那么这两个组件可以共享工作，并且只为该 \",[\"$r\",\"code\",null,{\"children\":\"user\"}],\" 调用一次 \",[\"$r\",\"code\",null,{\"children\":\"calculateUserMetrics\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"假设首先渲染了 \",[\"$r\",\"code\",null,{\"children\":\"Profile\"}],\"。它将调用 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"getUserMetrics\"}]}],\"，并检查是否有缓存的结果。由于这是第一次以该 \",[\"$r\",\"code\",null,{\"children\":\"user\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"getUserMetrics\"}],\"，所以缓存未命中。于是 \",[\"$r\",\"code\",null,{\"children\":\"getUserMetrics\"}],\" 将会使用 \",[\"$r\",\"code\",null,{\"children\":\"user\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"calculateUserMetrics\"}],\" 并将结果写入缓存。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当 \",[\"$r\",\"code\",null,{\"children\":\"TeamReport\"}],\" 使用相同的 \",[\"$r\",\"code\",null,{\"children\":\"user\"}],\" 对象来渲染 \",[\"$r\",\"code\",null,{\"children\":\"users\"}],\" 列表时，它将调用 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"getUserMetrics\"}]}],\" 并从缓存中读取结果。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"h5\",null,{\"id\":\"pitfall-different-memoized-functions\",\"children\":\"调用不同的记忆化函数将从不同的缓存中读取数据 \"}],[\"$r\",\"p\",null,{\"children\":\"要访问相同的缓存，组件必须调用同一个记忆化函数。\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 7, \\\"getWeekReport\\\"], [1, 7, \\\"cache(calculateWeekReport)\\\"], [1, 8, \\\"getWeekReport\\\"]]\",\"children\":\"// Temperature.js\\nimport {cache} from 'react';\\nimport {calculateWeekReport} from './report';\\n\\nexport function Temperature({cityData}) {\\n  // 🚩 错误示例：在组件中调用 `cache` 会为每次渲染创建新的 `getWeekReport`。\\n  const getWeekReport = cache(calculateWeekReport);\\n  const report = getWeekReport(cityData);\\n  // ...\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 6, \\\"getWeekReport\\\"], [2, 6, \\\"cache(calculateWeekReport)\\\"], [2, 9, \\\"getWeekReport\\\"]]\",\"children\":\"// Precipitation.js\\nimport {cache} from 'react';\\nimport {calculateWeekReport} from './report';\\n\\n// 🚩 错误示例：`getWeekReport` 仅供 `Precipitation` 组件访问。\\nconst getWeekReport = cache(calculateWeekReport);\\n\\nexport function Precipitation({cityData}) {\\n  const report = getWeekReport(cityData);\\n  // ...\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"在上面的示例中，\",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"Precipitation\"}]}],\" 和 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"Temperature\"}]}],\" 都将调用 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 创建新的记忆化函数，并使用自己的缓存查找。如果两个组件都使用相同的 \",[\"$r\",\"code\",null,{\"children\":\"cityData\"}],\" 进行渲染，它们将重复调用 \",[\"$r\",\"code\",null,{\"children\":\"calculateWeekReport\"}],\"，进行重复的工作。\"]}],[\"$r\",\"p\",null,{\"children\":[\"此外，\",[\"$r\",\"code\",null,{\"children\":\"Temperature\"}],\" 每次组件渲染时都创建一个 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"新的记忆化函数\"}],\"，这不允许任何缓存共享。\"]}],[\"$r\",\"p\",null,{\"children\":[\"为了最大化缓存命中率并减少工作量，这两个组件应该调用相同的记忆化函数以访问相同的缓存。因此应该在专用模块中定义记忆化函数，以在不同组件之间使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"import\"}],\"-ed\"]}],\" 进行共享。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[3, 5, \\\"export default cache(calculateWeekReport)\\\"]]\",\"children\":\"// getWeekReport.js\\nimport {cache} from 'react';\\nimport {calculateWeekReport} from './report';\\n\\nexport default cache(calculateWeekReport);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[3, 2, \\\"getWeekReport\\\", 0], [3, 5, \\\"getWeekReport\\\"]]\",\"children\":\"// Temperature.js\\nimport getWeekReport from './getWeekReport';\\n\\nexport default function Temperature({cityData}) {\\n\\tconst report = getWeekReport(cityData);\\n  // ...\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[3, 2, \\\"getWeekReport\\\", 0], [3, 5, \\\"getWeekReport\\\"]]\",\"children\":\"// Precipitation.js\\nimport getWeekReport from './getWeekReport';\\n\\nexport default function Precipitation({cityData}) {\\n  const report = getWeekReport(cityData);\\n  // ...\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"在这里，两个组件都调用从 \",[\"$r\",\"code\",null,{\"children\":\"./getWeekReport.js\"}],\" 导出的 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"相同的记忆化函数\"}],\" 来读取和写入相同的缓存。\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"take-and-share-snapshot-of-data\",\"children\":\"共享数据快照 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"要在组件之间共享数据快照，请使用类似 \",[\"$r\",\"code\",null,{\"children\":\"fetch\"}],\" 的数据获取函数调用 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\"。当多个组件进行相同的数据获取时，只会发出一个请求，并且返回的数据会被缓存并在各个组件之间共享。所有组件在服务器渲染期间都引用相同的数据快照。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 4, \\\"city\\\"], [1, 5, \\\"fetchTemperature(city)\\\"], [2, 4, \\\"getTemperature\\\"], [2, 9, \\\"getTemperature\\\"], [1, 9, \\\"city\\\"], [2, 14, \\\"getTemperature\\\"], [1, 14, \\\"city\\\"]]\",\"children\":\"import {cache} from 'react';\\nimport {fetchTemperature} from './api.js';\\n\\nconst getTemperature = cache(async (city) => {\\n\\treturn await fetchTemperature(city);\\n});\\n\\nasync function AnimatedWeatherCard({city}) {\\n\\tconst temperature = await getTemperature(city);\\n\\t// ...\\n}\\n\\nasync function MinimalWeatherCard({city}) {\\n\\tconst temperature = await getTemperature(city);\\n\\t// ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"AnimatedWeatherCard\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"MinimalWeatherCard\"}],\" 都为相同的 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"city\"}]}],\" 进行渲染，它们将从 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"记忆化函数\"}],\" 接收相同的数据快照。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 \",[\"$r\",\"code\",null,{\"children\":\"AnimatedWeatherCard\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"MinimalWeatherCard\"}],\" 向 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"getTemperature\"}]}],\" 提供不同的 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"city\"}]}],\" 参数，那么将调用两次 \",[\"$r\",\"code\",null,{\"children\":\"fetchTemperature\"}],\"，并且每个调用站点将接收不同的数据。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"city\"}]}],\" 在其中充当缓存键。\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"异步渲染\"}],\" 只在服务器组件中支持。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[3, 1, \\\"async\\\"], [3, 2, \\\"await\\\"]]\",\"children\":\"async function AnimatedWeatherCard({city}) {\\n\\tconst temperature = await getTemperature(city);\\n\\t// ...\\n}\\n\"}]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"preload-data\",\"children\":\"预加载数据 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通过缓存长时间运行的数据获取，你可以在渲染组件之前开始异步工作。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"meta\":\"[[2, 6, \\\"await getUser(id)\\\"], [1, 17, \\\"getUser(id)\\\"]]\",\"children\":\"const getUser = cache(async (id) => {\\n  return await db.user.query(id);\\n}\\n\\nasync function Profile({id}) {\\n  const user = await getUser(id);\\n  return (\\n    <section>\\n      <img src={user.profilePic} />\\n      <h2>{user.name}</h2>\\n    </section>\\n  );\\n}\\n\\nfunction Page({id}) {\\n  // ✅ 正确示例：开始获取用户数据。\\n  getUser(id);\\n  // ……一些计算工作\\n  return (\\n    <>\\n      <Profile id={id} />\\n    </>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在渲染 \",[\"$r\",\"code\",null,{\"children\":\"Page\"}],\" 时，组件调用 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"getUser\"}]}],\"，但请注意它并不使用返回的数据。这个早期的 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"getUser\"}]}],\" 调用会启动异步数据库查询，而在 \",[\"$r\",\"code\",null,{\"children\":\"Page\"}],\" 执行其他计算工作并渲染子组件时进行。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在渲染 \",[\"$r\",\"code\",null,{\"children\":\"Profile\"}],\" 时，我们再次调用 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"getUser\"}]}],\"。如果初始 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"getUser\"}]}],\" 调用已经返回并缓存了用户数据，那么当 \",[\"$r\",\"code\",null,{\"children\":\"Profile\"}],\" 在 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"请求并等待这些数据\"}],\" 时，它可以简单地从缓存中读取，而无需进行另一个远程过程调用。如果初始 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"fetchData\"}]}],\" 还没有完成，那么在这种模式下预加载数据可以减少数据获取的延迟。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"caching-asynchronous-work\",\"children\":\"缓存异步工作 \"}],[\"$r\",\"p\",null,{\"children\":[\"在评估 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"异步函数\"}],\" 时，你将收到一个 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Promise\"}],\"，该 Promise 包含了该工作的状态（pending，fulfilled，failed）和最终的完成结果。\"]}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，异步函数 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"fetchData\"}]}],\" 返回一个等待 \",[\"$r\",\"code\",null,{\"children\":\"fetch\"}],\" 的 promise。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 1, \\\"fetchData()\\\"], [2, 8, \\\"getData()\\\"], [3, 10, \\\"getData()\\\"]]\",\"children\":\"async function fetchData() {\\n  return await fetch(`https://...`);\\n}\\n\\nconst getData = cache(fetchData);\\n\\nasync function MyComponent() {\\n  getData();\\n  // ……一些计算工作\\n  await getData();\\n  // ……\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"在第一次调用 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"getData\"}]}],\" 时，从 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"fetchData\"}]}],\" 返回的 promise 将被缓存。随后的查找将返回相同的 promise。\"]}],[\"$r\",\"p\",null,{\"children\":[\"请注意，第一次调用 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"getData\"}]}],\" 不使用 \",[\"$r\",\"code\",null,{\"children\":\"await\"}],\"，而 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"第二次\"}],\" 调用会使用。\",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"await\"}]}],\" 是 JavaScript 中的一个操作符，它会等待并返回 promise 的已解决结果。第一次调用 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"getData\"}]}],\" 仅启动 \",[\"$r\",\"code\",null,{\"children\":\"fetch\"}],\" 以缓存 promise，以供 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"第二次\"}],\" 查找。\"]}],[\"$r\",\"p\",null,{\"children\":[\"如果在 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"第二次\"}],\" 调用时，promise 仍处于 pending 状态，那么 \",[\"$r\",\"code\",null,{\"children\":\"await\"}],\" 会等待结果。优化之处在于，在等待 \",[\"$r\",\"code\",null,{\"children\":\"fetch\"}],\" 的同时，React 可以继续进行计算工作，从而减少了第二次调用的等待时间。\"]}],[\"$r\",\"p\",null,{\"children\":[\"如果 promise 已经解决，无论是得到错误还是 fulfilled 的结果，\",[\"$r\",\"code\",null,{\"children\":\"await\"}],\" 都会立即返回该值。在这两种结果中，都存在性能优势。\"]}]]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"h5\",null,{\"id\":\"pitfall-memoized-call-outside-component\",\"children\":\"在组件外部调用记忆化函数将不使用缓存 \"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"meta\":\"[[1, 3, \\\"getUser\\\"]]\",\"children\":\"import {cache} from 'react';\\n\\nconst getUser = cache(async (userId) => {\\n  return await db.user.query(userId);\\n});\\n\\n// 🚩 错误示例：在组件外部调用记忆化函数将不进行记忆化。\\ngetUser('demo-id');\\n\\nasync function DemoProfile() {\\n  // ✅ 正确示例：`getUser` 将进行记忆化。\\n  const user = await getUser('demo-id');\\n  return <Profile user={user} />;\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"React 只允许在组件内访问记忆化函数的缓存。在组件外部调用 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":[\"$r\",\"code\",null,{\"children\":\"getUser\"}]}],\" 时，它仍会评估函数，但不会读取或更新缓存。\"]}],[\"$r\",\"p\",null,{\"children\":[\"这是因为缓存访问是通过 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"上下文（context）\"}],\" 提供的，而上下文只能从组件中访问。\"]}]]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"cache-memo-usememo\",\"children\":[\"应该何时使用 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\"、\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\"？ \"]}],[\"$r\",\"p\",null,{\"children\":\"所有提到的 API 都提供了记忆化功能，它们的区别在于记忆化什么、谁可以访问缓存以及何时缓存会失效。\"}],[\"$r\",\"h4\",null,{\"id\":\"deep-dive-use-memo\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" \"]}],[\"$r\",\"p\",null,{\"children\":[\"一般来说，\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\" 用于在客户端组件跨渲染时缓存昂贵的计算。例如，可以用它来记忆化组件内部数据的转换。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-jsx\",\"meta\":\"{4}\",\"children\":\"'use client';\\n\\nfunction WeatherReport({record}) {\\n  const avgTemp = useMemo(() => calculateAvg(record)), record);\\n  // ...\\n}\\n\\nfunction App() {\\n  const record = getRecord();\\n  return (\\n    <>\\n      <WeatherReport record={record} />\\n      <WeatherReport record={record} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，\",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 渲染了两个具有相同记录的 \",[\"$r\",\"code\",null,{\"children\":\"WeatherReport\"}],\"。尽管这两个组件都执行相同的工作，但它们无法共享工作。\",[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" 的缓存仅在组件内部可用。\"]}],[\"$r\",\"p\",null,{\"children\":[\"但是 \",[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" 能够确保如果 \",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 重新渲染并且 \",[\"$r\",\"code\",null,{\"children\":\"record\"}],\" 对象没有更改，每个组件实例都将跳过工作并使用 \",[\"$r\",\"code\",null,{\"children\":\"avgTemp\"}],\" 的记忆化值。\",[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" 仅会缓存具有给定依赖项的 \",[\"$r\",\"code\",null,{\"children\":\"avgTemp\"}],\" 的最后一次计算结果。\"]}],[\"$r\",\"h4\",null,{\"id\":\"deep-dive-cache\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" \"]}],[\"$r\",\"p\",null,{\"children\":[\"一般来说，\",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 应用于服务器组件以记忆化可以跨组件共享的工作。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 12, \\\"<WeatherReport city={city} />\\\"], [3, 13, \\\"<WeatherReport city={city} />\\\"], [2, 1, \\\"cache(fetchReport)\\\"]]\",\"children\":\"const cachedFetchReport = cache(fetchReport);\\n\\nfunction WeatherReport({city}) {\\n  const report = cachedFetchReport(city);\\n  // ...\\n}\\n\\nfunction App() {\\n  const city = \\\"Los Angeles\\\";\\n  return (\\n    <>\\n      <WeatherReport city={city} />\\n      <WeatherReport city={city} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 重新编写前面的示例，在这种情况下，\",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":[[\"$r\",\"code\",null,{\"children\":\"WeatherReport\"}],\" 的第二个实例\"]}],\" 将能够跳过重复的工作并从与第一个 \",[\"$r\",\"code\",null,{\"children\":\"WeatherReport\"}],\" 相同的缓存中读取。与前面的示例不同的另一个地方是，\",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 也推荐用于 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"记忆化数据获取\"}],\"，而 \",[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" 只应用于计算。\"]}],[\"$r\",\"p\",null,{\"children\":[\"目前 \",[\"$r\",\"code\",null,{\"children\":\"cache\"}],\" 应该仅在服务器组件中使用，并且缓存会在服务器请求之间失效。\"]}],[\"$r\",\"h4\",null,{\"id\":\"deep-dive-memo\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"memo\"}],\" \"]}],[\"$r\",\"p\",null,{\"children\":[\"你应该使用 \",[\"$r\",\"a\",null,{\"href\":\"reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\" 防止组件在其 \",[\"$r\",\"code\",null,{\"children\":\"props\"}],\" 未更改时重新渲染。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"'use client';\\n\\nfunction WeatherReport({record}) {\\n  const avgTemp = calculateAvg(record); \\n  // ...\\n}\\n\\nconst MemoWeatherReport = memo(WeatherReport);\\n\\nfunction App() {\\n  const record = getRecord();\\n  return (\\n    <>\\n      <MemoWeatherReport record={record} />\\n      <MemoWeatherReport record={record} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，两个 \",[\"$r\",\"code\",null,{\"children\":\"MemoWeatherReport\"}],\" 组件在首次渲染时都会调用 \",[\"$r\",\"code\",null,{\"children\":\"calculateAvg\"}],\"。然而，如果 \",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 重新渲染，但没有更改 \",[\"$r\",\"code\",null,{\"children\":\"record\"}],\"，则没有 props 发生更改，\",[\"$r\",\"code\",null,{\"children\":\"MemoWeatherReport\"}],\" 将不会重新渲染。\"]}],[\"$r\",\"p\",null,{\"children\":[\"与 \",[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" 相比，\",[\"$r\",\"code\",null,{\"children\":\"memo\"}],\" 根据 props 而不是特定计算来记忆化组件渲染。与 \",[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\" 类似，记忆化的组件只缓存了具有最后一组 prop 值的最后一次渲染。一旦 props 更改，缓存将失效，组件将重新渲染。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"memoized-function-still-runs\",\"children\":\"尽管传递的是相同参数，我的记忆化函数仍在重新运行 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"请查看之前提到的常见问题：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#pitfall-different-memoized-functions\",\"children\":\"调用不同的记忆化函数将从不同的缓存中读取\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#pitfall-memoized-call-outside-component\",\"children\":\"在组件外部调用记忆化函数将不使用缓存\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果以上问题都不适用，那么可能是与 React 检查缓存中是否存在内容的方式有关。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果参数不是原始数据类型(\",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)%EF%BC%88%E4%BE%8B%E5%A6%82%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E6%95%B0%E7%BB%84%EF%BC%89%EF%BC%8C%E8%AF%B7%E7%A1%AE%E4%BF%9D%E4%BC%A0%E9%80%92%E7%9A%84%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E3%80%82\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)（例如对象、函数、数组），请确保传递的是相同的对象引用。\"}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在调用记忆化函数时，React 将查找输入参数，以查看是否已经缓存了结果。React 将使用浅相等确定是否存在缓存。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import {cache} from 'react';\\n\\nconst calculateNorm = cache((vector) => {\\n  // ...\\n});\\n\\nfunction MapMarker(props) {\\n  // 🚩 错误示例：props 是一个对象，每次渲染时都会更改\\n  const length = calculateNorm(props);\\n  // ...\\n}\\n\\nfunction App() {\\n  return (\\n    <>\\n      <MapMarker x={10} y={10} z={10} />\\n      <MapMarker x={10} y={10} z={10} />\\n    </>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这种情况下，两个 \",[\"$r\",\"code\",null,{\"children\":\"MapMarker\"}],\" 看起来执行相同的工作，并使用相同的值 \",[\"$r\",\"code\",null,{\"children\":\"{x: 10, y: 10, z: 10}\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"calculateNorm\"}],\"。尽管这些对象包含相同的值，但它们不是相同的对象引用，因为每个组件都创建了自己的 props 对象。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 将调用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Object.is\"}],\" 来验证是否存在缓存命中。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,9}\",\"children\":\"import {cache} from 'react';\\n\\nconst calculateNorm = cache((x, y, z) => {\\n  // ...\\n});\\n\\nfunction MapMarker(props) {\\n  // ✅ 正确示例：传递原始类型给记忆化函数\\n  const length = calculateNorm(props.x, props.y, props.z);\\n  // ...\\n}\\n\\nfunction App() {\\n  return (\\n    <>\\n      <MapMarker x={10} y={10} z={10} />\\n      <MapMarker x={10} y={10} z={10} />\\n    </>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"解决这个问题的一种方法是将向量的维度传递给 \",[\"$r\",\"code\",null,{\"children\":\"calculateNorm\"}],\"。这个方法有效，因为维度本身是原始数据类型。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"另一种解决方案可能是将向量对象本身作为一个 prop 传递给组件。我们需要将相同的对象传递给两个组件实例。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,9,14}\",\"children\":\"import {cache} from 'react';\\n\\nconst calculateNorm = cache((vector) => {\\n  // ...\\n});\\n\\nfunction MapMarker(props) {\\n  // ✅ 正确示例：传递相同的 `vector` 对象。\\n  const length = calculateNorm(props.vector);\\n  // ...\\n}\\n\\nfunction App() {\\n  const vector = [10, 10, 10];\\n  return (\\n    <>\\n      <MapMarker vector={vector} />\\n      <MapMarker vector={vector} />\\n    </>\\n  );\\n}\\n\"}]}]]}]]","meta":{"title":"cache","canary":true}},"__N_SSG":true}