{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#useref\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useRef(initialValue)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"使用 \"},{\"url\":\"#referencing-a-value-with-a-ref\",\"depth\":3,\"text\":\"使用用 ref 引用一个值 \"},{\"url\":\"#manipulating-the-dom-with-a-ref\",\"depth\":3,\"text\":\"通过 ref 操作 DOM \"},{\"url\":\"#avoiding-recreating-the-ref-contents\",\"depth\":3,\"text\":\"避免重复创建 ref 的内容 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#i-cant-get-a-ref-to-a-custom-component\",\"depth\":3,\"text\":\"无法获取自定义组件的 ref \"}]","content":"[[\"$r\",\"MaxWidth\",\"60\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 是一个 React Hook，它能帮助引用一个不需要渲染的值。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const ref = useRef(initialValue)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"useref\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useRef(initialValue)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件顶层调用 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 以声明一个 \",[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs\",\"children\":\"ref\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nfunction MyComponent() {\\n  const intervalRef = useRef(0);\\n  const inputRef = useRef(null);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请参阅下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"initialValue\"}],\"：ref 对象的 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性的初始值。可以是任意类型的值。这个参数在首次渲染后被忽略。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 返回一个只有一个属性的对象:\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"current\"}],\"：初始值为传递的 \",[\"$r\",\"code\",null,{\"children\":\"initialValue\"}],\"。之后可以将其设置为其他值。如果将 ref 对象作为一个 JSX 节点的 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性传递给 React，React 将为它设置 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在后续的渲染中，\",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 将返回同一个对象。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"可以修改 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 属性。与 state 不同，它是可变的。然而，如果它持有一个用于渲染的对象（例如 state 的一部分），那么就不应该修改这个对象。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"改变 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 属性时，React 不会重新渲染组件。React 不知道它何时会发生改变，因为 ref 是一个普通的 JavaScript 对象。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"除了 \",[\"$r\",\"a\",null,{\"href\":\"#avoiding-recreating-the-ref-contents\",\"children\":\"初始化\"}],\" 外不要在渲染期间写入或者读取 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\"，否则会使组件行为变得不可预测。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在严格模式下，React 将会 \",[\"$r\",\"strong\",null,{\"children\":\"调用两次组件方法\"}],\"，这是为了 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#my-initializer-or-updater-function-runs-twice\",\"children\":\"帮助发现意外问题\"}],\"。但这只是开发模式下的行为，不会影响生产模式。每个 ref 对象都将会创建两次，但是其中一个版本将被丢弃。如果使用的是组件纯函数（也应当如此），那么这不会影响其行为。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"使用 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"referencing-a-value-with-a-ref\",\"children\":\"使用用 ref 引用一个值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件顶层调用 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 声明一个或多个 \",[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs\",\"children\":\"ref\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 4, \\\"intervalRef\\\"], [3, 4, \\\"0\\\"]]\",\"children\":\"import { useRef } from 'react';\\n\\nfunction Stopwatch() {\\n  const intervalRef = useRef(0);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 返回一个具有单个 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性\"]}],\" 的 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"ref 对象\"}],\"，并初始化为你提供的 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"初始值\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在后续的渲染中，\",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 将返回相同的对象。你可以改变它的 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性来存储信息，并在之后读取它。这会让人联想到 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"state\"}],\"，但是有一个重要的区别。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"改变 ref 不会触发重新渲染\"}],\"。这意味着 ref 是存储一些不影响组件视图输出信息的完美选择。例如，如果需要存储一个 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"interval ID\"}],\" 并在以后检索它，那么可以将它存储在 ref 中。只需要手动改变它的 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性\"]}],\" 即可修改 ref 的值：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 5, \\\"intervalRef.current\\\"]]\",\"children\":\"function handleStartClick() {\\n  const intervalId = setInterval(() => {\\n    // ...\\n  }, 1000);\\n  intervalRef.current = intervalId;\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在之后，从 ref 中读取 interval ID 便可以 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/clearInterval\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"清除定时器\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 2, \\\"intervalRef.current\\\"]]\",\"children\":\"function handleStopClick() {\\n  const intervalId = intervalRef.current;\\n  clearInterval(intervalId);\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"使用 ref 可以确保：\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"可以在重新渲染之间 \",[\"$r\",\"strong\",null,{\"children\":\"存储信息\"}],\"（普通对象存储的值每次渲染都会重置）。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"改变它 \",[\"$r\",\"strong\",null,{\"children\":\"不会触发重新渲染\"}],\"（状态变量会触发重新渲染）。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"对于组件的每个副本而言，\",[\"$r\",\"strong\",null,{\"children\":\"这些信息都是本地的\"}],\"（外部变量则是共享的）。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"改变 ref 不会触发重新渲染，所以 ref 不适合用于存储期望显示在屏幕上的信息。如有需要，使用 state 代替。阅读更多关于 \",[\"$r\",\"a\",null,{\"href\":\"/learn/referencing-values-with-refs#differences-between-refs-and-state\",\"children\":[\"在 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 之间选择\"]}],\" 的信息。\"]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"Examples of referencing a value with useRef\",\"titleId\":\"examples-value\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"click-counter\",\"children\":\"点击计数器 \"}],[\"$r\",\"p\",null,{\"children\":\"这个组件使用 ref 记录按钮被点击的次数。注意，在这里使用 ref 而不是 state 是可以的，因为点击次数只在事件处理程序中被读取和写入。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Counter() {\\n  let ref = useRef(0);\\n\\n  function handleClick() {\\n    ref.current = ref.current + 1;\\n    alert('You clicked ' + ref.current + ' times!');\\n  }\\n\\n  return (\\n    <button onClick={handleClick}>\\n      点击！\\n    </button>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"p\",null,{\"children\":[\"如果在 JSX 中显示 \",[\"$r\",\"code\",null,{\"children\":\"{ref.current}\"}],\"，数字不会在点击时更新。这是因为修改 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 不会触发重新渲染——用于渲染的信息应该使用 state。\"]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"a-stopwatch\",\"children\":\"秒表 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个例子使用了 state 和 ref 的组合。\",[\"$r\",\"code\",null,{\"children\":\"startTime\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"now\"}],\" 都是 state 变量，因为它们是用来渲染的。但是还需要持有 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"interval ID\"}],\" 以在按下按钮时停止定时器。因为 interval ID 不用于渲染，所以应该把它保存在一个 ref 中，并且手动更新它。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function Stopwatch() {\\n  const [startTime, setStartTime] = useState(null);\\n  const [now, setNow] = useState(null);\\n  const intervalRef = useRef(null);\\n\\n  function handleStart() {\\n    setStartTime(Date.now());\\n    setNow(Date.now());\\n\\n    clearInterval(intervalRef.current);\\n    intervalRef.current = setInterval(() => {\\n      setNow(Date.now());\\n    }, 10);\\n  }\\n\\n  function handleStop() {\\n    clearInterval(intervalRef.current);\\n  }\\n\\n  let secondsPassed = 0;\\n  if (startTime != null && now != null) {\\n    secondsPassed = (now - startTime) / 1000;\\n  }\\n\\n  return (\\n    <>\\n      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>\\n      <button onClick={handleStart}>\\n        开始\\n      </button>\\n      <button onClick={handleStop}>\\n        停止\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"86\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"不要在渲染期间写入或者读取 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}]]}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[\"React 期望组件主体 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"表现得像一个纯函数\"}],\"：\"]}],[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果输入的（\",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-props-to-a-component\",\"children\":\"props\"}],\"、\",[\"$r\",\"a\",null,{\"href\":\"/learn/state-a-components-memory\",\"children\":\"state\"}],\" 与 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"上下文\"}],\"）都是一样的，那么就应该返回一样的 JSX。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"以不同的顺序或用不同的参数调用它，不应该影响其他调用的结果。\"}],\"\\n\"]}],[\"$r\",\"p\",null,{\"children\":[\"在 \",[\"$r\",\"strong\",null,{\"children\":\"渲染期间\"}],\" 读取或写入 ref 会破坏这些预期行为。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-4,6-7}\",\"children\":\"function MyComponent() {\\n  // ...\\n  // 🚩 不要在渲染期间写入 ref\\n  myRef.current = 123;\\n  // ...\\n  // 🚩 不要在渲染期间读取 ref\\n  return <h1>{myOtherRef.current}</h1>;\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"可以在 \",[\"$r\",\"strong\",null,{\"children\":\"事件处理程序或者 Effect\"}],\" 中读取和写入 ref。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-5,9-10}\",\"children\":\"function MyComponent() {\\n  // ...\\n  useEffect(() => {\\n    // ✅ 可以在 Effect 中读取和写入 ref\\n    myRef.current = 123;\\n  });\\n  // ...\\n  function handleClick() {\\n    // ✅ 可以在事件处理程序中读取和写入 ref\\n    doSomething(myOtherRef.current);\\n  }\\n  // ...\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"如果不得不在渲染期间读取 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#storing-information-from-previous-renders\",\"children\":\"或者写入\"}],\"，那么应该 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"使用 state\"}],\" 代替。\"]}],[\"$r\",\"p\",null,{\"children\":[\"当打破这些规则时，组件可能仍然可以工作，但是我们为 React 添加的大多数新功能将依赖于这些预期行为。阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure#where-you-_can_-cause-side-effects\",\"children\":\"保持组件纯粹\"}],\" 以了解更多信息。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"manipulating-the-dom-with-a-ref\",\"children\":\"通过 ref 操作 DOM \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 ref 操作 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DOM\"}],\" 是非常常见的行为。React 内置了对它的支持。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"首先，声明一个 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"初始值\"}],\" 为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 的 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"ref 对象\"}]]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 4, \\\"inputRef\\\"], [3, 4, \\\"null\\\"]]\",\"children\":\"import { useRef } from 'react';\\n\\nfunction MyComponent() {\\n  const inputRef = useRef(null);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然后将 ref 对象作为 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 属性传递给想要操作的 DOM 节点的 JSX：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 2, \\\"inputRef\\\"]]\",\"children\":\"  // ...\\n  return <input ref={inputRef} />;\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当 React 创建 DOM 节点并将其渲染到屏幕时，React 将会把 DOM 节点设置为 ref 对象的 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性\"]}],\"。现在可以借助 ref 对象访问 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" 的 DOM 节点，并且可以调用类似于 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/focus\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"focus()\"}]}],\" 的方法：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 2, \\\"inputRef.current\\\"]]\",\"children\":\"  function handleClick() {\\n    inputRef.current.focus();\\n  }\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当节点从屏幕上移除时，React 将把 \",[\"$r\",\"code\",null,{\"children\":\"current\"}],\" 属性设置回 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs\",\"children\":\"用 ref 操纵 DOM\"}],\" 以了解更多信息。\"]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"Examples of manipulating the DOM with useRef\",\"titleId\":\"examples-dom\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"focusing-a-text-input\",\"children\":\"聚焦文字输入框 \"}],[\"$r\",\"p\",null,{\"children\":\"在这个示例中，点击按钮将会聚焦输入框：\"}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function Form() {\\n  const inputRef = useRef(null);\\n\\n  function handleClick() {\\n    inputRef.current.focus();\\n  }\\n\\n  return (\\n    <>\\n      <input ref={inputRef} />\\n      <button onClick={handleClick}>\\n        聚焦输入框\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"scrolling-an-image-into-view\",\"children\":\"滚动图片到视图 \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，点击按钮将会把图片滚动到视图。这里使用 ref 绑定到列表的 DOM 节点，然后调用 DOM 的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"querySelectorAll\"}]}],\" API 找到想要滚动的图片。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useRef } from 'react';\\n\\nexport default function CatFriends() {\\n  const listRef = useRef(null);\\n\\n  function scrollToIndex(index) {\\n    const listNode = listRef.current;\\n    // This line assumes a particular DOM structure:\\n    const imgNode = listNode.querySelectorAll('li > img')[index];\\n    imgNode.scrollIntoView({\\n      behavior: 'smooth',\\n      block: 'nearest',\\n      inline: 'center'\\n    });\\n  }\\n\\n  return (\\n    <>\\n      <nav>\\n        <button onClick={() => scrollToIndex(0)}>\\n          Tom\\n        </button>\\n        <button onClick={() => scrollToIndex(1)}>\\n          Maru\\n        </button>\\n        <button onClick={() => scrollToIndex(2)}>\\n          Jellylorum\\n        </button>\\n      </nav>\\n      <div>\\n        <ul ref={listRef}>\\n          <li>\\n            <img\\n              src=\\\"https://placekitten.com/g/200/200\\\"\\n              alt=\\\"Tom\\\"\\n            />\\n          </li>\\n          <li>\\n            <img\\n              src=\\\"https://placekitten.com/g/300/200\\\"\\n              alt=\\\"Maru\\\"\\n            />\\n          </li>\\n          <li>\\n            <img\\n              src=\\\"https://placekitten.com/g/250/200\\\"\\n              alt=\\\"Jellylorum\\\"\\n            />\\n          </li>\\n        </ul>\\n      </div>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"div {\\n  width: 100%;\\n  overflow: hidden;\\n}\\n\\nnav {\\n  text-align: center;\\n}\\n\\nbutton {\\n  margin: .25rem;\\n}\\n\\nul,\\nli {\\n  list-style: none;\\n  white-space: nowrap;\\n}\\n\\nli {\\n  display: inline;\\n  padding: 0.5rem;\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"playing-and-pausing-a-video\",\"children\":\"播放和暂停视频 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个示例使用 ref 调用 \",[\"$r\",\"code\",null,{\"children\":\"<video>\"}],\" DOM 节点的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/play\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"play()\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/pause\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"pause()\"}]}],\" 方法。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useRef } from 'react';\\n\\nexport default function VideoPlayer() {\\n  const [isPlaying, setIsPlaying] = useState(false);\\n  const ref = useRef(null);\\n\\n  function handleClick() {\\n    const nextIsPlaying = !isPlaying;\\n    setIsPlaying(nextIsPlaying);\\n\\n    if (nextIsPlaying) {\\n      ref.current.play();\\n    } else {\\n      ref.current.pause();\\n    }\\n  }\\n\\n  return (\\n    <>\\n      <button onClick={handleClick}>\\n        {isPlaying ? '暂停' : '播放'}\\n      </button>\\n      <video\\n        width=\\\"250\\\"\\n        ref={ref}\\n        onPlay={() => setIsPlaying(true)}\\n        onPause={() => setIsPlaying(false)}\\n      >\\n        <source\\n          src=\\\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\\\"\\n          type=\\\"video/mp4\\\"\\n        />\\n      </video>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-bottom: 20px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"exposing-a-ref-to-your-own-component\",\"children\":\"向组件暴露 ref \"}],[\"$r\",\"p\",null,{\"children\":[\"有时可能想让父级组件在组件中操纵 DOM。例如，假设正在编写一个 \",[\"$r\",\"code\",null,{\"children\":\"MyInput\"}],\" 组件，但希望父组件能够聚焦 input（不过父组件无法访问）。此时可以使用组件组合，通过 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 持有输入框并通过 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/forwardRef\",\"children\":[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}]}],\" 将其暴露给父组件。在这里阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes\",\"children\":\"详细演练\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { forwardRef, useRef } from 'react';\\n\\nconst MyInput = forwardRef((props, ref) => {\\n  return <input {...props} ref={ref} />;\\n});\\n\\nexport default function Form() {\\n  const inputRef = useRef(null);\\n\\n  function handleClick() {\\n    inputRef.current.focus();\\n  }\\n\\n  return (\\n    <>\\n      <MyInput ref={inputRef} />\\n      <button onClick={handleClick}>\\n        聚焦输入框\\n      </button>\\n    </>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"avoiding-recreating-the-ref-contents\",\"children\":\"避免重复创建 ref 的内容 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"React 会保存 ref 初始值，并在后续的渲染中忽略它。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Video() {\\n  const playerRef = useRef(new VideoPlayer());\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"虽然 \",[\"$r\",\"code\",null,{\"children\":\"new VideoPlayer()\"}],\" 的结果只会在首次渲染时使用，但是依然在每次渲染时都在调用这个方法。如果是创建昂贵的对象，这可能是一种浪费。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"为了解决这个问题，你可以像这样初始化 ref：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Video() {\\n  const playerRef = useRef(null);\\n  if (playerRef.current === null) {\\n    playerRef.current = new VideoPlayer();\\n  }\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常情况下，在渲染过程中写入或读取 \",[\"$r\",\"code\",null,{\"children\":\"ref.current\"}],\" 是不允许的。然而，在这种情况下是可以的，因为结果总是一样的，而且条件只在初始化时执行，所以是完全可预测的。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"how-to-avoid-null-checks-when-initializing-use-ref-later\",\"children\":[\"避免在初始化 \",[\"$r\",\"code\",null,{\"children\":\"useRef\"}],\" 之后进行 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 的类型检查 \"]}],[\"$r\",\"p\",null,{\"children\":[\"如果使用了类型检查器，并且不想总是检查 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，可以尝试用这样的模式来代替：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Video() {\\n  const playerRef = useRef(null);\\n\\n  function getPlayer() {\\n    if (playerRef.current !== null) {\\n      return playerRef.current;\\n    }\\n    const player = new VideoPlayer();\\n    playerRef.current = player;\\n    return player;\\n  }\\n\\n  // ...\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"在这里，\",[\"$r\",\"code\",null,{\"children\":\"playerRef\"}],\" 本身是可以为空的。然而，应该能够使类型检查器确信，不存在 \",[\"$r\",\"code\",null,{\"children\":\"getPlayer()\"}],\" 返回 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 的情况。然后在事件处理程序中调用 \",[\"$r\",\"code\",null,{\"children\":\"getPlayer()\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"i-cant-get-a-ref-to-a-custom-component\",\"children\":\"无法获取自定义组件的 ref \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果尝试像这样传递 \",[\"$r\",\"code\",null,{\"children\":\"ref\"}],\" 到自定义组件：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const inputRef = useRef(null);\\n\\nreturn <MyInput ref={inputRef} />;\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可能会在控制台中得到这样的错误：\"}],\"\\n\",[\"$r\",\"ConsoleBlock\",null,{\"level\":\"error\",\"children\":[\"$r\",\"p\",null,{\"children\":\"Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"默认情况下，自定义组件不会暴露它们内部 DOM 节点的 ref。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"为了解决这个问题，首先，找到想获得 ref 的组件：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"export default function MyInput({ value, onChange }) {\\n  return (\\n    <input\\n      value={value}\\n      onChange={onChange}\\n    />\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"然后像这样将其包装在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/forwardRef\",\"children\":[\"$r\",\"code\",null,{\"children\":\"forwardRef\"}]}],\" 里：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,8}\",\"children\":\"import { forwardRef } from 'react';\\n\\nconst MyInput = forwardRef(({ value, onChange }, ref) => {\\n  return (\\n    <input\\n      value={value}\\n      onChange={onChange}\\n      ref={ref}\\n    />\\n  );\\n});\\n\\nexport default MyInput;\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"最后，父级组件就可以得到它的 ref。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes\",\"children\":\"访问另一个组件的 DOM 节点\"}],\" 以了解更多信息。\"]}]]}]]","meta":{"title":"useRef"}},"__N_SSG":true}