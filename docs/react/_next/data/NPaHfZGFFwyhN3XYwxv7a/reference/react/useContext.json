{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#usecontext\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useContext(SomeContext)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#passing-data-deeply-into-the-tree\",\"depth\":3,\"text\":\"向组件树深层传递数据 \"},{\"url\":\"#updating-data-passed-via-context\",\"depth\":3,\"text\":\"通过 context 更新传递的数据 \"},{\"url\":\"#specifying-a-fallback-default-value\",\"depth\":3,\"text\":\"指定后备方案默认值 \"},{\"url\":\"#overriding-context-for-a-part-of-the-tree\",\"depth\":3,\"text\":\"覆盖组件树一部分的 context \"},{\"url\":\"#optimizing-re-renders-when-passing-objects-and-functions\",\"depth\":3,\"text\":\"在传递对象和函数时优化重新渲染 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#my-component-doesnt-see-the-value-from-my-provider\",\"depth\":3,\"text\":\"我的组件获取不到 provider 传递的值\"},{\"url\":\"#i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different\",\"depth\":3,\"text\":[\"尽管设置了不一样的默认值，但是我总是从 context 中得到 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]}]","content":"[[\"$r\",\"MaxWidth\",\"48\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 是一个 React Hook，可以让你读取和订阅组件中的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const value = useContext(SomeContext)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"usecontext\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext(SomeContext)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的顶层调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 来读取和订阅 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useContext } from 'react';\\n\\nfunction MyComponent() {\\n  const theme = useContext(ThemeContext);\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请看下方更多示例。\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\"：先前用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"createContext\"}]}],\" 创建的 context。context 本身不包含信息，它只代表你可以提供或从组件中读取的信息类型。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 为调用组件返回 context 的值。它被确定为传递给树中调用组件上方最近的 \",[\"$r\",\"code\",null,{\"children\":\"SomeContext.Provider\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\"。如果没有这样的 provider，那么返回值将会是为创建该 context 传递给 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"createContext\"}]}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"defaultValue\"}],\"。返回的值始终是最新的。如果 context 发生变化，React 会自动重新渲染读取 context 的组件。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"组件中的 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 调用不受 \",[\"$r\",\"strong\",null,{\"children\":\"同一\"}],\" 组件返回的 provider 的影响。相应的 \",[\"$r\",\"code\",null,{\"children\":\"<Context.Provider>\"}],\" 需要位于调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 的组件 \",[\"$r\",\"strong\",null,{\"children\":\"之上\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"从 provider 接收到不同的 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\" 开始，React 自动重新渲染使用了该特定 context 的所有子级。先前的值和新的值会使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 来做比较。使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\" 来跳过重新渲染并不妨碍子级接收到新的 context 值。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果您的构建系统在输出中产生重复的模块（可能发生在符号链接中），这可能会破坏 context。通过 context 传递数据只有在用于传递 context 的 \",[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\" 和用于读取数据的  \",[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\" 是完全相同的对象时才有效，这是由 \",[\"$r\",\"code\",null,{\"children\":\"===\"}],\" 比较决定的。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"passing-data-deeply-into-the-tree\",\"children\":\"向组件树深层传递数据 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的最顶级调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 来读取和订阅 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 4, \\\"theme\\\"], [1, 4, \\\"ThemeContext\\\"]]\",\"children\":\"import { useContext } from 'react';\\n\\nfunction Button() {\\n  const theme = useContext(ThemeContext);\\n  // ... \\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 返回你向 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"context\"}],\" 传递的 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"context value\"}],\"。为了确定 context 值，React 搜索组件树，为这个特定的 context \",[\"$r\",\"strong\",null,{\"children\":\"向上查找最近的\"}],\" context provider。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"若要将 context 传递给 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\"，请将其或其父组件之一包装到相应的 context provider：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 3, \\\"ThemeContext\\\"], [2, 3, \\\"\\\\\\\"dark\\\\\\\"\\\"], [1, 5, \\\"ThemeContext\\\"]]\",\"children\":\"function MyPage() {\\n  return (\\n    <ThemeContext.Provider value=\\\"dark\\\">\\n      <Form />\\n    </ThemeContext.Provider>\\n  );\\n}\\n\\nfunction Form() {\\n  // ... 在内部渲染 buttons ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"provider 和 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 之间有多少层组件并不重要。当 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 中的任何位置的 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext(ThemeContext)\"}],\" 时，它都将接收 \",[\"$r\",\"code\",null,{\"children\":\"\\\"dark\\\"\"}],\" 作为值。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 总是在调用它的组件 \",[\"$r\",\"strong\",null,{\"children\":\"上面\"}],\" 寻找最近的 provider。它向上搜索， \",[\"$r\",\"strong\",null,{\"children\":\"不考虑\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 的组件中的 provider。\"]}]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext } from 'react';\\n\\nconst ThemeContext = createContext(null);\\n\\nexport default function MyApp() {\\n  return (\\n    <ThemeContext.Provider value=\\\"dark\\\">\\n      <Form />\\n    </ThemeContext.Provider>\\n  )\\n}\\n\\nfunction Form() {\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      <Button>Sign up</Button>\\n      <Button>Log in</Button>\\n    </Panel>\\n  );\\n}\\n\\nfunction Panel({ title, children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'panel-' + theme;\\n  return (\\n    <section className={className}>\\n      <h1>{title}</h1>\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'button-' + theme;\\n  return (\\n    <button className={className}>\\n      {children}\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"60\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"updating-data-passed-via-context\",\"children\":\"通过 context 更新传递的数据 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常，你会希望 context 随着时间的推移而改变。要更新 context，请将其与 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"state\"}],\" 结合。在父组件中声明一个状态变量，并将当前状态作为 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"context value\"}],\" 传递给 provider。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2} [[1, 4, \\\"ThemeContext\\\"], [2, 4, \\\"theme\\\"], [1, 11, \\\"ThemeContext\\\"]]\",\"children\":\"function MyPage() {\\n  const [theme, setTheme] = useState('dark');\\n  return (\\n    <ThemeContext.Provider value={theme}>\\n      <Form />\\n      <Button onClick={() => {\\n        setTheme('light');\\n      }}>\\n       Switch to light theme\\n      </Button>\\n    </ThemeContext.Provider>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在 provider 中的任何一个 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 都会接收到当前的 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 值。如果调用 \",[\"$r\",\"code\",null,{\"children\":\"setTheme\"}],\" 来更新传递给 provider 的 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 值，则所有 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 组件都将使用新的值 \",[\"$r\",\"code\",null,{\"children\":\"'light'\"}],\" 来重新渲染。\"]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"更新 context 的例子\",\"titleId\":\"examples-basic\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"updating-a-value-via-context\",\"children\":\"通过 context 来更新数据 \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，\",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 组件包含一个状态变量，然后该变量被传递给 \",[\"$r\",\"code\",null,{\"children\":\"ThemeContext\"}],\" provider。选中“Dark mode”复选框更新状态。更改提供的值将重新渲染使用该 context 的所有组件。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\n\\nconst ThemeContext = createContext(null);\\n\\nexport default function MyApp() {\\n  const [theme, setTheme] = useState('light');\\n  return (\\n    <ThemeContext.Provider value={theme}>\\n      <Form />\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={theme === 'dark'}\\n          onChange={(e) => {\\n            setTheme(e.target.checked ? 'dark' : 'light')\\n          }}\\n        />\\n        Use dark mode\\n      </label>\\n    </ThemeContext.Provider>\\n  )\\n}\\n\\nfunction Form({ children }) {\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      <Button>Sign up</Button>\\n      <Button>Log in</Button>\\n    </Panel>\\n  );\\n}\\n\\nfunction Panel({ title, children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'panel-' + theme;\\n  return (\\n    <section className={className}>\\n      <h1>{title}</h1>\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'button-' + theme;\\n  return (\\n    <button className={className}>\\n      {children}\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n  margin-bottom: 10px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"注意，\",[\"$r\",\"code\",null,{\"children\":\"value=\\\"dark\\\"\"}],\" 传递 \",[\"$r\",\"code\",null,{\"children\":\"\\\"dark\\\"\"}],\" 字符串，但 \",[\"$r\",\"code\",null,{\"children\":\"value={theme}\"}],\" 传递带有 \",[\"$r\",\"a\",null,{\"href\":\"/learn/javascript-in-jsx-with-curly-braces\",\"children\":\"JSX 花括号\"}],\" 的 JavaScript \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 变量的值。花括号还允许传递非字符串的 context 值。\"]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"updating-an-object-via-context\",\"children\":\"通过 context 更新对象 \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，有一个 \",[\"$r\",\"code\",null,{\"children\":\"currentUser\"}],\" 状态变量，它包含一个对象。将 \",[\"$r\",\"code\",null,{\"children\":\"{ currentUser, setCurrentUser }\"}],\" 组合成一个对象，并通过 context 在 \",[\"$r\",\"code\",null,{\"children\":\"value={}\"}],\" 中向下传递。这允许下面的任何组件，如 \",[\"$r\",\"code\",null,{\"children\":\"LoginButton\"}],\"，同时读取 \",[\"$r\",\"code\",null,{\"children\":\"currentUser\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"setCurrentUser\"}],\"，然后在需要时调用 \",[\"$r\",\"code\",null,{\"children\":\"setCurrentUser\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\n\\nconst CurrentUserContext = createContext(null);\\n\\nexport default function MyApp() {\\n  const [currentUser, setCurrentUser] = useState(null);\\n  return (\\n    <CurrentUserContext.Provider\\n      value={{\\n        currentUser,\\n        setCurrentUser\\n      }}\\n    >\\n      <Form />\\n    </CurrentUserContext.Provider>\\n  );\\n}\\n\\nfunction Form({ children }) {\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      <LoginButton />\\n    </Panel>\\n  );\\n}\\n\\nfunction LoginButton() {\\n  const {\\n    currentUser,\\n    setCurrentUser\\n  } = useContext(CurrentUserContext);\\n\\n  if (currentUser !== null) {\\n    return <p>You logged in as {currentUser.name}.</p>;\\n  }\\n\\n  return (\\n    <Button onClick={() => {\\n      setCurrentUser({ name: 'Advika' })\\n    }}>Log in as Advika</Button>\\n  );\\n}\\n\\nfunction Panel({ title, children }) {\\n  return (\\n    <section className=\\\"panel\\\">\\n      <h1>{title}</h1>\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ children, onClick }) {\\n  return (\\n    <button className=\\\"button\\\" onClick={onClick}>\\n      {children}\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\n  display: block;\\n}\\n\\n.panel {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n  margin-bottom: 10px;\\n}\\n\\n.button {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"multiple-contexts\",\"children\":\"同时使用多个 context \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，存在两个独立的 context。\",[\"$r\",\"code\",null,{\"children\":\"ThemeContext\"}],\" 提供了当前的主题，它是一个字符串，而 \",[\"$r\",\"code\",null,{\"children\":\"CurrentUserContext\"}],\" 保存了代表当前用户的对象。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\n\\nconst ThemeContext = createContext(null);\\nconst CurrentUserContext = createContext(null);\\n\\nexport default function MyApp() {\\n  const [theme, setTheme] = useState('light');\\n  const [currentUser, setCurrentUser] = useState(null);\\n  return (\\n    <ThemeContext.Provider value={theme}>\\n      <CurrentUserContext.Provider\\n        value={{\\n          currentUser,\\n          setCurrentUser\\n        }}\\n      >\\n        <WelcomePanel />\\n        <label>\\n          <input\\n            type=\\\"checkbox\\\"\\n            checked={theme === 'dark'}\\n            onChange={(e) => {\\n              setTheme(e.target.checked ? 'dark' : 'light')\\n            }}\\n          />\\n          Use dark mode\\n        </label>\\n      </CurrentUserContext.Provider>\\n    </ThemeContext.Provider>\\n  )\\n}\\n\\nfunction WelcomePanel({ children }) {\\n  const {currentUser} = useContext(CurrentUserContext);\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      {currentUser !== null ?\\n        <Greeting /> :\\n        <LoginForm />\\n      }\\n    </Panel>\\n  );\\n}\\n\\nfunction Greeting() {\\n  const {currentUser} = useContext(CurrentUserContext);\\n  return (\\n    <p>You logged in as {currentUser.name}.</p>\\n  )\\n}\\n\\nfunction LoginForm() {\\n  const {setCurrentUser} = useContext(CurrentUserContext);\\n  const [firstName, setFirstName] = useState('');\\n  const [lastName, setLastName] = useState('');\\n  const canLogin = firstName.trim() !== '' && lastName.trim() !== '';\\n  return (\\n    <>\\n      <label>\\n        First name{': '}\\n        <input\\n          required\\n          value={firstName}\\n          onChange={e => setFirstName(e.target.value)}\\n        />\\n      </label>\\n      <label>\\n        Last name{': '}\\n        <input\\n        required\\n          value={lastName}\\n          onChange={e => setLastName(e.target.value)}\\n        />\\n      </label>\\n      <Button\\n        disabled={!canLogin}\\n        onClick={() => {\\n          setCurrentUser({\\n            name: firstName + ' ' + lastName\\n          });\\n        }}\\n      >\\n        Log in\\n      </Button>\\n      {!canLogin && <i>Fill in both fields.</i>}\\n    </>\\n  );\\n}\\n\\nfunction Panel({ title, children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'panel-' + theme;\\n  return (\\n    <section className={className}>\\n      <h1>{title}</h1>\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ children, disabled, onClick }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'button-' + theme;\\n  return (\\n    <button\\n      className={className}\\n      disabled={disabled}\\n      onClick={onClick}\\n    >\\n      {children}\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\n  display: block;\\n}\\n\\n.panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n  margin-bottom: 10px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"extracting-providers-to-a-component\",\"children\":\"把 provider 抽离成组件 \"}],[\"$r\",\"p\",null,{\"children\":[\"随着你的应用增长，预计你会有一个像“金字塔”一样的 context 出现在靠近你应用的根部。这样没什么问题。然而，如果你从审美上不喜欢这种嵌套，你可以将 provider 抽离成单独的组件。在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"MyProviders\"}],\" 隐藏了“管路”，并且在需要的 provider 中渲染传递给它的子节点。请注意，\",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 本身需要 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"setTheme\"}],\" 状态，因此 \",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 仍然拥有这部分的状态。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\n\\nconst ThemeContext = createContext(null);\\nconst CurrentUserContext = createContext(null);\\n\\nexport default function MyApp() {\\n  const [theme, setTheme] = useState('light');\\n  return (\\n    <MyProviders theme={theme} setTheme={setTheme}>\\n      <WelcomePanel />\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={theme === 'dark'}\\n          onChange={(e) => {\\n            setTheme(e.target.checked ? 'dark' : 'light')\\n          }}\\n        />\\n        Use dark mode\\n      </label>\\n    </MyProviders>\\n  );\\n}\\n\\nfunction MyProviders({ children, theme, setTheme }) {\\n  const [currentUser, setCurrentUser] = useState(null);\\n  return (\\n    <ThemeContext.Provider value={theme}>\\n      <CurrentUserContext.Provider\\n        value={{\\n          currentUser,\\n          setCurrentUser\\n        }}\\n      >\\n        {children}\\n      </CurrentUserContext.Provider>\\n    </ThemeContext.Provider>\\n  );\\n}\\n\\nfunction WelcomePanel({ children }) {\\n  const {currentUser} = useContext(CurrentUserContext);\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      {currentUser !== null ?\\n        <Greeting /> :\\n        <LoginForm />\\n      }\\n    </Panel>\\n  );\\n}\\n\\nfunction Greeting() {\\n  const {currentUser} = useContext(CurrentUserContext);\\n  return (\\n    <p>You logged in as {currentUser.name}.</p>\\n  )\\n}\\n\\nfunction LoginForm() {\\n  const {setCurrentUser} = useContext(CurrentUserContext);\\n  const [firstName, setFirstName] = useState('');\\n  const [lastName, setLastName] = useState('');\\n  const canLogin = firstName !== '' && lastName !== '';\\n  return (\\n    <>\\n      <label>\\n        First name{': '}\\n        <input\\n          required\\n          value={firstName}\\n          onChange={e => setFirstName(e.target.value)}\\n        />\\n      </label>\\n      <label>\\n        Last name{': '}\\n        <input\\n        required\\n          value={lastName}\\n          onChange={e => setLastName(e.target.value)}\\n        />\\n      </label>\\n      <Button\\n        disabled={!canLogin}\\n        onClick={() => {\\n          setCurrentUser({\\n            name: firstName + ' ' + lastName\\n          });\\n        }}\\n      >\\n        Log in\\n      </Button>\\n      {!canLogin && <i>Fill in both fields.</i>}\\n    </>\\n  );\\n}\\n\\nfunction Panel({ title, children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'panel-' + theme;\\n  return (\\n    <section className={className}>\\n      <h1>{title}</h1>\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ children, disabled, onClick }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'button-' + theme;\\n  return (\\n    <button\\n      className={className}\\n      disabled={disabled}\\n      onClick={onClick}\\n    >\\n      {children}\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\n  display: block;\\n}\\n\\n.panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n  margin-bottom: 10px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"scaling-up-with-context-and-a-reducer\",\"children\":\"使用 context 和 reducer 进行扩展 \"}],[\"$r\",\"p\",null,{\"children\":[\"在大型应用程序中，通常将 context 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useReducer\",\"children\":\"reducer\"}],\" 结合起来从组件中抽离与某种状态相关的逻辑。在本例中，所有的“线路”都隐藏在 \",[\"$r\",\"code\",null,{\"children\":\"TasksContext.js\"}],\" 中，它包含一个 reducer 和两个单独 context。\"]}],[\"$r\",\"p\",null,{\"children\":[\"阅读这个例子的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/scaling-up-with-reducer-and-context\",\"children\":\"完整演示。\"}]]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import AddTask from './AddTask.js';\\nimport TaskList from './TaskList.js';\\nimport { TasksProvider } from './TasksContext.js';\\n\\nexport default function TaskApp() {\\n  return (\\n    <TasksProvider>\\n      <h1>Day off in Kyoto</h1>\\n      <AddTask />\\n      <TaskList />\\n    </TasksProvider>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TasksContext.js\",\"children\":\"import { createContext, useContext, useReducer } from 'react';\\n\\nconst TasksContext = createContext(null);\\n\\nconst TasksDispatchContext = createContext(null);\\n\\nexport function TasksProvider({ children }) {\\n  const [tasks, dispatch] = useReducer(\\n    tasksReducer,\\n    initialTasks\\n  );\\n\\n  return (\\n    <TasksContext.Provider value={tasks}>\\n      <TasksDispatchContext.Provider value={dispatch}>\\n        {children}\\n      </TasksDispatchContext.Provider>\\n    </TasksContext.Provider>\\n  );\\n}\\n\\nexport function useTasks() {\\n  return useContext(TasksContext);\\n}\\n\\nexport function useTasksDispatch() {\\n  return useContext(TasksDispatchContext);\\n}\\n\\nfunction tasksReducer(tasks, action) {\\n  switch (action.type) {\\n    case 'added': {\\n      return [...tasks, {\\n        id: action.id,\\n        text: action.text,\\n        done: false\\n      }];\\n    }\\n    case 'changed': {\\n      return tasks.map(t => {\\n        if (t.id === action.task.id) {\\n          return action.task;\\n        } else {\\n          return t;\\n        }\\n      });\\n    }\\n    case 'deleted': {\\n      return tasks.filter(t => t.id !== action.id);\\n    }\\n    default: {\\n      throw Error('Unknown action: ' + action.type);\\n    }\\n  }\\n}\\n\\nconst initialTasks = [\\n  { id: 0, text: 'Philosopher’s Path', done: true },\\n  { id: 1, text: 'Visit the temple', done: false },\\n  { id: 2, text: 'Drink matcha', done: false }\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js\",\"children\":\"import { useState, useContext } from 'react';\\nimport { useTasksDispatch } from './TasksContext.js';\\n\\nexport default function AddTask() {\\n  const [text, setText] = useState('');\\n  const dispatch = useTasksDispatch();\\n  return (\\n    <>\\n      <input\\n        placeholder=\\\"Add task\\\"\\n        value={text}\\n        onChange={e => setText(e.target.value)}\\n      />\\n      <button onClick={() => {\\n        setText('');\\n        dispatch({\\n          type: 'added',\\n          id: nextId++,\\n          text: text,\\n        }); \\n      }}>Add</button>\\n    </>\\n  );\\n}\\n\\nlet nextId = 3;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js\",\"children\":\"import { useState, useContext } from 'react';\\nimport { useTasks, useTasksDispatch } from './TasksContext.js';\\n\\nexport default function TaskList() {\\n  const tasks = useTasks();\\n  return (\\n    <ul>\\n      {tasks.map(task => (\\n        <li key={task.id}>\\n          <Task task={task} />\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n\\nfunction Task({ task }) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  const dispatch = useTasksDispatch();\\n  let taskContent;\\n  if (isEditing) {\\n    taskContent = (\\n      <>\\n        <input\\n          value={task.text}\\n          onChange={e => {\\n            dispatch({\\n              type: 'changed',\\n              task: {\\n                ...task,\\n                text: e.target.value\\n              }\\n            });\\n          }} />\\n        <button onClick={() => setIsEditing(false)}>\\n          Save\\n        </button>\\n      </>\\n    );\\n  } else {\\n    taskContent = (\\n      <>\\n        {task.text}\\n        <button onClick={() => setIsEditing(true)}>\\n          Edit\\n        </button>\\n      </>\\n    );\\n  }\\n  return (\\n    <label>\\n      <input\\n        type=\\\"checkbox\\\"\\n        checked={task.done}\\n        onChange={e => {\\n          dispatch({\\n            type: 'changed',\\n            task: {\\n              ...task,\\n              done: e.target.checked\\n            }\\n          });\\n        }}\\n      />\\n      {taskContent}\\n      <button onClick={() => {\\n        dispatch({\\n          type: 'deleted',\\n          id: task.id\\n        });\\n      }}>\\n        Delete\\n      </button>\\n    </label>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\nli { list-style-type: none; }\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"80\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"specifying-a-fallback-default-value\",\"children\":\"指定后备方案默认值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 React 没有在父树中找到该特定 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"context\"}],\" 的任何 provider，\",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 返回的 context 值将等于你在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createContext\",\"children\":\"创建 context\"}],\" 时指定的 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"默认值\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 1, \\\"ThemeContext\\\"], [3, 1, \\\"null\\\"]]\",\"children\":\"const ThemeContext = createContext(null);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"默认值 \",[\"$r\",\"strong\",null,{\"children\":\"从不改变\"}],\"。如果你想要更新 context，请按 \",[\"$r\",\"a\",null,{\"href\":\"#updating-data-passed-via-context\",\"children\":\"上述方式\"}],\" 将其与状态一起使用。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常，除了 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，还有一些更有意义的值可以用作默认值，例如：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 1, \\\"ThemeContext\\\"], [3, 1, \\\"light\\\"]]\",\"children\":\"const ThemeContext = createContext('light');\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这样，如果你不小心渲染了没有相应 provider 的某个组件，它也不会出错。这也有助于你的组件在测试环境中很好地运行，而无需在测试中设置许多 provider。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在下面的例子中，“Toggle theme”按钮总是处于 light 状态，因为它位于 \",[\"$r\",\"strong\",null,{\"children\":\"任何主题的 context provider 之外\"}],\"，且 context 主题的默认值是 \",[\"$r\",\"code\",null,{\"children\":\"'light'\"}],\"。试着编辑默认主题为 \",[\"$r\",\"code\",null,{\"children\":\"'dark'\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\n\\nconst ThemeContext = createContext('light');\\n\\nexport default function MyApp() {\\n  const [theme, setTheme] = useState('light');\\n  return (\\n    <>\\n      <ThemeContext.Provider value={theme}>\\n        <Form />\\n      </ThemeContext.Provider>\\n      <Button onClick={() => {\\n        setTheme(theme === 'dark' ? 'light' : 'dark');\\n      }}>\\n        Toggle theme\\n      </Button>\\n    </>\\n  )\\n}\\n\\nfunction Form({ children }) {\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      <Button>Sign up</Button>\\n      <Button>Log in</Button>\\n    </Panel>\\n  );\\n}\\n\\nfunction Panel({ title, children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'panel-' + theme;\\n  return (\\n    <section className={className}>\\n      <h1>{title}</h1>\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ children, onClick }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'button-' + theme;\\n  return (\\n    <button className={className} onClick={onClick}>\\n      {children}\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n  margin-bottom: 10px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"92\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"overriding-context-for-a-part-of-the-tree\",\"children\":\"覆盖组件树一部分的 context \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通过在 provider 中使用不同的值包装树的某个部分，可以覆盖该部分的 context。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,5}\",\"children\":\"<ThemeContext.Provider value=\\\"dark\\\">\\n  ...\\n  <ThemeContext.Provider value=\\\"light\\\">\\n    <Footer />\\n  </ThemeContext.Provider>\\n  ...\\n</ThemeContext.Provider>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可以根据需要多次嵌套和覆盖 provider。\"}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"Examples of overriding context\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"overriding-a-theme\",\"children\":\"覆盖主题 \"}],[\"$r\",\"p\",null,{\"children\":[\"这里，与 \",[\"$r\",\"code\",null,{\"children\":\"Footer\"}],\" 外的值为（\",[\"$r\",\"code\",null,{\"children\":\"\\\"dark\\\"\"}],\"）的按钮相比，\",[\"$r\",\"strong\",null,{\"children\":\"里面\"}],\" 的按钮接收到一个不一样的 context 值（\",[\"$r\",\"code\",null,{\"children\":\"\\\"light\\\"\"}],\"）。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext } from 'react';\\n\\nconst ThemeContext = createContext(null);\\n\\nexport default function MyApp() {\\n  return (\\n    <ThemeContext.Provider value=\\\"dark\\\">\\n      <Form />\\n    </ThemeContext.Provider>\\n  )\\n}\\n\\nfunction Form() {\\n  return (\\n    <Panel title=\\\"Welcome\\\">\\n      <Button>Sign up</Button>\\n      <Button>Log in</Button>\\n      <ThemeContext.Provider value=\\\"light\\\">\\n        <Footer />\\n      </ThemeContext.Provider>\\n    </Panel>\\n  );\\n}\\n\\nfunction Footer() {\\n  return (\\n    <footer>\\n      <Button>Settings</Button>\\n    </footer>\\n  );\\n}\\n\\nfunction Panel({ title, children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'panel-' + theme;\\n  return (\\n    <section className={className}>\\n      {title && <h1>{title}</h1>}\\n      {children}\\n    </section>\\n  )\\n}\\n\\nfunction Button({ children }) {\\n  const theme = useContext(ThemeContext);\\n  const className = 'button-' + theme;\\n  return (\\n    <button className={className}>\\n      {children}\\n    </button>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"footer {\\n  margin-top: 20px;\\n  border-top: 1px solid #aaa;\\n}\\n\\n.panel-light,\\n.panel-dark {\\n  border: 1px solid black;\\n  border-radius: 4px;\\n  padding: 20px;\\n}\\n.panel-light {\\n  color: #222;\\n  background: #fff;\\n}\\n\\n.panel-dark {\\n  color: #fff;\\n  background: rgb(23, 32, 42);\\n}\\n\\n.button-light,\\n.button-dark {\\n  border: 1px solid #777;\\n  padding: 5px;\\n  margin-right: 10px;\\n  margin-top: 10px;\\n}\\n\\n.button-dark {\\n  background: #222;\\n  color: #fff;\\n}\\n\\n.button-light {\\n  background: #fff;\\n  color: #222;\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"automatically-nested-headings\",\"children\":\"自动嵌套标题 \"}],[\"$r\",\"p\",null,{\"children\":[\"在嵌套使用 context provider 时，可以“累积”信息。在此示例中，\",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 组件记录了 \",[\"$r\",\"code\",null,{\"children\":\"LevelContext\"}],\"，该 context 指定了 section 嵌套的深度。它从父级 section 中读取 \",[\"$r\",\"code\",null,{\"children\":\"LevelContext\"}],\"，然后把 \",[\"$r\",\"code\",null,{\"children\":\"LevelContext\"}],\" 的数值加一传递给子级。因此，\",[\"$r\",\"code\",null,{\"children\":\"Heading\"}],\" 组件可以根据被 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 组件嵌套的层数自动决定使用 \",[\"$r\",\"code\",null,{\"children\":\"<h1>\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"<h2>\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"<h3>\"}],\"，…，中的哪种标签。\"]}],[\"$r\",\"p\",null,{\"children\":[\"阅读此示例的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"详细演示\"}]]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import Heading from './Heading.js';\\nimport Section from './Section.js';\\n\\nexport default function Page() {\\n  return (\\n    <Section>\\n      <Heading>Title</Heading>\\n      <Section>\\n        <Heading>Heading</Heading>\\n        <Heading>Heading</Heading>\\n        <Heading>Heading</Heading>\\n        <Section>\\n          <Heading>Sub-heading</Heading>\\n          <Heading>Sub-heading</Heading>\\n          <Heading>Sub-heading</Heading>\\n          <Section>\\n            <Heading>Sub-sub-heading</Heading>\\n            <Heading>Sub-sub-heading</Heading>\\n            <Heading>Sub-sub-heading</Heading>\\n          </Section>\\n        </Section>\\n      </Section>\\n    </Section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Section.js\",\"children\":\"import { useContext } from 'react';\\nimport { LevelContext } from './LevelContext.js';\\n\\nexport default function Section({ children }) {\\n  const level = useContext(LevelContext);\\n  return (\\n    <section className=\\\"section\\\">\\n      <LevelContext.Provider value={level + 1}>\\n        {children}\\n      </LevelContext.Provider>\\n    </section>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Heading.js\",\"children\":\"import { useContext } from 'react';\\nimport { LevelContext } from './LevelContext.js';\\n\\nexport default function Heading({ children }) {\\n  const level = useContext(LevelContext);\\n  switch (level) {\\n    case 0:\\n      throw Error('Heading must be inside a Section!');\\n    case 1:\\n      return <h1>{children}</h1>;\\n    case 2:\\n      return <h2>{children}</h2>;\\n    case 3:\\n      return <h3>{children}</h3>;\\n    case 4:\\n      return <h4>{children}</h4>;\\n    case 5:\\n      return <h5>{children}</h5>;\\n    case 6:\\n      return <h6>{children}</h6>;\\n    default:\\n      throw Error('Unknown level: ' + level);\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/LevelContext.js\",\"children\":\"import { createContext } from 'react';\\n\\nexport const LevelContext = createContext(0);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".section {\\n  padding: 10px;\\n  margin: 5px;\\n  border-radius: 5px;\\n  border: 1px solid #aaa;\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"optimizing-re-renders-when-passing-objects-and-functions\",\"children\":\"在传递对象和函数时优化重新渲染 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可以通过 context 传递任何值，包括对象和函数。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 10, \\\"{ currentUser, login }\\\"]] \",\"children\":\"function MyApp() {\\n  const [currentUser, setCurrentUser] = useState(null);\\n\\n  function login(response) {\\n    storeCredentials(response.credentials);\\n    setCurrentUser(response.user);\\n  }\\n\\n  return (\\n    <AuthContext.Provider value={{ currentUser, login }}>\\n      <Page />\\n    </AuthContext.Provider>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"此处，\",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"context value\"}],\" 是一个具有两个属性的 JavaScript 对象，其中一个是函数。每当 \",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 出现重新渲染（例如，路由更新）时，这里将会是一个 \",[\"$r\",\"strong\",null,{\"children\":\"不同的\"}],\" 对象指向 \",[\"$r\",\"strong\",null,{\"children\":\"不同的\"}],\" 函数，因此 React 还必须重新渲染树中调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext(AuthContext)\"}],\" 的所有组件。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在较小的应用程序中，这不是问题。但是，如果基础数据如 \",[\"$r\",\"code\",null,{\"children\":\"currentUser\"}],\" 没有更改，则不需要重新渲染它们。为了帮助 React 利用这一点，你可以使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useCallback\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useCallback\"}]}],\" 包装 \",[\"$r\",\"code\",null,{\"children\":\"login\"}],\" 函数，并将对象创建包装到 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\" 中。这是一个性能优化的例子：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6,9,11,14,17}\",\"children\":\"import { useCallback, useMemo } from 'react';\\n\\nfunction MyApp() {\\n  const [currentUser, setCurrentUser] = useState(null);\\n\\n  const login = useCallback((response) => {\\n    storeCredentials(response.credentials);\\n    setCurrentUser(response.user);\\n  }, []);\\n\\n  const contextValue = useMemo(() => ({\\n    currentUser,\\n    login\\n  }), [currentUser, login]);\\n\\n  return (\\n    <AuthContext.Provider value={contextValue}>\\n      <Page />\\n    </AuthContext.Provider>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"根据以上改变，即使 \",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 需要重新渲染，调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext(AuthContext)\"}],\" 的组件也不需要重新渲染，除非 \",[\"$r\",\"code\",null,{\"children\":\"currentUser\"}],\" 发生了变化。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读更多关于 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo#skipping-re-rendering-of-components\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useCallback#skipping-re-rendering-of-components\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useCallback\"}]}],\" 的内容。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-component-doesnt-see-the-value-from-my-provider\",\"children\":\"我的组件获取不到 provider 传递的值\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这里有几种常见的情况会引起这个问题：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你在调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 的同一组件（或下层）渲染 \",[\"$r\",\"code\",null,{\"children\":\"<SomeContext.Provider>\"}],\"。把 \",[\"$r\",\"code\",null,{\"children\":\"<SomeContext.Provider>\"}],\" 向调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 组件 \",[\"$r\",\"strong\",null,{\"children\":\"之上和之外\"}],\" 移动。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你可能忘记了使用 \",[\"$r\",\"code\",null,{\"children\":\"<SomeContext.Provider>\"}],\" 包装组件，或者你可能将组件放在树的不同部分。使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/react-developer-tools\",\"children\":\"React DevTools\"}],\" 检查组件树的层级是否正确。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你的工具可能会遇到一些构建问题，导致你在传值组件中的所看到的 \",[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\" 和读值组件中所看到的 \",[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\" 是两个不同的对象。例如，如果使用符号链接，就会发生这种情况。你可以通过将它们赋值给全局对象如 \",[\"$r\",\"code\",null,{\"children\":\"window.SomeContext1\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"window.SomeContext2\"}],\" 来验证这种情况。然后在控制台检查 \",[\"$r\",\"code\",null,{\"children\":\"window.SomeContext1 === window.SomeContext2\"}],\" 是否相等。如果它们是不相等的，就在构建工具层面修复这个问题。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different\",\"children\":[\"尽管设置了不一样的默认值，但是我总是从 context 中得到 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可能在组件树中有一个没有设置 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\" 的 provider：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,2}\",\"children\":\"// 🚩 不起作用：没有 value 作为 prop\\n<ThemeContext.Provider>\\n   <Button />\\n</ThemeContext.Provider>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你忘记了指定 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\"，它会像这样传值 \",[\"$r\",\"code\",null,{\"children\":\"value={undefined}\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可能还错误地使用了一个不同的 prop 名：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,2}\",\"children\":\"// 🚩 不起作用：prop 应该是“value”\\n<ThemeContext.Provider theme={theme}>\\n   <Button />\\n</ThemeContext.Provider>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这两种情况下，你都应该在控制台中看到 React 发出的警告。要解决这些问题，使用 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\" 作为 prop：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,2}\",\"children\":\"// ✅ 传递 value 作为 prop\\n<ThemeContext.Provider value={theme}>\\n   <Button />\\n</ThemeContext.Provider>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"注意，只有在 \",[\"$r\",\"strong\",null,{\"children\":\"上层根本没有匹配的 provider\"}],\" 时才使用 \",[\"$r\",\"a\",null,{\"href\":\"#specifying-a-fallback-default-value\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"createContext(defaultValue)\"}],\"调用的默认值\"]}],\"。如果存在 \",[\"$r\",\"code\",null,{\"children\":\"<SomeContext.Provider value={undefined}>\"}],\" 组件在父树的某个位置，调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext(SomeContext)\"}],\" 的组件 \",[\"$r\",\"strong\",null,{\"children\":\"将会\"}],\" 接收到 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 作为 context 的值。\"]}]]}]]","meta":{"title":"useContext"}},"__N_SSG":true}