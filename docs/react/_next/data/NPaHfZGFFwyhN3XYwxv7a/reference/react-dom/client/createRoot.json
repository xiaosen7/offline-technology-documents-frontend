{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#createroot\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"createRoot(domNode, options?)\"}],\" \"]},{\"url\":\"#root-render\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"root.render(reactNode)\"}],\" \"]},{\"url\":\"#root-unmount\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"root.unmount()\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#rendering-an-app-fully-built-with-react\",\"depth\":3,\"text\":\"渲染一个完全由 React 构建的应用 \"},{\"url\":\"#rendering-a-page-partially-built-with-react\",\"depth\":3,\"text\":\"渲染一个部分由 React 构建的应用 \"},{\"url\":\"#updating-a-root-component\",\"depth\":3,\"text\":\"更新一个根组件 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"错误排查 \"},{\"url\":\"#ive-created-a-root-but-nothing-is-displayed\",\"depth\":3,\"text\":\"我已经创建了一个根节点，但是页面没有显示任何内容 \"},{\"url\":\"#im-getting-an-error-target-container-is-not-a-dom-element\",\"depth\":3,\"text\":\"我得到了一个异常报错信息：“目标容器不是一个 DOM 元素（Target container is not a DOM element）” \"},{\"url\":\"#im-getting-an-error-functions-are-not-valid-as-a-react-child\",\"depth\":3,\"text\":\"我得到了一个异常报错信息：“函数不是合法的 React 子项（Functions are not valid as a React child）” \"},{\"url\":\"#我的服务端渲染的-html-在更新时会全部重新创建\",\"depth\":3,\"text\":\"我的服务端渲染的 HTML 在更新时会全部重新创建 \"}]","content":"[[\"$r\",\"MaxWidth\",\"100\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\" 允许在浏览器的 DOM 节点中创建根节点以显示 React 组件。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const root = createRoot(domNode, options?)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"createroot\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"createRoot(domNode, options?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\" 以在浏览器 DOM 元素中创建根节点显示内容。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createRoot } from 'react-dom/client';\\n\\nconst domNode = document.getElementById('root');\\nconst root = createRoot(domNode);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 将会为 \",[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\" 创建一个根节点，并控制其中的 DOM。在已经创建根节点之后，需要调用 \",[\"$r\",\"a\",null,{\"href\":\"#root-render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"root.render\"}]}],\" 来显示 React 组件：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"root.render(<App />);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"对于一个完全用 React 构建的应用程序，通常会调用一个 \",[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\" 来创建它的根节点。而对于一个使用了“少量” React 来创建部分内容的应用程序，则要按具体需求来确定根节点的数量。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\"：一个 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DOM 元素\"}],\"。React 将为这个 DOM 元素创建一个根节点然后允许你在这个根节点上调用函数，比如 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 来显示渲染的 React 内容。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"options\"}],\"：用于配置这个 React 根节点的对象。\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"onRecoverableError\"}],\"：回调函数，在 React 从异常错误中恢复时自动调用。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"identifierPrefix\"}],\"：一个 React 用来配合 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useId\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useId\"}]}],\" 生成 id 的字符串前缀。在同一个页面上使用多个根节点的场景下，这将能有效避免冲突。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\" 返回一个带有两个方法的的对象，这两个方法是：\",[\"$r\",\"a\",null,{\"href\":\"#root-render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"#root-unmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"unmount\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果应用程序是服务端渲染的，那么不能使用 \",[\"$r\",\"code\",null,{\"children\":\"createRoot()\"}],\"。请使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/hydrateRoot\",\"children\":[\"$r\",\"code\",null,{\"children\":\"hydrateRoot()\"}]}],\" 替代它。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在你的应用程序中，可能只调用了一次 \",[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\"。但如果你使用了框架，它可能已经自动帮你完成了这次调用。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"当你想要渲染一段 JSX，但是它存在于 DOM 树的其他位置，并非当前组件的子组件时（比如，一个弹窗或者提示框），使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/createPortal\",\"children\":[\"$r\",\"code\",null,{\"children\":\"createPortal\"}]}],\" 替代 \",[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"root-render\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"root.render(reactNode)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 以将一段 \",[\"$r\",\"a\",null,{\"href\":\"/learn/writing-markup-with-jsx\",\"children\":\"JSX\"}],\"（“React 节点”）在 React 的根节点中渲染为 DOM 节点并显示。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"root.render(<App />);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 将会在 \",[\"$r\",\"code\",null,{\"children\":\"根节点\"}],\" 中显示 \",[\"$r\",\"code\",null,{\"children\":\"<App />\"}],\" 组件，并且控制组件中的 DOM。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"root-render-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"reactNode\"}],\"：一个你想要显示的 \",[\"$r\",\"strong\",null,{\"children\":\"React 节点\"}],\"。它总是一段 JSX，就像 \",[\"$r\",\"code\",null,{\"children\":\"<App />\"}],\"，但是你也总是可以传递一个 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createElement\",\"children\":[\"$r\",\"code\",null,{\"children\":\"createElement()\"}]}],\" 构造的 React 元素、一个字符串、一个数字、\",[\"$r\",\"code\",null,{\"children\":\"null\"}],\" 或者 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"root-render-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 返回 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"root-render-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"首次调用 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 时，React 会先清空根节点中所有已经存在的 HTML，然后才会渲染 React 组件。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你的根节点包含了由 React 在构建期间通过服务端渲染生成的 HTML 内容，请使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/hydrateRoot\",\"children\":[\"$r\",\"code\",null,{\"children\":\"hydrateRoot()\"}]}],\" 替代这个方法，这样才能把事件处理程序和现有的 HTML 绑定。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你在一个根节点上多次调用了 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\"，React 仍然会更新 DOM，这样才能保证显示的内容是最新的。React 将会筛选出可复用的部分和需要更新的部分，对于需要更新的部分，是 React 通过与之前渲染的树进行 \",[\"$r\",\"a\",null,{\"href\":\"/learn/preserving-and-resetting-state\",\"children\":\"“比较”\"}],\" 得到的。在同一个根节点上再次调用 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 就和在根节点上调用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState#setstate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数\"]}],\" 类似：React 会避免没必要的 DOM 更新。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"root-unmount\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"root.unmount()\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"root.unmount\"}],\" 以销毁 React 根节点中的一个已经渲染的树。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"root.unmount();\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常情况下，一个完全由 React 构建的应用程序不会调用 \",[\"$r\",\"code\",null,{\"children\":\"root.unmount\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"此方法适用的场景是，React 根节点中的 DOM 节点（或者它的任何一个父级节点）被除了这个方法以外的代码移除了。举个例子，试想在一个 jQuery 选项卡面板中，非活跃状态的选项卡的 DOM 结构将被移除。一个标签页被移除时，它内部的所有内容（包括 React 根节点）也将会从 DOM 树移除。在这种情况下，你才需要调用 \",[\"$r\",\"code\",null,{\"children\":\"root.unmount\"}],\" 来通知 React “停止”控制已经被移除的根节点的内容。否则，被移除的根节点的内部组件就不能及时释放消息订阅等资源。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"root.unmout\"}],\" 将卸载根节点内的所有组件，该根节点上的 React 将被剥离，即所有事件处理程序以及组件树上的状态将被移除。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"root-unmount-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"root.unmount\"}],\" 不接收任何参数。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"root-unmount-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"root.unmount\"}],\" 返回 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"root-unmount-caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"root.unmout\"}],\" 将卸载根节点内的所有组件，该根节点上的 React 将被剥离，即所有事件处理程序以及组件树上的状态将被移除。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"一旦调用 \",[\"$r\",\"code\",null,{\"children\":\"root.unmout\"}],\"，就不能在该根节点上调用 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\"。在一个已经卸载的根节点上尝试调用 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 将会抛出异常错误信息“无法更新一个未挂载的根节点（Cannot update an unmouted root）”。不过，你可以在卸载一个根节点后又重新创建它。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-an-app-fully-built-with-react\",\"children\":\"渲染一个完全由 React 构建的应用 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果应用程序是完全由 React 构建的，那么请为整个应用程序创建全局唯一的一个根节点。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 3, \\\"document.getElementById('root')\\\"], [2, 4, \\\"<App />\\\"]]\",\"children\":\"import { createRoot } from 'react-dom/client';\\n\\nconst root = createRoot(document.getElementById('root'));\\nroot.render(<App />);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通常情况下，在项目启动阶段，你只需要运行下面的代码。它将会：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"获取 HTML 中定义的\",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"DOM 节点\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"在该 DOM 节点中显示 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"React 组件\"}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"index.html\",\"children\":\"<!DOCTYPE html>\\n<html>\\n  <head><title>My app</title></head>\\n  <body>\\n    <!-- 这就是我们提到的 DOM 节点 -->\\n    <div id=\\\"root\\\"></div>\\n  </body>\\n</html>\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js active\",\"children\":\"import { createRoot } from 'react-dom/client';\\nimport App from './App.js';\\nimport './styles.css';\\n\\nconst root = createRoot(document.getElementById('root'));\\nroot.render(<App />);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <h1>你好，世界!</h1>\\n      <Counter />\\n    </>\\n  );\\n}\\n\\nfunction Counter() {\\n  const [count, setCount] = useState(0);\\n  return (\\n    <button onClick={() => setCount(count + 1)}>\\n      点击了 {count} 次\\n    </button>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"118\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"如果你的应用程序完全由 React 构建，你仅应该创建全局唯一的一个根节点，并只调用一次 \",[\"$r\",\"a\",null,{\"href\":\"#root-render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"root.render\"}]}]]}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"从这时起，React 将会控制整个应用程序的 DOM。如果要添加更多组件，\",[\"$r\",\"a\",null,{\"href\":\"/learn/importing-and-exporting-components\",\"children\":[\"可以将它们嵌套进 \",[\"$r\",\"code\",null,{\"children\":\"App\"}],\" 组件中\"]}],\"。如果你需要更新视图，每一个组件都可以通过使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"state\"}],\" 做到这一点。如果你需要额外显示一些在这个 DOM 节点之外的内容，比如一个弹窗或者提示框，那么可以 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/createPortal\",\"children\":\"使用 portal 进行渲染\"}],\"。\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"当 HTML 为空时，用户将会看一个空白的页面，直到应用程序中的 JavaScript 代码加载并运行：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"children\":\"<div id=\\\"root\\\"></div>\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"这个过程太慢了！要解决这个问题，可以在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/server\",\"children\":\"服务端或者应用构建期间\"}],\" 通过组件生成一些初始 HTML。这样一来，在 JavaScript 加载之前，用户就能看到一些文字、图片，也能点击链接。我们推荐 \",[\"$r\",\"a\",null,{\"href\":\"/learn/start-a-new-react-project#production-grade-react-frameworks\",\"children\":\"使用框架\"}],\"，通过框架开箱即用的能力轻易地完成这个优化。根据框架运行的时机，分为 \",[\"$r\",\"strong\",null,{\"children\":\"服务端渲染（SSR）\"}],\" 和 \",[\"$r\",\"strong\",null,{\"children\":\"静态站点生成（SSG）\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"使用了服务端渲染或者静态站点生成的应用程序，必须调用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/hydrateRoot\",\"children\":[\"$r\",\"code\",null,{\"children\":\"hydrateRoot\"}]}],\" 而不是 \",[\"$r\",\"code\",null,{\"children\":\"createRoot\"}]]}],\"。调用后，React 将会 \",[\"$r\",\"strong\",null,{\"children\":\"hydrate\"}],\" HTML 中的 DOM 节点，而不是销毁后重新创建它们。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-a-page-partially-built-with-react\",\"children\":\"渲染一个部分由 React 构建的应用 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果页面 \",[\"$r\",\"a\",null,{\"href\":\"/learn/add-react-to-an-existing-project#using-react-for-a-part-of-your-existing-page\",\"children\":\"不完全是 React 构建的\"}],\"，可以多次调用 \",[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\" 为每一个由 React 管理的顶级视图片段，即一段 DOM 中的顶级节点，创建一个根节点。可以在每一个根节点中调用 \",[\"$r\",\"a\",null,{\"href\":\"#root-render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"root.render\"}]}],\" 来显示不同的内容。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这样依赖，两个不同的 React 组件分别在同一个文件 \",[\"$r\",\"code\",null,{\"children\":\"index.html\"}],\" 内定义的两个 DOM 节点中被渲染：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"public/index.html\",\"children\":\"<!DOCTYPE html>\\n<html>\\n  <head><title>My app</title></head>\\n  <body>\\n    <nav id=\\\"navigation\\\"></nav>\\n    <main>\\n      <p>这一段不会被 React 渲染（可以打开 index.html 验证这一点）。</p>\\n      <section id=\\\"comments\\\"></section>\\n    </main>\\n  </body>\\n</html>\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js active\",\"children\":\"import './styles.css';\\nimport { createRoot } from 'react-dom/client';\\nimport { Comments, Navigation } from './Components.js';\\n\\nconst navDomNode = document.getElementById('navigation');\\nconst navRoot = createRoot(navDomNode); \\nnavRoot.render(<Navigation />);\\n\\nconst commentDomNode = document.getElementById('comments');\\nconst commentRoot = createRoot(commentDomNode); \\ncommentRoot.render(<Comments />);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Components.js\",\"children\":\"export function Navigation() {\\n  return (\\n    <ul>\\n      <NavLink href=\\\"/\\\">Home</NavLink>\\n      <NavLink href=\\\"/about\\\">About</NavLink>\\n    </ul>\\n  );\\n}\\n\\nfunction NavLink({ href, children }) {\\n  return (\\n    <li>\\n      <a href={href}>{children}</a>\\n    </li>\\n  );\\n}\\n\\nexport function Comments() {\\n  return (\\n    <>\\n      <h2>Comments</h2>\\n      <Comment text=\\\"你好!\\\" author=\\\"Sophie\\\" />\\n      <Comment text=\\\"最近怎么样?\\\" author=\\\"Sunil\\\" />\\n    </>\\n  );\\n}\\n\\nfunction Comment({ text, author }) {\\n  return (\\n    <p>{text} — <i>{author}</i></p>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"nav ul { padding: 0; margin: 0; }\\nnav ul li { display: inline-block; margin-right: 20px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"136\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"也可以通过 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createElement\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"document.createElement()\"}]}],\" 创建一个新的 DOM 节点然后手动将其加入页面文档之中。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const domNode = document.createElement('div');\\nconst root = createRoot(domNode); \\nroot.render(<Comment />);\\ndocument.body.appendChild(domNode); // 你可以把它加入到页面文档的任何位置\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"a\",null,{\"href\":\"#root-unmount\",\"children\":[\"$r\",\"code\",null,{\"children\":\"root.unmount\"}]}],\" 将从 DOM 节点移除这个 React 树并清除它使用的资源。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"root.unmount();\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果 React 组件处于一个由不同框架构建的应用程序之中时，那么这个方法将会非常有用。\"}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"updating-a-root-component\",\"children\":\"更新一个根组件 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"可以在同一个根节点上多次调用 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\"。只要当前的组件树结构与之前渲染的结果是一致的，React 将会 \",[\"$r\",\"a\",null,{\"href\":\"/learn/preserving-and-resetting-state\",\"children\":\"保存 state\"}],\"。仔细思考一下，为什么能在输入框中正常输入？正如下方的示例，在每一秒中内多次重复调用 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 后发生的更新，是非破坏性的：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js active\",\"children\":\"import { createRoot } from 'react-dom/client';\\nimport './styles.css';\\nimport App from './App.js';\\n\\nconst root = createRoot(document.getElementById('root'));\\n\\nlet i = 0;\\nsetInterval(() => {\\n  root.render(<App counter={i} />);\\n  i++;\\n}, 1000);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"export default function App({counter}) {\\n  return (\\n    <>\\n      <h1>你好，世界！{counter}</h1>\\n      <input placeholder=\\\"在这里输入一些内容\\\" />\\n    </>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"多次调用 \",[\"$r\",\"code\",null,{\"children\":\"render\"}],\" 是一个不常见的事情。通常情况下，你的组件将通过 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"更新 state\"}],\" 达到同样的效果。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"错误排查 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"ive-created-a-root-but-nothing-is-displayed\",\"children\":\"我已经创建了一个根节点，但是页面没有显示任何内容 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"确保你没有忘记在根节点上 \",[\"$r\",\"strong\",null,{\"children\":\"渲染\"}],\" 你的应用程序：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5}\",\"children\":\"import { createRoot } from 'react-dom/client';\\nimport App from './App.js';\\n\\nconst root = createRoot(document.getElementById('root'));\\nroot.render(<App />);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在你进行渲染之前，页面不会显示任何内容。\"}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"im-getting-an-error-target-container-is-not-a-dom-element\",\"children\":\"我得到了一个异常报错信息：“目标容器不是一个 DOM 元素（Target container is not a DOM element）” \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个异常错误即字面意思，你传递给 \",[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\" 的内容不是一个 DOM 元素。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果你不确定发生了什么，试着在控制台打印它：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2}\",\"children\":\"const domNode = document.getElementById('root');\\nconsole.log(domNode); // ？？？\\nconst root = createRoot(domNode);\\nroot.render(<App />);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"举个例子，如果 \",[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\" 是 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，代表着 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementById\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"getElementById\"}]}],\" 返回了 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。这意味着你在调用这个方法的时候，页面文档内并不存在指定的 id 对应的元素，于是就出现了这个问题。这里有一些可能的原因：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"你使用的 id 可能和 HTML 文件中的 id 不同。请检查一下你的拼写是否正确！\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"打包构建产物的 HTML 文件中的 \",[\"$r\",\"code\",null,{\"children\":\"<script>\"}],\" 标签，不能感知到在它执行 \",[\"$r\",\"strong\",null,{\"children\":\"之后\"}],\" 才出现的 DOM 节点。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"触发这个异常报错的另一个常见方式是，将 \",[\"$r\",\"code\",null,{\"children\":\"createRoot(domNode)\"}],\" 错写成 \",[\"$r\",\"code\",null,{\"children\":\"createRoot(<App />)\"}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"im-getting-an-error-functions-are-not-valid-as-a-react-child\",\"children\":\"我得到了一个异常报错信息：“函数不是合法的 React 子项（Functions are not valid as a React child）” \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个错误意味着，你传递给 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 的内容不是一个 React 组件。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这可能发生在你使用 \",[\"$r\",\"code\",null,{\"children\":\"Component\"}],\" 而不是 \",[\"$r\",\"code\",null,{\"children\":\"<Component />\"}],\" 作为参数对 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 进行调用时：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,5}\",\"children\":\"// 🚩 错误方式：App 是一个函数，不是一个组件。\\nroot.render(App);\\n\\n// ✅ 正确方式：<App /> 是一个组件。\\nroot.render(<App />);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"或者你向 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 传递了一个函数本身，而不是其返回值：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,5}\",\"children\":\"// 🚩 错误方式：createApp 是一个函数，不是一个组件。\\nroot.render(createApp);\\n\\n// ✅ 正确方式：使用 createApp 执行后返回的组件。\\nroot.render(createApp());\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"我的服务端渲染的-html-在更新时会全部重新创建\",\"children\":\"我的服务端渲染的 HTML 在更新时会全部重新创建 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你的应用程序是服务端渲染的，并且包含了由 React 生成的初始 HTML，你可能会注意到，在创建一个根节点后调用 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 时会删除所有初始 HTML，然后重新生成所有 DOM 节点。这可能会让你的应用变得比客户端渲染更慢，并且在用户输入失去焦点和滑动滚动条时丢失用户输入的内容。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"服务端渲染的应用程序必须使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/hydrateRoot\",\"children\":[\"$r\",\"code\",null,{\"children\":\"hydrateRoot\"}]}],\" 替代 \",[\"$r\",\"code\",null,{\"children\":\"createRoot\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,4-7}\",\"children\":\"import { hydrateRoot } from 'react-dom/client';\\nimport App from './App.js';\\n\\nhydrateRoot(\\n  document.getElementById('root'),\\n  <App />\\n);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，服务端渲染的 API 是不同的。特别注意，在通常情况下，不会再有 \",[\"$r\",\"code\",null,{\"children\":\"root.render\"}],\" 调用。\"]}]]}]]","meta":{"title":"createRoot"}},"__N_SSG":true}