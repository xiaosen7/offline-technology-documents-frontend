{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#hydrate\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"hydrate(reactNode, domNode, callback?)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#hydrating-server-rendered-html\",\"depth\":3,\"text\":\"hydrate 服务器渲染的 HTML \"},{\"url\":\"#suppressing-unavoidable-hydration-mismatch-errors\",\"depth\":3,\"text\":\"抑制不可避免的 hydrate 不匹配错误 \"},{\"url\":\"#handling-different-client-and-server-content\",\"depth\":3,\"text\":\"处理不同的客户端和服务器内容 \"}]","content":"[[\"$r\",\"MaxWidth\",\"48\",{\"children\":[[\"$r\",\"Deprecated\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"此 API 将在未来的 React 主要版本中被移除。\"}],[\"$r\",\"p\",null,{\"children\":[\"从 React 18 开始，\",[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\" 被 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/hydrateRoot\",\"children\":[\"$r\",\"code\",null,{\"children\":\"hydrateRoot\"}]}],\" 替代。在 React 18 或更高版本中使用 \",[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\" 将会警告你的应用程序行为会和 React 17 一样。如果你想了解更多，请看 \",[\"$r\",\"a\",null,{\"href\":\"/blog/2022/03/08/react-18-upgrade-guide#updates-to-client-rendering-apis\",\"children\":\"这里\"}],\"。\"]}]]}],\"\\n\",[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\" 允许你在 React 17 及以下版本中将使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/server\",\"children\":[\"$r\",\"code\",null,{\"children\":\"react-dom/server\"}]}],\" 生成的 HTML 内容作为浏览器 DOM 节点，并在其中显示 React 组件。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"hydrate(reactNode, domNode, callback?)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"hydrate\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"hydrate(reactNode, domNode, callback?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 React 17 及以下版本中调用 \",[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\"，可以将 React “附加”到在服务器环境中已经由 React 渲染的现有 HTML 上。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { hydrate } from 'react-dom';\\n\\nhydrate(reactNode, domNode);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 将会附加到 \",[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\" 内部现有的 HTML，并接管有关的 DOM 的管理。使用 React 完全构建的应用通常只会有一个 \",[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\" 调用，并用于根组件。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下面更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"reactNode\"}],\"：此参数用于渲染现有的 HTML。这通常是像 \",[\"$r\",\"code\",null,{\"children\":\"<App />\"}],\" 这样的 JSX 片段，并且在 React 17 中使用如 \",[\"$r\",\"code\",null,{\"children\":\"renderToString(<App />)\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"ReactDOM Server\"}],\" 方法进行渲染。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\"：在服务器中被渲染为根节点的 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"DOM 元素\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选属性\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"callback\"}],\"：一个函数。如果传递了该参数，React 将会在组件 hydrate 后调用它。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\" 返回 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\" 要求渲染的内容与服务器渲染的内容完全相同。尽管 React 可以修复文本内容的差异，但你应该首先将不匹配视为错误并进行修复。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"在开发模式下，React 会在 hydration 期间警告不匹配的错误。如果存在不匹配情况，无法保证属性的差异会被修补。在大多数应用程序中不匹配是很少见的，所以验证所有标记的代价将会很高。因此考虑到性能原因，这是很重要的。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你的应用程序中可能只有一个 \",[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\" 调用。如果你使用了框架，它可能会为你执行此调用。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果你的应用程序是客户端渲染的，并且没有已经渲染的 HTML，则不支持使用 \",[\"$r\",\"code\",null,{\"children\":\"hydrate()\"}],\"。请改用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/render\",\"children\":\"render()\"}],\"（适用于 React 17 及以下版本）或 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/createRoot\",\"children\":\"createRoot()\"}],\"（适用于 React 18 及以上版本）。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\" 将 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"React 组件\"}],\" 附加（attach）到服务器渲染的 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"浏览器 DOM 节点\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 3, \\\"<App />\\\"], [2, 3, \\\"document.getElementById('root')\\\"]]\",\"children\":\"import { hydrate } from 'react-dom';\\n\\nhydrate(<App />, document.getElementById('root'));\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"不支持使用 \",[\"$r\",\"code\",null,{\"children\":\"hydrate()\"}],\" 渲染仅用于客户端的应用程序（没有服务器渲染的 HTML）。请改用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/render\",\"children\":[\"$r\",\"code\",null,{\"children\":\"render()\"}]}],\"（适用于 React 17 及以下版本）或 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/createRoot\",\"children\":[\"$r\",\"code\",null,{\"children\":\"createRoot()\"}]}],\"（适用于 React 18 及以上版本）。\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"hydrating-server-rendered-html\",\"children\":\"hydrate 服务器渲染的 HTML \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在 React 中，hydrate 是指将 React “附加（attach）”到在服务器环境中已由 React 渲染的现有 HTML 上。在 hydrate 期间，React 将尝试将事件监听器附加（attach）到现有标记，并在客户端上接管渲染应用程序。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在完全使用 React 构建的应用程序中，\",[\"$r\",\"strong\",null,{\"children\":\"通常只会在第一次启动整个应用程序时，hydrate “根”节点\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"public/index.html\",\"children\":\"<!--\\n  `<div id=\\\"root\\\">...</div>` 中的 HTML 内容是\\n  由 `react-dom/server` 从 `App` 生成的。\\n-->\\n<div id=\\\"root\\\"><h1>你好，世界！</h1></div>\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js active\",\"children\":\"import './styles.css';\\nimport { hydrate } from 'react-dom';\\nimport App from './App.js';\\n\\nhydrate(<App />, document.getElementById('root'));\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"export default function App() {\\n  return <h1>你好，世界！</h1>;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"62\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常情况下，你不需要再次调用 \",[\"$r\",\"code\",null,{\"children\":\"hydrate\"}],\"，也不需要在更多地方调用它。从此时开始，React 将会管理你的应用程序的 DOM。为了更新 UI，你的组件将会 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"使用 state\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"有关 hydrate 的更多信息，请参阅 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/hydrateRoot\",\"children\":[\"$r\",\"code\",null,{\"children\":\"hydrateRoot\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"suppressing-unavoidable-hydration-mismatch-errors\",\"children\":\"抑制不可避免的 hydrate 不匹配错误 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果服务器和客户端之间某个元素的属性或文本内容无法避免不同（比如一个时间戳），你可以禁止 hydrate 警告。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"使用 \",[\"$r\",\"code\",null,{\"children\":\"suppressHydrationWarning={true}\"}],\" 禁止 hydrate 警告：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"public/index.html\",\"children\":\"<!--\\n  `<div id=\\\"root\\\">...</div>` 中的 HTML 内容是\\n  由 `react-dom/server` 从 `App` 生成的。\\n-->\\n<div id=\\\"root\\\"><h1>当前时间：01/01/2020</h1></div>\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js\",\"children\":\"import './styles.css';\\nimport { hydrate } from 'react-dom';\\nimport App from './App.js';\\n\\nhydrate(<App />, document.getElementById('root'));\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js active\",\"children\":\"export default function App() {\\n  return (\\n    <h1 suppressHydrationWarning={true}>\\n      当前时间：{new Date().toLocaleDateString()}\\n    </h1>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"72\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这只在同级深度上有效，而且是一种脱围机制，因此不要过度使用它。除非它是文本内容，否则 React 仍然不会尝试修补它，因此直至未来的更新它都可能会保持不一致。\"}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"handling-different-client-and-server-content\",\"children\":\"处理不同的客户端和服务器内容 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果需要在服务器和客户端上故意渲染不同的内容，可以进行双重渲染。在客户端上渲染不同内容的组件可以读取像 \",[\"$r\",\"code\",null,{\"children\":\"isClient\"}],\" 这样的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"state 变量\"}],\"，你可以在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":\"effect\"}],\" 中将其设置为 \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\"：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"public/index.html\",\"children\":\"<!--\\n  `<div id=\\\"root\\\">...</div>` 中的 HTML 内容是\\n  由 `react-dom/server` 从 `App` 生成的。\\n-->\\n<div id=\\\"root\\\"><h1>在服务器</h1></div>\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js\",\"children\":\"import './styles.css';\\nimport { hydrate } from 'react-dom';\\nimport App from './App.js';\\n\\nhydrate(<App />, document.getElementById('root'));\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js active\",\"children\":\"import { useState, useEffect } from \\\"react\\\";\\n\\nexport default function App() {\\n  const [isClient, setIsClient] = useState(false);\\n\\n  useEffect(() => {\\n    setIsClient(true);\\n  }, []);\\n\\n  return (\\n    <h1>\\n      {isClient ? '在客户端' : '在服务器'}\\n    </h1>\\n  );\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这样，初始渲染过程将呈现与服务器相同的内容，并且避免不匹配的情况，但会在 hydrate 后立即同步并进行额外的渲染。\"}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"这种方法会使 hydrate 变慢，因为你的组件必须渲染两次，因此要注意在网络不好情况下的用户体验。JavaScript 代码的加载可能比初始 HTML 渲染要晚许多，因此在 hydrate 后立即渲染不同的 UI 可能会让用户感到不适。\"}]}]]}]]","meta":{"title":"hydrate"}},"__N_SSG":true}