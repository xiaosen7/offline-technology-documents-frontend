{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#createportal\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"createPortal(children, domNode, key?)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#rendering-to-a-different-part-of-the-dom\",\"depth\":3,\"text\":\"渲染到 DOM 的不同部分 \"},{\"url\":\"#rendering-a-modal-dialog-with-a-portal\",\"depth\":3,\"text\":\"使用 portal 渲染模态对话框 \"},{\"url\":\"#rendering-react-components-into-non-react-server-markup\",\"depth\":3,\"text\":\"将 React 组件渲染到非 React 服务器标记中 \"},{\"url\":\"#rendering-react-components-into-non-react-dom-nodes\",\"depth\":3,\"text\":\"将 React 组件渲染到非 React DOM 节点 \"}]","content":"[[\"$r\",\"MaxWidth\",\"46\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 允许你将 JSX 作为 children 渲染至 DOM 的不同部分。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<div>\\n  <SomeComponent />\\n  {createPortal(children, domNode, key?)}\\n</div>\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"createportal\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"createPortal(children, domNode, key?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 创建 portal，并传入 JSX 与实际渲染的目标 DOM 节点：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createPortal } from 'react-dom';\\n\\n// ...\\n\\n<div>\\n  <p>这个子节点被放置在父节点 div 中。</p>\\n  {createPortal(\\n    <p>这个子节点被放置在 document body 中。</p>,\\n    document.body\\n  )}\\n</div>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"portal 只改变 DOM 节点的所处位置。在其他方面，渲染至 portal 的 JSX 的行为表现与作为 React 组件的子节点一致。该子节点可以访问由父节点树提供的 context 对象、事件将从子节点依循 React 树冒泡到父节点。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\"：React 可以渲染的任何内容，如 JSX 片段（\",[\"$r\",\"code\",null,{\"children\":\"<div />\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"<SomeComponent />\"}],\" 等等）、\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Fragment\",\"children\":\"Fragment\"}],\"（\",[\"$r\",\"code\",null,{\"children\":\"<>...</>\"}],\"）、字符串或数字，以及这些内容构成的数组。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\"：某个已经存在的 DOM 节点，例如由 \",[\"$r\",\"code\",null,{\"children\":\"document.getElementById()\"}],\" 返回的节点。在更新过程中传递不同的 DOM 节点将导致 portal 内容被重建。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选参数\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"：用作 portal \",[\"$r\",\"a\",null,{\"href\":\"/learn/rendering-lists/#keeping-list-items-in-order-with-key\",\"children\":\"key\"}],\" 的独特字符串或数字。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 返回一个可以包含在 JSX 中或从 React 组件中返回的 React 节点。如果 React 在渲染输出中遇见它，它将把提供的 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 放入提供的 \",[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\" 中。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"警告 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"portal 中的事件传播遵循 React 树而不是 DOM 树。例如点击 \",[\"$r\",\"code\",null,{\"children\":\"<div onClick>\"}],\" 内部的 portal，将触发 \",[\"$r\",\"code\",null,{\"children\":\"onClick\"}],\" 处理程序。如果这会导致意外的问题，请在 portal 内部停止事件传播，或将 portal 移动到 React 树中的上层。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-to-a-different-part-of-the-dom\",\"children\":\"渲染到 DOM 的不同部分 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"em\",null,{\"children\":\"portal\"}],\" 允许组件将它们的某些子元素渲染到 DOM 中的不同位置。这使得组件的一部分可以“逃脱”它所在的容器。例如组件可以在页面其余部分上方或外部显示模态对话框和提示框。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 并传入 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"JSX\"}],\" 与 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\" 应该放置的 DOM 节点\"}],\" 作为参数，然后渲染返回值以创建 portal：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 8, \\\"<p>这个子节点被放置在 document body 中。</p>\\\"], [2, 9, \\\"document.body\\\"]]\",\"children\":\"import { createPortal } from 'react-dom';\\n\\nfunction MyComponent() {\\n  return (\\n    <div style={{ border: '2px solid black' }}>\\n      <p>这个子节点被放置在父节点 div 中。</p>\\n      {createPortal(\\n        <p>这个子节点被放置在 document body 中。</p>,\\n        document.body\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 将 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"传递的 JSX\"}],\" 对应的 DOM 节点放入 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"提供的 DOM 节点\"}],\" 中。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果没有 portal，第二个 \",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\" 将放置在父级 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 中，但 portal 会将其“传送”到 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/body\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"document.body\"}]}],\" 中：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createPortal } from 'react-dom';\\n\\nexport default function MyComponent() {\\n  return (\\n    <div style={{ border: '2px solid black' }}>\\n      <p>这个子节点被放置在父节点 div 中。</p>\\n      {createPortal(\\n        <p>这个子节点被放置在 document body 中。</p>,\\n        document.body\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"62\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，第二个段落在视觉上出现在带有边框的父级 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 之外。如果你使用开发者工具检查 DOM 结构，会发现第二个 \",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\" 直接放置在 \",[\"$r\",\"code\",null,{\"children\":\"<body>\"}],\" 中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"{4-6,9}\",\"children\":\"<body>\\n  <div id=\\\"root\\\">\\n    ...\\n      <div style=\\\"border: 2px solid black\\\">\\n        <p>这个子节点被放置在父节点 div 中。</p>\\n      </div>\\n    ...\\n  </div>\\n  <p>这个子节点被放置在 document body 中。</p>\\n</body>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"portal 只改变 DOM 节点的所处位置。在其他方面，portal 中的 JSX 将作为实际渲染它的 React 组件的子节点。该子节点可以访问由父节点树提供的 context 对象、事件将仍然从子节点冒泡到父节点树。\"}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-a-modal-dialog-with-a-portal\",\"children\":\"使用 portal 渲染模态对话框 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以使用 portal 创建一个浮动在页面其余部分之上的模态对话框，即使呼出对话框的组件位于带有 \",[\"$r\",\"code\",null,{\"children\":\"overflow: hidden\"}],\" 或其他干扰对话框样式的容器中。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在此示例中，这两个容器具有破坏模态对话框的样式，但是渲染到 portal 中的容器不受影响，因为在 DOM 中，模态对话框不包含在父 JSX 元素内部。\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js active\",\"children\":\"import NoPortalExample from './NoPortalExample';\\nimport PortalExample from './PortalExample';\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <div className=\\\"clipping-container\\\">\\n        <NoPortalExample  />\\n      </div>\\n      <div className=\\\"clipping-container\\\">\\n        <PortalExample />\\n      </div>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/NoPortalExample.js\",\"children\":\"import { useState } from 'react';\\nimport ModalContent from './ModalContent.js';\\n\\nexport default function NoPortalExample() {\\n  const [showModal, setShowModal] = useState(false);\\n  return (\\n    <>\\n      <button onClick={() => setShowModal(true)}>\\n        不使用 portal 展示模态（modal）\\n      </button>\\n      {showModal && (\\n        <ModalContent onClose={() => setShowModal(false)} />\\n      )}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/PortalExample.js active\",\"children\":\"import { useState } from 'react';\\nimport { createPortal } from 'react-dom';\\nimport ModalContent from './ModalContent.js';\\n\\nexport default function PortalExample() {\\n  const [showModal, setShowModal] = useState(false);\\n  return (\\n    <>\\n      <button onClick={() => setShowModal(true)}>\\n        使用 portal 展示模态（motal）\\n      </button>\\n      {showModal && createPortal(\\n        <ModalContent onClose={() => setShowModal(false)} />,\\n        document.body\\n      )}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ModalContent.js\",\"children\":\"export default function ModalContent({ onClose }) {\\n  return (\\n    <div className=\\\"modal\\\">\\n      <div>这是一个模态对话框</div>\\n      <button onClick={onClose}>关闭</button>\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"meta\":\"src/styles.css\",\"children\":\".clipping-container {\\n  position: relative;\\n  border: 1px solid #aaa;\\n  margin-bottom: 12px;\\n  padding: 12px;\\n  width: 250px;\\n  height: 80px;\\n  overflow: hidden;\\n}\\n\\n.modal {\\n  display: flex;\\n  justify-content: space-evenly;\\n  align-items: center;\\n  box-shadow: rgba(100, 100, 111, 0.3) 0px 7px 29px 0px;\\n  background-color: white;\\n  border: 2px solid rgb(240, 240, 240);\\n  border-radius: 12px;\\n  position:  absolute;\\n  width: 250px;\\n  top: 70px;\\n  left: calc(50% - 125px);\\n  bottom: 70px;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"72\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"使用 portal 时，确保应用程序的无障碍性非常重要。例如，你可能需要管理键盘焦点，以便用户可以自然进出 portal。\"}],[\"$r\",\"p\",null,{\"children\":[\"创建模态对话框时，请遵循 \",[\"$r\",\"a\",null,{\"href\":\"https://www.w3.org/WAI/ARIA/apg/#dialog_modal\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"WAI-ARIA 模态实践指南\"}],\"。如果你使用了社区包，请确保它具有无障碍性，并遵循这些指南。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-react-components-into-non-react-server-markup\",\"children\":\"将 React 组件渲染到非 React 服务器标记中 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果静态或服务端渲染的网站中只有某一部分使用 React，则 portal 可能非常有用。如果你的页面使用 Rails 等服务端框架构建，则可以在静态区域（例如侧边栏）中创建交互区域。与拥有 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/createRoot#rendering-a-page-partially-built-with-react\",\"children\":\"多个独立的 React 根\"}],\" 相比，portal 将应用程序视为一个单一的 React 树，即使它的部分在 DOM 的不同部分渲染，也可以共享状态。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"index.html\",\"children\":\"<!DOCTYPE html>\\n<html>\\n  <head><title>我的应用程序</title></head>\\n  <body>\\n    <h1>我的网站一部分使用了 React，另外一部分没有使用</h1>\\n    <div class=\\\"parent\\\">\\n      <div class=\\\"sidebar\\\">\\n        这是一个非 React 服务器标记\\n        <div id=\\\"sidebar-content\\\"></div>\\n      </div>\\n      <div id=\\\"root\\\"></div>\\n    </div>\\n  </body>\\n</html>\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js\",\"children\":\"import { StrictMode } from 'react';\\nimport { createRoot } from 'react-dom/client';\\nimport App from './App.js';\\nimport './styles.css';\\n\\nconst root = createRoot(document.getElementById('root'));\\nroot.render(\\n  <StrictMode>\\n    <App />\\n  </StrictMode>\\n);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js active\",\"children\":\"import { createPortal } from 'react-dom';\\n\\nconst sidebarContentEl = document.getElementById('sidebar-content');\\n\\nexport default function App() {\\n  return (\\n    <>\\n      <MainContent />\\n      {createPortal(\\n        <SidebarContent />,\\n        sidebarContentEl\\n      )}\\n    </>\\n  );\\n}\\n\\nfunction MainContent() {\\n  return <p>这一部分是被 React 渲染的。</p>;\\n}\\n\\nfunction SidebarContent() {\\n  return <p>这一部分也是被 React 渲染的！</p>;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".parent {\\n  display: flex;\\n  flex-direction: row;\\n}\\n\\n#root {\\n  margin-top: 12px;\\n}\\n\\n.sidebar {\\n  padding:  12px;\\n  background-color: #eee;\\n  width: 200px;\\n  height: 200px;\\n  margin-right: 12px;\\n}\\n\\n#sidebar-content {\\n  margin-top: 18px;\\n  display: block;\\n  background-color: white;\\n}\\n\\np {\\n  margin: 0;\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"92\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-react-components-into-non-react-dom-nodes\",\"children\":\"将 React 组件渲染到非 React DOM 节点 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你还可以使用 portal 来管理在 React 之外管理的 DOM 节点的内容。假设你正在集成非 React 地图小部件，并且想要在弹出窗口中渲染 React 内容，那么可以声明一个 \",[\"$r\",\"code\",null,{\"children\":\"popupContainer\"}],\" state 变量来存储要渲染到的目标 DOM 节点：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [popupContainer, setPopupContainer] = useState(null);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在创建第三方小部件时，存储由小部件返回的 DOM 节点，以便可以将内容渲染到其中：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5-6}\",\"children\":\"useEffect(() => {\\n  if (mapRef.current === null) {\\n    const map = createMapWidget(containerRef.current);\\n    mapRef.current = map;\\n    const popupDiv = addPopupToMapWidget(map);\\n    setPopupContainer(popupDiv);\\n  }\\n}, []);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这样，一旦 \",[\"$r\",\"code\",null,{\"children\":\"popupContainer\"}],\" 可用，就可以使用 \",[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 将 React 内容渲染到其中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-6}\",\"children\":\"return (\\n  <div style={{ width: 250, height: 250 }} ref={containerRef}>\\n    {popupContainer !== null && createPortal(\\n      <p>来自 React 的你，你好！</p>,\\n      popupContainer\\n    )}\\n  </div>\\n);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"以下是一个完整的示例，你可以尝试一下：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"leaflet\\\": \\\"1.9.1\\\",\\n    \\\"react\\\": \\\"latest\\\",\\n    \\\"react-dom\\\": \\\"latest\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"remarkable\\\": \\\"2.0.1\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useRef, useEffect, useState } from 'react';\\nimport { createPortal } from 'react-dom';\\nimport { createMapWidget, addPopupToMapWidget } from './map-widget.js';\\n\\nexport default function Map() {\\n  const containerRef = useRef(null);\\n  const mapRef = useRef(null);\\n  const [popupContainer, setPopupContainer] = useState(null);\\n\\n  useEffect(() => {\\n    if (mapRef.current === null) {\\n      const map = createMapWidget(containerRef.current);\\n      mapRef.current = map;\\n      const popupDiv = addPopupToMapWidget(map);\\n      setPopupContainer(popupDiv);\\n    }\\n  }, []);\\n\\n  return (\\n    <div style={{ width: 250, height: 250 }} ref={containerRef}>\\n      {popupContainer !== null && createPortal(\\n        <p>来自 React 的你，你好！</p>,\\n        popupContainer\\n      )}\\n    </div>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/map-widget.js\",\"children\":\"import 'leaflet/dist/leaflet.css';\\nimport * as L from 'leaflet';\\n\\nexport function createMapWidget(containerDomNode) {\\n  const map = L.map(containerDomNode);\\n  map.setView([0, 0], 0);\\n  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {\\n    maxZoom: 19,\\n    attribution: '© OpenStreetMap'\\n  }).addTo(map);\\n  return map;\\n}\\n\\nexport function addPopupToMapWidget(map) {\\n  const popupDiv = document.createElement('div');\\n  L.popup()\\n    .setLatLng([0, 0])\\n    .setContent(popupDiv)\\n    .openOn(map);\\n  return popupDiv;\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\n\"}]}]]}]]","meta":{"title":"createPortal"}},"__N_SSG":true}